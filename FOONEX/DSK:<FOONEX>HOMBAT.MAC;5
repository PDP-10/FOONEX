;DSK:<FOONEX>HOMBAT.PEF;3  8-Jul-80 14:25:45, Edit by FRENCH
;INSURE PRIMARY BAT WRITTEN TO DISK WHEN INITIALIZED
;DSK:<PEFMON>HOMBAT.MAC;19 12-Jun-80 12:42:24, Edit by FRENCH
;HANDLE UDSKIO ERROR IF ERROR BITS RETURNED IN AC 1
;DSK:<PEFMON>HOMBAT.MAC;18  9-Jun-80 13:47:57, Edit by FRENCH
;DON'T LET DEDRM CLOBBER 5,6 IN NTRBAT
;DSK:<PEFMON>HOMBAT.MAC;16  9-Jun-80 13:38:44, Edit by FRENCH
;DEDRM RETURNS +3 FOR SUCCESS, HANDLE IT
;ADD LOGIC FOR "BAD BUT IN USE" TABLES
;DSK:<FOONEX>HOMBAT.MAC;2  4-Jun-80 15:45:42, Edit by FRENCH
;RENAME SUPPORT STUFF FOR NO CNOFLICT WITH MACSYM STUFF
;DSK:<PEFMON>HOMBAT.MAC;35 29-May-80 13:46:51, Edit by FRENCH
;DON'T LEAVE ANY LOGICAL PACK IDENT IN BAT BLOCKS SO TRANSPORTABLE
;DSK:<PEFMON>HOMBAT.MAC;25 14-May-80 17:34:44, Edit by FRENCH
;ADDED HOMBAT PARAMETER TABLE FOR GETAB
;MOVE HDWR DISK ADR FORMAT SPEC TO PARAMS
;DSK:<PEFMON>HOMBAT.MAC;23 14-May-80 14:19:01, Edit by FRENCH
;SINCE DSKABT IN PARAMS NOW, USE IT SYMBOLICLLY INSTEAD OF 1B14

;HOME BLOCK AND BAT BLOCK STUFF

	SEARCH	STENEX,PROLOG
	TITLE	HOMBAT

INTERN HOMBAT,NHOMBA
INTERN XB1TBL,XB2TBL
INTERN HM1TBL,HM2TBL,BB1TBL,BB2TBL
INTERN MCDTBL,MICTBL,BOTTBL
INTERN MONADR,CDLADR,CDHADR
INTERN CRTHMA,CRTHOM,CRTBAA,CRTBAT,CRTBFA,CRTBAF
INTERN CRTSFA,DEFDIA
INTERN DOBDSA,DOBDRA,DOBDDA,DOBAT
INTERN NTRBAT
INTERN CRASH,RELOAD

EXTERN DSKASA,DSKASN,DEDSK,DSKDTB,NSECPG,SWPTK,SWPTKH,NSECTK
EXTERN UDSKIO
EXTERN ASDRMS,DEDRM,DRMFRE,DRMSEC,DRMBND
EXTERN CVDSK,CDSKVA,CVADSW
EXTERN DIDSCA,DIDSCI,FDDSCA,FILIFG
EXTERN ASOFN,ASGPAG,SETMPG,RELPAG,RELOFN,FPTA,MLKPG,MULKPG
EXTERN GETFDB,USTDIR,JFNOFN
EXTERN BUGCHK,BUGHLT
EXTERN SYSGO,DBUGSW

	RESCD

;MODULE FLAGS

BATDBG:	Z		;NON-0 TO ALLOW INIT OF GOOD BATS WHEN DBUGSW/ 2
BATMAX:	^D500		;MAX BAD SPOTS CDC SAYS WE WILL SEE


;STORAGE

LS (HBXSTF)		;NON-ZERO IF HOMBAT FILES EXIST ON ALL PACKS


;WARNING: THE FOLLOWING MACROS USE ACS 14,15 BUT ARE RESTORED
;	  OUTSIDE THE CONTEXT OF THE SUPPORT PROCESSORS.
;	  .A16 IS ALWAYS CLOBBERED

.A16==16			;SCRATCH AC

.FPV==15			;FRAME PTR FOR VARMAC

;TRANSIENT VARIABLE MACRO

DEFINE VARMAC (VARS)<
	..VRR==10		;;REMEMBER CURRENT RADIX
	RADIX 8
	..VNV==1		;;INIT COUNT OF STACK WORDS
	IRP VARS,<
	  .VAR1 (VARS)>		;;PROCESS LIST
	JSP .A16,.VRSET		;;ALLOCATE STACK SPACE, SETUP .FP
	 ..VNV-1,,..VNV-1
	RADIX ..VRR		;;RESTORE RADIX
	PURGE ..VRR,..VNV>	;;CLEAN UP

DEFINE .VAR1 (VAR)<
	.VAR2 (VAR)>		;;PEEL OFF ANGLEBRACKETS IF ANY

DEFINE .VAR2 (NAM,SIZ)<
	.VAR3 (NAM,\..VNV)	;;DEFINE VARIABLE
	IFB <SIZ>,<..VNV=..VNV+1>
	IFNB <SIZ>,<..VNV=..VNV+SIZ>>

DEFINE .VAR3 (NAM,LOC)<
   IFDEF NAM,<.IF NAM,SYMBOL,<PRINTX VARMAC NAM ALREADY DEFINED>>
	DEFINE NAM<^O'LOC(.FPV)>>



.FPA==14				;FRAME PTR FOR ACMAC

;AC 1-4 SAVER AND RESTORER

DEFINE ACMAC (ARGS)<
	..ARR==10		;;SAVE RADIX
	RADIX 8
	..ANV==1		;;INIT ARG COUNT
	IRP ARGS,<
	  .ACV1 (ARGS)>		;;DEFINE ARG SYMBOL
	IFG ..ANV-5,<PRINTX ?TOO MANY ARGUMENTS: ARGS>
	JSP .A16,.ACSET		;;SETUP STACK
	RADIX ..ARR		;;RESTORE RADIX
	PURGE ..ARR,..ANV>

DEFINE .ACV1 (VAR)<
	.ACV2 (VAR)>		;;PEEL OFF ANGLEBRACKETS IF ANY

DEFINE .ACV2 (NAM,SIZ)<
	.ACV3 (NAM,\..ANV)	;;DEFINE VARIABLE
	IFB <SIZ>,<..ANV=..ANV+1>
	IFNB <SIZ>,<..ANV=..ANV+SIZ>>

DEFINE .ACV3 (NAM,LOC)<
   IFDEF NAM,<.IF NAM,SYMBOL,<PRINTX ACMAC NAM ALREADY DEFINED>>
	DEFINE NAM<^O'LOC(.FPA)>>



;MACRO TO SAVE FRAME PTRS INCASE SOME ROUTINE CLOBBERS IT

DEFINE SFRAME
<	PUSH P,.FPA
	PUSH P,.FPV
>

;MACRO TO RESTORE FRAME PTRS SAVED BY SFRAME

DEFINE RFRAME
<	POP P,.FPV
	POP P,.FPA
>



;SUPPORT ROUTINE FOR VARMAC

.VRSET::PUSH P,.FPV		;PRESERVE OLD .FPV
	MOVE .FPV,P		;SETUP FRAME PTR
	ADD P,0(.A16)		;ALLOCATE SPACE
	JUMPGE P,VRSOV
VRSET1:	PUSHJ P,1(.A16)		;CONTINUE ROUTINE, EXIT VIA .+1
.VRRET::CAIA			;NO SKIP
	 AOS -1(.FPV)		;SKIP
	MOVEM .FPV,P
	POP P,.FPV
	POPJ P,

VRSOV:	SUB P,0(.A16)		;STACK OVERFLOW - UNDO ADD
	HLL .A16,0(.A16)	;GET COUNT
VRSOV1:	PUSH P,[0]		;DO ONE PUSH AT A TIME, GET REGULAR
	SUB .A16,[1,,0]		; ACTION ON OVERFLOW
	TLNE .A16,777777	;COUNT TO 0?
	JRST VRSOV1		;NO, KEEP PUSHING
	JRST VRSET1		;CONTINUE SETUP


;SUPPORT ROUTINE FOR ACMAC

.ACSET::PUSH P,.FPA		;SAVE .FPA
	MOVE .FPA,P		;SETUP FRAME POINTER
	PUSH P,1		;DO WITH PUSH, GET INTERRUPT...
	PUSH P,2
	PUSH P,3
	PUSH P,4
ACSET1:	PUSHJ P,0(.A16)		;CONTINUE ROUTINE
.ACRET::CAIA			;NO SKIP
	 AOS -1(.FPA)		;SKIP
	POP P,4			;RESTORE ACS
	POP P,3
	POP P,2
	POP P,1
	MOVEM .FPA,P
	POP P,.FPA
	POPJ P,


;ASSEMBLY OF SENSITIVE PAGE HARDWARE ADRS FOR ASSIGNMENT TO ERROR FREE AREA
;ON CDC WINCHESTER DRIVES
;CYL 0, HEADS 0 AND 1 ARE AVAILABLE.
;HEAD 1 IS ASSUMED SAFER THAN HEAD 0 (LESS CHANCE OF HUMAN ERROR CLOBBERING IT)
;CYL 0, HEADS 0 AND 1, SECTOR 0 ARE ASSUMED UNSAFE (MUCH CHANCE OF HUMAN ERROR)


;LAYOUT
;* DENOTES MAY NOT BE PRESENT (USUALLY ONLY FOUND ON PACK 0 OF A STRUCTURE)
;
;CYLINDER 0, HEAD 0 (TRACK 0)
;
;				    SECTOR #
;    0        1         2         3         4         5         6         7
;------------------------------------------------------------------------------
;        !         ! HOMBAT  ! HOME    ! BAT     ! DEFAULT ! CRASH   ! CRASH
;        !         ! FILE 2  ! BLOCK 2 ! BLOCK 2 ! MONITOR ! DMP LOW ! DMP HIGH
;        !         ! XB      !         !         ! XB *    ! XB *    ! XB *
;------------------------------------------------------------------------------
;
;
;CYLINDER 0, HEAD 1 (TRACK 1)
;
;				    SECTOR #
;    0        1         2         3         4         5         6         7
;------------------------------------------------------------------------------
;        !         ! HOMBAT  ! HOME    ! BAT     ! MICRO   ! MICRO   ! BOOT
;        !         ! FILE 1  ! BLOCK 1 ! BLOCK 1 ! CODE    ! DIAG    ! STRAP
;        !         ! XB      !         !         ! XB      ! XB      ! XB
;------------------------------------------------------------------------------


;SENSITIVE PAGE ASSIGNMENT DEFINITIONS

;UNITS

PRMUNT==0		;PRIMARY UNIT OF A STRUCTURE

;CYLINDERS

CYLALL==0		;ALL IN CYLINDER 0

;SURFACES

SRFXB1==1		;PRIMARY HOMBAT XB
SRFHM1==1		;PRIMARY HOMEBLOCK
SRFBB1==1		;PRIMARY BAT BLOCK
SRFXB2==0		;SECONDARY HOMBAT XB
SRFHM2==0		;SECONDARY HOMEBLOCK
SRFBB2==0		;SECONDARY BAT BLOCK
SRFMIC==1		;MICROCODE XB
SRFMCD==1		;MICRO DIAGNOSTICS XB
SRFBOT==1		;BOOTSTRAP XB
SRFMON==0		;DEFAULT MONITOR XB
SRFCDL==0		;CRASH DUMP XB LOW
SRFCDH==0		;CRASH DUMP XB HIGH

;SECTORS

SECXB1==2		;PRIMARY HOMBAT XB
SECHM1==3		;PRIMARY HOMEBLOCK
SECBB1==4		;PRIMARY BAT BLOCK
SECXB2==2		;SECONDARY HOMBAT XB
SECHM2==3		;SECONDARY HOMEBLOCK
SECBB2==4		;SECONDARY BAT BLOCK
SECMIC==5		;MICROCODE XB
SECMCD==6		;MICRO DIAGNOSTICS XB
SECBOT==7		;BOOTSTRAP XB
SECMON==5		;DEFAULT MONITOR XB
SECCDL==6		;CRASH DUMP XB LOW
SECCDH==7		;CRASH DUMP XB HIGH



;TABLE OF INDEX BLOCK ADRS FOR PRIMARY HOMBAT FILES FOR ALL PACKS
;INDEXED BY PACK #

..U==0
XB1TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFXB1>B<SRFLSB>+<SECXB1>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF INDEX BLOCK ADRS FOR SECONDARY HOMBAT FILES FOR ALL PACKS
;INDEXED BY PACK #

..U==0
XB2TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFXB2>B<SRFLSB>+<SECXB2>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF ADRS FOR PRIMARY HOMEBLOCKS FOR ALL PACKS
;INDEXED BY PACK #

..U==0
HM1TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFHM1>B<SRFLSB>+<SECHM1>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF ADRS FOR SECONDARY HOMEBLOCKS FOR ALL PACKS
;INDEXED BY PACK #

..U==0
HM2TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFHM2>B<SRFLSB>+<SECHM2>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF ADRS FOR PRIMARY BATBLOCKS FOR ALL PACKS
;INDEXED BY PACK #

..U==0
BB1TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFBB1>B<SRFLSB>+<SECBB1>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF ADRS FOR SECONDARY BATBLOCKS FOR ALL PACKS
;INDEXED BY PACK #

..U==0
BB2TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFBB2>B<SRFLSB>+<SECBB2>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS


;OTHER SENSITIVE PAGES TO BE ASSIGNED TO ERROR FREE AREAS

;TABLE OF ADRS FOR MICRO CODE FILE FOR ALL PACKS
;INDEXED BY PACK #

..U==0
MICTBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFMIC>B<SRFLSB>+<SECMIC>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS



;TABLE OF ADRS FOR MICRO DIAG FILE FOR ALL PACKS
;INDEXED BY PACK #

..U==0
MCDTBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFMCD>B<SRFLSB>+<SECMCD>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF ADRS FOR BOOTSTRAP FILE FOR ALL PACKS
;INDEXED BY PACK #

..U==0
BOTTBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFBOT>B<SRFLSB>+<SECBOT>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS


;FOUND ON PRIMARY PACK ONLY

;DEFAULT MONITOR INDEX BLOCK ADR

MONADR==<PRMUNT>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFMON>B<SRFLSB>+<SECMON>B<SECLSB>

;CRASH DUMP INDEX BLOCK ADR LOW

CDLADR==<PRMUNT>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFCDL>B<SRFLSB>+<SECCDL>B<SECLSB>


;CRASH DUMP INDEX BLOCK ADR HIGH

CDHADR==<PRMUNT>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFCDH>B<SRFLSB>+<SECCDH>B<SECLSB>



;HOMBLOCK DEFINITIONS

DEFINE DEFHOM (SUFFIX)
<	IRP SUFFIX, <HOM'SUFFIX==..N
		     ..N==..N+1>
>

..N==0		;INIT COUNTER FOR MACRO

DEFHOM <NAM,ID,VER,HW0,HW1,HW2,HW3,HW4>		;00 : 07
DEFHOM <HB1,HB2,MDA,MDF,MCA,MCF,BTA,BTF>	;10 : 17
DEFHOM <MNA,MNF,CLA,CLF,CHA,CHF,SNM,SFG>	;20 : 27
DEFHOM <SPK,PFG,SWP,NX1,NX2,DR1,DR2,SPR>	;30 : 37

..N==HOMLEN-2	;2ND PART INIT COUNTER FOR MACRO

DEFHOM <COD,SLF>				;HOMLEN-2,HOMLEN-1

;PARAMETERS

VERHOM==1		;VERSION
HOMLEN==1000		;FULL PAGE DEVOTED TO HOMEBLOCK
CODHOM==707070


;FLAGS ASSEMBLED INTO HOME BLOCKS

MCDFGS==0		;MICRO DIAG FLAGS
MICFGS==0		;MICRO CODE FLAGS
BOTFGS==0		;BOOTSTRAP FLAGS
MONFGS==0		;DEFAULT MONITOR FLAGS
CDLFGS==0		;CRASH DUMP FLAGS LOW
CDHFGS==0		;CRASH DUMP FLAGS HIGH
STRFGS==0		;STRUCTURE FLAGS
PAKFGS==0		;PACK FLAGS



;HOMEBLOCK PROTOTYPE (.-. TO BE FILLED IN)

HOMPRO:	SIXBIT /HOME/					;HOMNAM
	.-.						;HOMID
	VERHOM,,HOMLEN					;HOMVER
	<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35	;HOMHW0
	NTKUN,,NSURFS					;HOMHW1
	NSECS,,NWSEC					;HOMHW2
	<NTKUN*NSURFS*NSECS>,,<NSURFS*NSECS>		;HOMHW3
	0						;HOMHW4
	.-.						;HOMHB1
	.-.						;HOMHB2
	.-.						;HOMMDA
	MCDFGS						;HOMMDF
	.-.						;HOMMCA
	MICFGS						;HOMMCF
	.-.						;HOMBTA
	BOTFGS						;HOMBTF
	MONADR						;HOMMNA
	MONFGS						;HOMMNF
	CDLADR						;HOMCLA
	CDLFGS						;HOMCLF
	CDHADR						;HOMCHA
	CDHFGS						;HOMCHF
	SIXBIT /PS/					;HOMSNM
	STRFGS						;HOMSFG
	NPACKS,,.-.					;HOMSPK
	PAKFGS						;HOMPFG
	SWPTK,,SWPTKH-1					;HOMSWP

HOMPLN==.-HOMPRO		;LENGTH OF A HOME BLOCK PROTOTYPE



;CALL CRTHOM FOR ALL PACKS

CRTHMA:	PUSH P,1
	PUSH P,2
	HRROI 1,[ASCIZ/
Creating HOME Blocks and associated files./]
	PSOUT
	MOVSI 2,-NPACKS		;AOBJN FOR PACKS
CRTHM1:	HRRZ 1,2		;LOGICAL PACK # IN 1
	CALL CRTHOM
	AOBJN 2,CRTHM1
	POP P,2
	POP P,1
	AOS HBXSTF			;SAY HOMBAT FILES EXIST
	RET

;CREATE HOME BLOCKS FOR PACK
;ACCEPTS LOGICAL PACK # IN 1

CRTHOM:	ACMAC <%UNIT,%AC2,%AC3,%AC4>	;SAVE ACS
	VARMAC <$HBN,$PAGE,$OFN,$JFN>	;RESERVE INFO STUFF
	MOVEI 2,1			;INDEX BLOCK 1
	MOVEM 2,$HBN			;SAVE FOR FUTURE REF
CRTHO1:	MOVE 1,%UNIT
	CALL MPHMXB			;MAP THE INDEX BLOCK
	MOVE 1,%UNIT
	MOVE 2,$HBN
	MOVEM 3,$PAGE			;REMEMBER MAPPED PAGE ADR
	MOVEM 4,$OFN			;AND THE OFN
	CALL STHMXB			;SET UP XB
	MOVE 3,$PAGE
	MOVE 4,$OFN
	CALL RLHMXB			;RELEASE THE XB
	MOVE 1,%UNIT
	MOVE 2,$HBN
	CALL MKHMFL			;MAKE AND RELEASE FILE
	MOVE 1,%UNIT
	MOVE 2,$HBN
	CALL MAPHOM			;NOW USE FILE TO MAP HB
	 BUG (HLT,<CRTHOM: FAILED TO MAP JUST CREATED HB>)
	MOVEM 3,$PAGE			;KNOW PAGE ITS MAPPED TO
	MOVEM 4,$JFN			;KNOW JFN
	MOVE 1,%UNIT
	MOVE 2,$HBN
	CALL FILLHB			;FILL HB
	MOVE 1,%UNIT
	MOVE 2,$HBN
	MOVE 3,$PAGE
	MOVE 4,$JFN
	TLO 3,(1B0)			;INSURE IT GETS TO DISK
	CALL RELHOM			;RELEASE HB
	  BUG (HLT,<CRTHOM: FAILED TO RELEASE HB>)
	AOS 2,$HBN			;DO BOTH PRIMARY AND SECONDARY
	CAIG 2,2
	 JRST CRTHO1			;LOOP FOR NEXT
	RET

	PURGE %UNIT,%AC2,%AC3,%AC4
	PURGE $HBN,$PAGE,$OFN,$JFN


;ASSIGN AND MAP XB FOR HOME BLOCK
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ HOME BLOCK #

;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ OFN

MPHMXB:	MOVEI 0,TYPHOM		;TYPE OF BLOCK ITS FOR
	JRST MAPXB


;FILL OUT HOME XB AND ASSIGN HOME BLOCK SO NOT POINTING TO UNASSIGNED PAGE
;ACCEPTS 1/ LOGICAL PACK #
;	 2/ HOME BLOCK #
;	 3/ PAGE ITS MAPPED TO

STHMXB:	MOVEI 0,TYPHOM
	JRST SETXB


;UNMAP AND RELEASE HOME XB
;ACCEPTS 3/ PAGE ITS MAPPED TO
;	 4/ OFN

RLHMXB:	MOVEI 0,TYPHOM
	JRST RELXB


;CREATES AND RELEASES HOMEBLOCK FILE PTING TO PROPER XB
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ # OF BLOCK INVOLVED

MKHMFL:	MOVEI 0,TYPHOM
	JRST MAKFL


;MAP HOMEBLOCK TO PAGE, READ AND WRITE
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ HB #

;RETURNS 3/ PAGE ADR
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP POSSIBLY WITH ERROR CODE IN 1

MAPHOM:	MOVEI 0,TYPHOM
	SKIPN FILIFG			;OK TO USE FILE SYSTEM YET?
	 JRST MP.BLK			;NO-JUST READ IT IN
	JRST MAPBLK


;UNMAP AND RELEASE HOMEBLOCK
;WRITING TO DISK IS ONLY MEANINGFUL IF THE FILESYSTEM IS NOT BEING
;USED FOR THE MAPPING.  ITS FOR HARD DISK WRITING ONLY WHEN NECESSARY
;WEN NOT USING THE FILESYSTEM FOR MAPPING.

;ACCEPTS 1/ UNIT
;	 2/ BLOCK #
;	 3/ PAGE ADR ITS MAPPED TO, 1B0 ON FOR WRITE IT TO DISK
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

RELHOM:	MOVEI 0,TYPHOM
	SKIPN FILIFG			;OK TO USE FILE SYSTEM YET?
	 JRST RL.BLK			;NO-UNMAP IT WITHOUT ITS HELP
	TLZ 3,(1B0)			;CLEAR WRITE FLAG, WRITING MEANINGLESS
	JRST RELBLK



;FILL OUT HOME BLOCK
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ HB #
;	 3/ PAGE ADR ITS MAPPED TO

FILLHB:	ACMAC <%UNIT,%HBN,%PAGE,%AC4>
	MOVE 3,%PAGE			;3/ MAPPED ADR
	HRLI 1,HOMPRO			;PROTOTYPE
	HRR 1,%PAGE			;TO HERE
	BLT 1,HOMPLN-1(3)		;COPY PROTO TO MAPPED HB
	HRLI 1,HOMPLN(3)		;AND CLEAR REST OF BLOCK
	HRRI 1,HOMPLN+1(3)
	SETZM HOMPLN(3)
	BLT 1,HOMLEN-1(3)
	MOVE 1,%HBN			;NOW FILL IT OUT
	ADDI 1,'0'			;MAKE # SIXBIT
	DPB 1,[POINT 6,HOMID(3),5]
	MOVE 2,%UNIT
	MOVE 1,XB1TBL(2)		;PRIMARY HOMBAT XB FOR UNIT
	MOVEM 1,HOMHB1(3)
	MOVE 1,XB2TBL(2)		;SECONDARY HOMBAT XB FOR UNIT
	MOVEM 1,HOMHB2(3)
	MOVE 1,MCDTBL(2)		;MICRO DIAG XB
	MOVEM 1,HOMMDA(3)
	MOVE 1,MICTBL(2)		;MICRO CODE XB
	MOVEM 1,HOMMCA(3)
	MOVE 1,BOTTBL(2)		;BOOTSTRAP XB
	MOVEM 1,HOMBTA(3)
	HRRM 2,HOMSPK(3)		;LOGICAL UNIT #
	MOVE 1,DIDSCA			;INDEX.;1 XB ADR LINEAR
	CALL CVDSK			;MAKE HARDWARE ADR
	MOVE 3,%PAGE
	MOVEM 1,HOMNX1(3)
	SETZM HOMNX2(3)			;NO BACKUP INDEX.;2 CURRENTLY
	MOVE 1,FDDSCA			;DIRECTORY.;1 XB ADR LINEAR
	CALL CVDSK			;MAKE HARDWARE ADR
	MOVE 3,%PAGE
	MOVEM 1,HOMDR1(3)
	SETZM HOMDR2(3)			;NO BACKUP DIRECTORY.;2 CURRENTLY
	MOVEI 1,CODHOM			;SPECIAL CODE
	MOVEM 1,HOMCOD(3)
	MOVE 4,%HBN
	MOVE 2,%UNIT
	MOVE 1,HM1TBL(2)		;ASSUME PRIMARY HB ADR FOR UNIT
	CAIE 4,1			;IS IT?
	 MOVE 1,HM2TBL(2)		;NO-GET SECONDARY HB ADR FOR UNIT
	MOVEM 1,HOMSLF(3)		;STORE PTR TO SELF
	RET

	PURGE %UNIT,%HBN,%PAGE,%AC4



;CHECK HOME BLOCK CONSISTENCY

;ACCEPTS 1/ PAGE HOME BLOCK IS MAPPED TO
;RETURNS +1 LOOKS BAD
;	 +2 LOOKS OK

;DOES NOT CHECK XB ADRS, FLAGS, ETC. SINCE MAY BE CHANGED ON THE
;FLY OR DURING TRYING TO PIECE BROKEN SYSTEM TOGETHER

CHKHOM:	ACMAC <%PAGE,%AC2,%AC3,%AC4>
	MOVE 2,HOMNAM(1)
	CAME 2,[SIXBIT/HOME/]
	 RET
	MOVE 2,HOMID(1)
	CAME 2,[SIXBIT/1/]
	CAMN 2,[SIXBIT/2/]
	 CAIA
	RET
	MOVE 2,HOMVER(1)
	CAME 2,[VERHOM,,HOMLEN]
	 RET
	MOVE 2,HOMHW0(1)
	CAME 2,[<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35]
	 RET
	MOVE 2,HOMHW1(1)
	CAME 2,[NTKUN,,NSURFS]
	 RET
	MOVE 2,HOMHW2(1)
	CAME 2,[NSECS,,NWSEC]
	 RET
	MOVE 2,HOMHW3(1)
	CAME 2,[<NTKUN*NSURFS*NSECS>,,<NSURFS*NSECS>]
	 RET
	MOVE 2,HOMSNM(1)
	CAME 2,[SIXBIT/PS/]
	 RET
	MOVE 2,HOMCOD(1)
	CAIN 2,CODHOM
	 AOS (P)
	RET

	PURGE %PAGE,%AC2,%AC3,%AC4



;READS HOMEBLOCKS UNTIL A GOOD ONE IS FOUND AND RETURNS
;DIDSCA IN AC1.  THIS IS BECAUSE ONLY THE HOMEBLOCKS TRULY
;KNOW WHERE THE WORLD STARTS SINCE DIDSCI MIGHT HAVE BEEN
;A BAD SPOT AND WAS SKIPPED OVER VIA BAT BLOCK LOGIC.

;RETURNS 1/ VALUE OF DIDSCA TO BE BELIEVED

DEFDIA:	ACMAC <%DIA,%AC2,%AC3,%AC4>
	VARMAC <$AOBJN,$GOODB,$PAGE,$RCORE>
	MOVSI 1,-NPACKS
DEFDI1:	MOVEM 1,$AOBJN			;LOOP BACK TO HERE
	HRRZ 1,$AOBJN			;GET UNIT #
	MOVEI 2,1			;BLOCK 1
	MOVEM 2,$GOODB			;ASSUME IT WILL BE GOOD
	CALL MAPHOM			;READ IT
	 JRST DEFDIM			;FAILED TO MAP
	MOVEM 3,$PAGE			;SAVE WHERE IT IS
	MOVEM 4,$RCORE			;AND ITS REAL CORE ADR
	MOVE 1,$PAGE
	CALL CHKHOM			;PRIMARY OK?
	 CAIA				;NOPE-TRY SECONDARY
	JRST DEFDI2			;YES-USE IT
	HRRZ 1,$AOBJN			;UNIT
	MOVEI 2,1
	MOVE 3,$PAGE
	MOVE 4,$RCORE
	CALL RELHOM			;RELEASE THE PRIMARY
	 JRST DEFDIR			;FAILED TO UNMAP
	HRRZ 1,$AOBJN			;UNIT
	MOVEI 2,2			;BLOCK 2
	MOVEM 2,$GOODB			;ASSUME IT WILL BE GOOD
	CALL MAPHOM			;READ IT
	 JRST DEFDIM			;FAILED TO MAP
	MOVEM 3,$PAGE			;SAVE WHERE IT IS
	MOVEM 4,$RCORE			;AND ITS REAL CORE ADR
	MOVE 1,$PAGE
	CALL CHKHOM			;SECONDARY OK?
	 JRST DEFDI3			;NO-NEXT PACK
DEFDI2:	MOVE 1,$PAGE
	MOVE 1,HOMNX1(1)		;GET HDWR FORMAT DIDSCA
	CALL CDSKVA			;MAKE IT LINEAR SOFT
	TLO 1,(DSKABT)			;DSKABT ON
	MOVEM 1,%DIA			;RET TO USER
	HRRZ 1,$AOBJN			;UNIT
	MOVE 2,$GOODB			;BLOCK #
	MOVE 3,$PAGE
	MOVE 4,$RCORE
	CALL RELHOM			;RELEASE MAPPED BLOCK
	 JRST DEFDIR			;FAILED TO UNMAP
	RET

DEFDI3:	HRRZ 1,$AOBJN			;UNIT
	MOVEI 2,2			;SECONDARY
	MOVE 3,$PAGE
	MOVE 4,$RCORE
	CALL RELHOM			;UNMAP BAD SEC HOME BLK
	 JRST DEFDIR			;FAILED TO UNMAP
	MOVE 1,$AOBJN
	AOBJN 1,DEFDI1			;LOOP FOR ALL PACKS TIL DONE
	BUG (HLT,<DEFDIA: FAILED TO READ DIDSCA FROM HOME BLOCKS>)
	MOVE 1,DIDSCI
	MOVEM 1,%DIA			;PROBABLY WILL WORK
	RET

DEFDIM:	BUG (HLT,<DEFDIA: FAILED TO MAP HOME BLOCK>)
DEFDIR:	BUG (HLT,<DEFDIA: FAILED TO RELEASE HOME BLOCK>)

	PURGE %DIA,%AC2,%AC3,%AC4
	PURGE $AOBJN,$GOODB,$PAGE,$RCORE



;BAT BLOCK DEFINITIONS

DEFINE DEFBAT (SUFFIX)
<	IRP SUFFIX, <BAT'SUFFIX==..N
		     ..N==..N+1>
>

..N==0		;INIT COUNTER FOR MACRO

DEFBAT <NAM,ID,VER,HW0,HB1,HB2,FRE,CNT,SPR,DAT>	;00 : 11

..N==BATLEN-2	;2ND PART INIT COUNTER FOR MACRO

DEFBAT <COD,SLF>


;PARAMETERS ASSEMBLED INTO BAT BLOCK HEADERS

VERBAT==1			;VERSION
BATLEN==1000			;LENGTH OF ENTIRE BLOCK
FREBAT==BATCOD-BATDAT-1		;INITIAL FREE COUNT
INIBAT==0			;INITIAL INITIAL COUNT
ADDBAT==0			;INITIAL ADDED COUNT
CODBAT==606060

OPDEF BATSCT [POINT NUNTBT,0,UNTLSB]	;PTR TO SECTOR COUNT FIELD IN ENTRY
OPDEF BATADR [POINT <NCYLBT+NSRFBT+NSECBT>,0,35] ;PTR TO HDWR SECTOR ADR 


;BATBLOCK HEADER PROTOTYPE (.-. TO BE FILLED IN)

BATPRO:	SIXBIT /BAT/					;BATNAM
	.-.						;BATID
	VERBAT,,BATLEN					;BATVER
	<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35	;BATHW0
	.-.						;BATHB1
	.-.						;BATHB2
	FREBAT						;BATFRE
	INIBAT,,ADDBAT					;BATCNT

BATPLN==.-BATPRO		;LENGTH OF A BAT PROTOTYPE


;CREATION OF BAT BLOCKS IS ONLY AN OPTION FOR SYSLODS
;IF YOU WANT TO PLAY WITH THEM ON AN EXISTANT FILESYSTEM - DO
;IT THRU THE FILESYSTEM STANDALONE.

;CALL CRTBAT FOR ALL PACKS

CRTBAA:	PUSH P,1
	PUSH P,2
	HRROI 1,[ASCIZ/
Examining BAT blocks./]
	PSOUT
	MOVSI 2,-NPACKS		;AOBJN FOR PACKS
CRTAA1:	HRRZ 1,2		;LOGICAL PACK # IN 1
	CALL CRTBAT
	AOBJN 2,CRTAA1
	POP P,2
	POP P,1
	RET

;CREATE BAT BLOCKS FOR PACK
;IF THE BLOCK CURRENTLY ON THE PACK LOOKS BAD, MAKE USER INIT IT
;OTHERWISE ACCEPT IT, NEVER OVERWRITING GOOD BAT BLOCKS

;ACCEPTS LOGICAL PACK # IN 1

CRTBAT:	ACMAC <%UNIT,%AC2,%AC3,%AC4>	;SAVE ACS
	VARMAC <$PAGE1,$PAGE2,$JFN1,$JFN2>
	MOVE 1,%UNIT			;MAP BOTH BLOCKS
	MOVEI 2,1
	CALL MAPBAT			;WITHOUT FILE SYSTEM
	 BUG (HLT,<CRTBAT: FAILED TO MAP PRIMARY BAT BLK>)
	MOVEM 3,$PAGE1
	MOVEM 4,$JFN1
	MOVE 1,%UNIT
	MOVEI 2,2
	CALL MAPBAT
	 BUG (HLT,<CRTBAT: FAILED TO MAP SECONDARY BAT BLK>)
	MOVEM 3,$PAGE2
	MOVEM 4,$JFN2
	MOVE 1,$PAGE1
	CALL CHKBAT			;IS PRIMARY OK?
	 JRST CRTBA3			;NO
	MOVE 1,$PAGE2
	CALL CHKBAT			;IS SECONDARY OK?
	 JRST CRTBA2			;NO-COPY PRIMARY TO IT
	MOVE 1,DBUGSW
	CAIE 1,2			;DEBUGGING?
	 JRST CRTBA5			;NO-ACCEPT GOOD BATS
	SKIPN BATDBG			;ALLOW SMART USER AT THEM?
	 JRST CRTBA5			;NO-TAKE NO CHANCES
	HRROI 1,[ASCIZ/
You are being given this option because you are debugging BAT blocks!
Clobber GOOD!!! BAT blocks for pack /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%UNIT
	MOVEI 3,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/? /]
	PSOUT
	CALL RPLUSR
	 JRST CRTBA5			;NO-BOTH OK TO USE AS IS
	JRST CRTBA1			;YES-CLOBBER BOTH OF EM



CRTBA2:	MOVSI 1,(1B0)			;TURN ON FLAG TO INSURE WRITE
	IORM 1,$PAGE2			;OF SECONDARY TO DISK
	HRROI 1,[ASCIZ/
Copying primary BAT block to secondary BAT block for pack /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%UNIT
	MOVEI 3,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/.
/]
	PSOUT
	HRL 1,$PAGE1			;NO-COPY PIMARY TO IT THEN
	HRR 1,$PAGE2
	HRRZ 3,$PAGE2
	BLT 1,BATLEN-1(3)
	MOVE 1,[SIXBIT/2/]		;AND FIX IT UP
	MOVEM 1,BATID(3)
	MOVE 2,%UNIT
	LDB 1,[BATADR BB2TBL(2)]	;GET JUST CYL,HD,SEC OF SELF
	MOVEM 1,BATSLF(3)
	JRST CRTBA5			;BOTH OK NOW

;HERE IF PRIMARY IS BAD

CRTBA3:	MOVSI 1,(1B0)			;TURN ON FLAG TO INSURE WRITE
	IORM 1,$PAGE1			;OF PRIMARY TO DISK WHEN RELEASED
	MOVE 1,$PAGE2
	CALL CHKBAT			;IS SECONDARY OK?
	 JRST CRTBA4			;NO-TWO LOSERS
	HRROI 1,[ASCIZ/
Copying secondary BAT block to primary BAT block for pack /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%UNIT
	MOVEI 3,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/.
/]
	PSOUT
	HRL 1,$PAGE2			;YES-COPY SECONDARY TO PRIMARY
	HRR 1,$PAGE1
	HRRZ 3,$PAGE1
	BLT 1,777(3)
	MOVE 1,[SIXBIT/1/]		;AND FIX IT UP
	MOVEM 1,BATID(3)
	MOVE 2,%UNIT
	LDB 1,[BATADR BB1TBL(2)]	;GET JUST CYL,HD,SEC OF SELF
	MOVEM 1,BATSLF(3)
	JRST CRTBA5



;HERE WHEN BOTH PRIMARY AND SECONDARY BAT BLOCKS FUCKED UP

CRTBA4: HRROI 1,[ASCIZ/
Both BAT blocks on pack /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%UNIT
	MOVEI 3,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/ look bad.  Reinitialize them? /]
	PSOUT
	CALL RPLUSR
	 JRST CRTBA5			;NO-JUST UNMAP THEM, STAY BROKEN
CRTBA1:	MOVE 1,%UNIT
	MOVEI 2,1			;REINIT PRIMARY
	MOVE 3,$PAGE1
	CALL FILLBB			;INIT IT
	MOVSI 1,(1B0)			;TURN ON FLAG TO INSURE PRIMARY
	IORM 1,$PAGE1			;IS WRITTEN OUT TO DISK
	HRROI 1,[ASCIZ/
Primary BAT Done.  Use a FLAW map to initialize the BAT data? /]
	PSOUT
	CALL RPLUSR
	 JRST CRTBA2			;NO-COPY PRIMARY TO SECONDARY
	CALL GETFLW			;YES-GET FLAW MAP INFO, BUILD TABLES
	MOVE 4,$PAGE1			;1,2,3 SETUP.  4/ ADR OF BAT BLK MAPPED
	CALL BATFLW			;MAKE BAT ENTRIES FROM FLAW MAP TABLES
	CALL RELFLW			;RELEASE THE FLAW MAP
	JRST CRTBA2			;NOW COPY IT ALL TO SECONDARY

CRTBA5:	MOVE 1,%UNIT			;UNMAP BOTH BLOCKS
	MOVEI 2,1
	MOVE 3,$PAGE1			;1B0 MEANS WRITE IT OUT
	MOVE 4,$JFN1
	CALL RELBAT
	 BUG (HLT,<CRTBAT: FAILED TO UNMAP PRIMARY BAT BLK>)
	MOVE 1,%UNIT
	MOVEI 2,2
	MOVE 3,$PAGE2			;1B0 MEANS WRITE IT OUT
	MOVE 4,$JFN2
	CALL RELBAT
	 BUG (HLT,<CRTBAT: FAILED TO UNMAP SECONDARY BAT BLK>)
	RET

	PURGE %UNIT,%AC2,%AC3,%AC4
	PURGE $PAGE1,$PAGE2,$JFN1,$JFN2



;GETS REPLY Y OR N FROM CTY
;SKIPS IF Y, NO SKIP IF N

RPLUSR:	PUSH P,1
RPLUS1:	PBIN
	TRZ 1,40
	CAIN 1,"Y"
	 JRST RPLUYE
	CAIN 1,"N"
	 JRST RPLUNO
	HRROI 1,[ASCIZ/ Y or N? /]
	PSOUT
	JRST RPLUS1

RPLUYE:	AOS -1(P)
RPLUNO:	POP P,1
	RET



;ASSIGN AND MAP XB FOR BAT BLOCK
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ BAT BLOCK #

;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ OFN

MPBBXB:	MOVEI 0,TYPBAT
	JRST MAPXB


;FILL OUT BAT XB AND ASSIGN BAT BLOCK SO NOT POINTING TO UNASSIGNED PAGE
;ACCEPTS 1/ LOGICAL PACK #
;	 2/ BAT BLOCK #
;	 3/ PAGE ITS MAPPED TO

STBBXB:	MOVEI 0,TYPBAT
	JRST SETXB


;UNMAP AND RELEASE BAT XB
;ACCEPTS 3/ PAGE ITS MAPPED TO
;	 4/ OFN

RLBBXB:	MOVEI 0,TYPBAT
	JRST RELXB


;CREATES AND RELEASES BATBLOCK FILE PTING TO PROPER XB
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ # OF BLOCK INVOLVED

MKBBFL:	MOVEI 0,TYPBAT
	JRST MAKFL


;MAP BATBLOCK TO PAGE, READ AND WRITE
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ BLOCK #

;RETURNS 3/ PAGE ADR
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP POSSIBLY WITH ERROR CODE IN 1

MAPBAT:	MOVEI 0,TYPBAT
	SKIPN FILIFG			;OK TO USE FILE SYSTEM YET?
	 JRST MP.BLK			;NO-JUST READ IT IN
	JRST MAPBLK


;UNMAP AND RELEASE BATBLOCK
;WRITING TO DISK IS ONLY MEANINGFUL IF THE FILESYSTEM IS NOT BEING
;USED FOR THE MAPPING.  ITS FOR HARD DISK WRITING ONLY WHEN NECESSARY
;WEN NOT USING THE FILESYSTEM FOR MAPPING.

;ACCEPTS 1/ UNIT
;	 2/ BLOCK #
;	 3/ PAGE ADR ITS MAPPED TO, 1B0 ON FOR WRITE IT TO DISK
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

RELBAT:	MOVEI 0,TYPBAT
	SKIPN FILIFG			;OK TO USE FILE SYSTEM YET?
	 JRST RL.BLK			;NO-UNMAP IT WITHOUT ITS HELP
	TLZ 3,(1B0)			;CLEAR WRITE FLAG, WRITING MEANINGLESS
	JRST RELBLK



;FILL OUT BAT BLOCK
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ BLOCK #
;	 3/ PAGE ADR ITS MAPPED TO

FILLBB:	ACMAC <%UNIT,%BBN,%PAGE,%AC4>
	MOVE 3,%PAGE			;3/ MAPPED ADR
	HRLI 1,BATPRO			;PROTOTYPE
	HRR 1,%PAGE			;TO HERE
	BLT 1,BATPLN-1(3)		;COPY PROTO TO MAPPED BAT BLK
	HRLI 1,BATPLN(3)		;AND CLEAR REST OF BLOCK
	HRRI 1,BATPLN+1(3)
	SETZM BATPLN(3)
	BLT 1,BATLEN-1(3)
	MOVE 1,%BBN			;NOW FILL IT OUT
	ADDI 1,'0'			;MAKE # SIXBIT
	DPB 1,[POINT 6,BATID(3),5]
	MOVE 2,%UNIT
	LDB 1,[BATADR XB1TBL(2)]	;PRIMARY HOMBAT XB SANS UNIT FIELD
	MOVEM 1,BATHB1(3)
	LDB 1,[BATADR XB2TBL(2)]	;SECONDARY HOMBAT XB SANS UNIT FIELD
	MOVEM 1,BATHB2(3)
	MOVEI 1,CODBAT			;SPECIAL CODE
	MOVEM 1,BATCOD(3)
	MOVE 4,%BBN
	MOVE 2,%UNIT
	LDB 1,[BATADR BB1TBL(2)]	;ASSUME PRIMARY HB ADR FOR UNIT
	CAIE 4,1			;IS IT?
	 LDB 1,[BATADR BB2TBL(2)]	;NO-GET SECONDARY HB ADR FOR UNIT
	MOVEM 1,BATSLF(3)		;STORE PTR TO SELF
	RET

	PURGE %UNIT,%BBN,%PAGE,%AC4



;CHECK BAT BLOCK CONSISTENCY

;ACCEPTS 1/ PAGE BAT BLOCK IS MAPPED TO
;RETURNS +1 LOOKS BAD
;	 +2 LOOKS OK

CHKBAT:	ACMAC <%PAGE,%AC2,%AC3,%AC4>
	MOVE 2,BATNAM(1)
	CAME 2,[SIXBIT/BAT/]
	 RET
	MOVE 2,BATID(1)
	CAME 2,[SIXBIT/1/]
	CAMN 2,[SIXBIT/2/]
	 CAIA
	RET
	MOVE 2,BATVER(1)
	CAME 2,[VERBAT,,BATLEN]
	 RET
	MOVE 2,BATHW0(1)
	CAME 2,[<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35]
	 RET
	MOVE 2,BATFRE(1)			;CURRENT FREE COUNT
	HLRZ 3,BATCNT(1)			;INITIAL USED COUNT
	HRRZ 4,BATCNT(1)			;ADDED USED COUNT
	ADD 3,4					;3/ USED
	ADD 2,3					;2/ TOTAL FREE AND USED
	CAIE 2,FREBAT				;BETTER BE SAME AS INIT FREE
	 RET
	MOVE 2,BATCOD(1)
	CAIN 2,CODBAT
	 AOS (P)
	RET

	PURGE %PAGE,%AC2,%AC3,%AC4



;CALL CRTBAF FOR ALL PACKS

CRTBFA:	PUSH P,1
	PUSH P,2
	HRROI 1,[ASCIZ/
Creating BAT blocks and associated files./]
	PSOUT
	MOVSI 2,-NPACKS		;AOBJN FOR PACKS
CRTFA1:	HRRZ 1,2		;LOGICAL PACK # IN 1
	CALL CRTBAF
	AOBJN 2,CRTFA1
	POP P,2
	POP P,1
	AOS HBXSTF			;SAY HOMBAT FILES EXIST
	RET




;CREATE BAT BLOCK FILES NOW THAT FILE SYSTEM EXISTS

;ACCEPTS LOGICAL PACK # IN 1

CRTBAF:	ACMAC <%UNIT,%AC2,%AC3,%AC4>	;SAVE ACS
	VARMAC <$BBN,$PAGE,$OFN>	;RESERVE INFO STUFF
	MOVEI 2,1			;INDEX BLOCK 1
	MOVEM 2,$BBN			;SAVE FOR FUTURE REF
CRTBF1:	MOVE 1,%UNIT
	CALL MPBBXB			;MAP THE INDEX BLOCK
	MOVE 1,%UNIT
	MOVE 2,$BBN
	MOVEM 3,$PAGE			;REMEMBER MAPPED PAGE ADR
	MOVEM 4,$OFN			;AND THE OFN
	CALL STBBXB			;SET UP XB
	MOVE 3,$PAGE
	MOVE 4,$OFN
	CALL RLBBXB			;RELEASE THE XB
	MOVE 1,%UNIT
	MOVE 2,$BBN
	CALL MKBBFL			;MAKE AND RELEASE FILE
	MOVE 1,%UNIT
	MOVE 2,$BBN
	CALL MAPBAT			;NOW USE FILE TO MAP BAT
	 BUG (HLT,<CRTBAF: FAILED TO MAP JUST CREATED BAT>)
	MOVES (3)			;TOUCH IT
	CALL RELBAT			;RELEASE BAT, SEEMS TO WORK!
	  BUG (HLT,<CRTBAF: FAILED TO RELEASE BAT>)
	AOS 2,$BBN			;DO BOTH PRIMARY AND SECONDARY
	CAIG 2,2
	 JRST CRTBF1			;LOOP FOR NEXT
	RET

	PURGE %UNIT,%AC2,%AC3,%AC4
	PURGE $BBN,$PAGE,$OFN



;TEMP GET FLAW MAP ROUTINE
;BUILDS CYL,,HEAD TABLE AND POSITION,,LENGTH TABLE

;RETURNS 1/ ADR OF CYL,,HEAD TABLE
;	 2/ ADR OF POS,,LENGTH TABLE
;	 3/ USEABLE LENGTH OF THOSE TABLES

GETFLW:	ACMAC <%C.HTB,%P.LTB,%LEN,%AC4>
	CALL ASGPAG
	 BUG (HLT,<GETFLW: FAILED TO ASGPAG FOR CYL,,HEAD TABLE>)
	MOVEM 1,%C.HTB
	CALL ASGPAG
	 BUG (HLT,<GETFLW: FAILED TO ASGPAG FOR POS,,LEN TABLE>)
	MOVEM 1,%P.LTB
	HRROI 1,[ASCIZ/

GETFLW: Enter Clyinder,,Head in table starting at /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%C.HTB
	MOVEI 3,10
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/
        Enter Position,,Length in table starting at /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%P.LTB
	MOVEI 3,10
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/
        and # of entries in AC 1.  BUGCHK coming up.
        $P when ready.
/]
	PSOUT
	MOVEI 1,101
	DOBE
	MOVE 1,%C.HTB
	HRLI 2,(1)
	HRRI 2,1(1)
	SETZM (1)
	BLT 2,777(1)
	MOVE 1,%P.LTB
	HRLI 2,(1)
	HRRI 2,1(1)
	SETZM (1)
	BLT 2,777(1)
GETFL1:	SETO 1,			;CHECK ON PROPER SETTING OF AC 1
	BUG (CHK,<GETFLW: FAKE RTN, BUILD TABLES, SET AC 1, $P>)
	JUMPGE 1,GETFL2
	HRROI 1,[ASCIZ/
You forgot to indicate the length of the tables in AC 1.
Do it.  Tables still intact.
/]
	PSOUT
	MOVEI 1,101
	DOBE
	JRST GETFL1

GETFL2:	MOVEM 1,%LEN
	RET

	PURGE %C.HTB,%P.LTB,%LEN,%AC4

;RELEASES PAGES ASSIGNED FOR ABOVE FLAW MAP CROCK

;ACCEPTS 1/ ADR OF CYL,,HEAD TABLE
;	 2/ ADR OF POS,,LENGTH TABLE

RELFLW:	ACMAC <%C.HTB,%P.LTB,%AC3,%AC4>
	MOVEI 1,%C.HTB
	CALL RELPAG
	MOVEI 1,%P.LTB
	CALL RELPAG
	RET

	PURGE %C.HTB,%P.LTB,%AC3,%AC4



;FILL OUT BAT BLOCK GIVEN TABLES OF FLAW MAP ENTRIES

;ACCEPTS 1/ ADR OF CYL,,HEAD TABLE
;	 2/ ADR OF POSITION,,LENGTH TABLE
;	 3/ LENGTH OF THOSE TABLES
;	 4/ ADR OF BAT BLOCK TO BE FILLED OUT

BATFLW:	ACMAC <%C.H,%P.L,%LEN,%BAT>
	VARMAC <$SEC1,$SEC2,$SEC3,$SECNT,$FLWAP>
	NOSKED			;WHOLE THING IS NOSKED
	MOVEI 1,FREBAT		;INIT COUNTS
	MOVEM 1,BATFRE(4)
	MOVE 1,[INIBAT,,ADDBAT]
	MOVEM 1,BATCNT(4)
	HRLI 1,BATDAT(4)
	HRRI 1,BATDAT+1(4)
	SETZM BATDAT(4)
	BLT 1,BATCOD-1(4)	;CLEAR ALL OF DATA AREA
	SKIPN %LEN		;ANY LENGTH TO FLAW MAP?
	 JRST BATF10		;NO-NOTHING TO DO
	MOVN 1,%LEN
	HRLZM 1,$FLWAP		;FLAW MAP AOBJN PTR
	SETZM $SECNT		;SAY NO SECTORS SEEN YET
BATFL1:	MOVE 1,%C.H		;ADR OF FLAW MAP TABLES
	MOVE 2,%P.L
	HRRZ 3,$FLWAP		;FLAW MAP TABLES INDEX
	CALL FLWSEC		;CONVERT ENTRY TO SECTOR ON PACK
	 JRST BATFL7		;RAN OUT FOR THIS FLAW MAP INDEX
BATFL2:	SKIPE $SECNT		;STARTING OFF NEW SET OF SECTORS?
	 JRST BATFL4		;NO
	MOVEM 1,$SEC1		;YES-SET 1ST SECTOR
	MOVEM 1,$SEC2		;SET LAST SECTOR
	AOS $SECNT		;SAY A SECTOR SEEN
BATFL4:	CAMN 1,$SEC2		;SAME AS LAST SECTOR SEEN?
	 JRST BATFL1		;YES, BYTE IN SAME SECTOR, IGNORE
	MOVEM 1,$SEC3		;NO-SAVE CURRENT SECTOR
	SUB 1,$SEC2		;GET DIFF OF LAST AND CURRENT SECTOR
	CAIE 1,1		;CONTIGUOUS SECTORS?
	 JRST BATFL5		;NO-MAKE BAT ENTRY, START NEW SET
	AOS $SECNT		;YES-JUST BUMP SECTOR COUNT
	AOS $SEC2		;LAST SEC IS THEREFORE LAST + 1
	JRST BATFL1		;LOOP

;HERE TO MAKE BAT ENTRY BECAUSE CURRENT SECTOR IS NOT CONTIGUOUS.
;JUMP BACK INTO LOOP FOR CURRENT SECTOR AFTER ENTRY MADE

BATFL5:	MOVE 1,$SEC1		;START SECTOR
	MOVE 2,$SECNT		;# SECTORS
	MOVE 3,%BAT		;ADR OF BAT BLOCK ITSELF
	MOVSI 4,(1B0)		;SAY INITIAL ENRTY
	CALL BATENT		;DO IT (NOSKED)
	 BUG (HLT,<BATFLW: FAILED TO MAKE BAT BLOCK ENTRY>)
	SETZM $SECNT		;SAY STARTING NEW SET
	MOVE 1,$SEC3		;RESTORE CURRENT SECTOR
	JRST BATFL2		;JUST LIKE FLWSEC WON 1ST TIME

;HERE BECAUSE FLWSEC CLAIMS THE POSITION CNT IN FLAW MAP ENTRY WENT
;TO ZERO AND NO MORE POSSITIONS TO PROCESS IN THEIS ENTRY

BATFL7:	MOVE 1,$FLWAP		;GET FLAW MAP AOBJN
	AOBJN 1,BATFL8		;STEP TO NEXT FLAW MAP ENTRY
	 JRST BATFL9		;ALL DONE
BATFL8:	MOVEM 1,$FLWAP		;UPDATE FLAW MAP AOBJN PTR
	JRST BATFL1		;CONTINUE USING CURRENT $SECNT

;HERE WHEN FLAW MAP EXHAUSTED.  MAKE LAST BAT ENTRY

BATFL9:	SKIPN 2,$SECNT		;I DON'T THINK IT CAN BE 0 (SAFE)
	 JRST BATF10
	MOVE 1,$SEC1		;1ST SECTOR
	MOVE 3,%BAT		;ADR OF BAT BLOCK ITSELF
	MOVSI 4,(1B0)		;SAY INITIAL ENTRY
	CALL BATENT		;MAKE LAST ENTRY (NOSKED)
	 BUG (HLT,<BATFLW: FAILED TO MAKE BAT BLOCK ENTRY>)
BATF10:	OKSKED
	RET

	PURGE %C.H,%P.L,%LEN,%BAT
	PURGE $SEC1,$SEC2,$SEC3,$SECNT,$FLWAP



;PROCESS FLAW MAP ENTRY AND RETURN PACK RELATIVE SECTOR ADR
;SKIPS IF OK, NO SKIP IF NO MORE BYTE POSITIONS TO PROCESS FOR ENTRY

;ACCEPTS 1/ CYL,,HEAD TABLE ADR
;	 2/ POSITION,,LENGTH TABLE ADR
;	 3/ TABLE INDEX TO USE
;RETURNS 1/ SECTOR IF SKIPS

FLWSEC:	ACMAC <%C.H,%P.L,%FLWNX,%AC4>
	MOVE 1,%P.L
	ADD 1,%FLWNX
	HRRZ 2,(1)		;GET CNT OF ENTRY
	JUMPE 2,FLWSE1		;JUMP IF NO MORE IN THIS ENTRY
	HLRZ 2,(1)		;GET BYTE POSITION
	IDIVI 2,^D2520		;MAGICALLY CONVERT TO SECTOR
	SOS 3,(1)		;MAKE POS+1,,CNT-1
	ADD 3,[1,,0]
	MOVEM 3,(1)
	MOVE 1,%C.H
	ADD 1,%FLWNX
	HLRZ 3,(1)		;GET CYLINDER
	IMULI 3,NSURFS*NSECS	;MAKE SECTOR
	ADD 2,3			;ACCUMULATE SECTORS IN 2
	HRRZ 3,(1)		;GET HEAD
	IMULI 3,NSECS		;MAKE SECTOR
	ADD 2,3
	MOVEM 2,%C.H		;RETURN PACK RELATIVE SECTOR IN 1
	AOS (P)			;SKIP TO SAY DID IT
FLWSE1:	RET

	PURGE %C.H,%P.L,%FLWNX,%AC4



;MAKE ENTRIES INTO BAT BLOCK, MUST BE CALLED NOSKED
;IF ALREADY THERE => NOP
;ADD TO EXISTING ENTRIES VIA SECTOR COUNT FIELD IF POSSIBLE
;IF CAN'T ADD TO EXISTANT => MAKE NEW ENTRY IF POSSIBLE

;ACCEPTS 1/ START SECTOR
;	 2/ # SECTORS
;	 3/ ADR OF BAT BLOCK
;	 4/ 1B0 FOR INITIAL ENTRIES
;	    1B1 FOR ADDED ENTRIES

;RETURNS +1 FAILED TO COMPLETE, SOME SECTORS MAY HAVE MADE IT
;	 +2 SUCCESS, ALL SECTORS ENTERED

BATENT:	ACMAC <%SSEC,%NSEC,%BAT,%FLAGS>

	VARMAC <$SECAP,$CSEC,$BATAP,$RCNT>
	TLNN 4,(1B0!1B1)	;SMART USER?
	 JRST BATE10		;NO-MOST AREN'T
	MOVNS 2
	HRLZM 2,$SECAP		;AOBJN PTR FOR SECTORS TO DO
BATEN0:	HRRZ 1,$SECAP
	ADD 1,%SSEC		;1/ SECTOR TO DO
	MOVEM 1,$CSEC		;CURRENT SECTOR
	MOVE 1,%BAT		;ADR OF BAT BLOCK
	HLRZ 4,BATCNT(1)	;GET INITIAL COUNT
	HRRZ 3,BATCNT(1)	;AND ADDED COUNT
	ADDI 4,(3)		;4/ TOTAL USED COUNT
	JUMPE 4,BATEN5		;EMPTY BAT BLOCK, NO MATCHING POSSIBLE
	MOVNS 4
	HRLS 4
	HRRI 4,BATDAT(1)	;4/ - # USED,,ADR OF 0TH IN BAT BLK
BATEN1:	MOVEM 4,$BATAP		;SAVE AOBJN PTR
	LDB 2,[BATSCT (4)]	;GET COUNT
	MOVEM 2,$RCNT		;RANGE COUNT SAVED
	LDB 1,[BATADR (4)]	;GET JUST HDWR ADR
	CALL CDSKVA		;MAKE LINEAR ADR IN 1
	MOVE 2,$RCNT		;GET RANGE COUNT AGAIN
	ADD 2,1			;ADD IN STARTING LINEAR SECTOR
	SUBI 2,1		;MAKE ENDING SECTOR
	CAMLE 1,$CSEC		;CSEC BELOW RANGE?
	 JRST BATEN2		;YES
	CAMGE 2,$CSEC		;CSEC ABOVE RANGE?
	 JRST BATEN3		;YES
	JRST BATEN7		;NO-WITHIN RANGE, NOTHING TO DO FOR CSEC

;HERE CSEC IS BELOW RANGE, SEE IF IT'S BELOW BY ONE

BATEN2:	SUB 1,$CSEC		;GET DIFFERENCE
	CAIE 1,1		;CAN ADD TO THIS ENTRY VIA CNT FIELD?
	 JRST BATEN4		;NO
	MOVE 1,$CSEC		;YES-CSEC BECOMES LOW END OF RANGE
	CALL CVDSK		;MAKE HARDWAR SECTOR ADR
	AOS 2,$RCNT		;GET OLD RANGE COUNT BUMPED
	DPB 2,[BATSCT 1]	;ENTER CNT INTO HDWR SECTOR
	HRRZ 2,$BATAP		;GET ADR OF ENTRY IN QUESTION
	MOVEM 1,(2)		;REPLACE IT WITH BIGGER RANGED ENTRY
	JRST BATEN7		;DONE WITH CSEC

;HERE CSEC IS ABOVE RANGE, SEE IF IT'S ABOVE BY ONE

BATEN3:	MOVE 1,$CSEC
	SUB 1,2			;GET DIFFERENCE
	CAIE 1,1		;CAN ADD TO THIS ENTRY VIA CNT FIELD?
	 JRST BATEN4		;NO
	AOS 1,$RCNT		;YES-BUMP COUNT
	HRRZ 2,$BATAP		;GET ADR OF ENTRY IN QUESTION
	DPB 1,[BATSCT (2)]	;ENTER NEW COUNT
	JRST BATEN7		;DONE WITH CSEC

;HERE WHEN CSEC TOO FAR OUT OF RANGE TO BE ADDED TO EXISTING ENTRY

BATEN4:	MOVE 4,$BATAP		;GET ABOJN THRU BAT BLK
	AOBJN 4,BATEN1		;STEP TO NEXT BAT ENTRY TO EXAMINE
	 JRST BATEN5		;NO MORE-MUST MAKE NEW ENTRY FOR CSEC

;HERE WHEN ALL BAT BLK SCANNED AND CSEC FITS NOWHERE
;MUST MAKE NEW ENTRY FOR IT

BATEN5:	MOVE 1,$CSEC		;GET LINEAR CURRENT SECTOR
	CALL CVDSK		;MAKE HARWARE ADR
	MOVEI 2,1		;IT'S LENGTH IS 1
	DPB 2,[BATSCT 1]	;COMPLETE ENTRY
	MOVEM 1,$CSEC		;ITS HARDWARE NOW
	MOVE 1,%BAT		;ADR OF BAT BLK AGAIN
	SKIPG BATFRE(1)		;ANY ROOM IN BAT BLK?
	 JRST BATE10		;NO-LOSER
	SOS BATFRE(1)		;DEC # FREE
	MOVE 3,%FLAGS		;GET FLAGS
	TLNE 3,(1B0)		;INITIAL ENTRY?
	 MOVSI 2,1		;YES-BUMP LH
	TLNE 3,(1B1)		;ADDED ENTRY?
	 MOVEI 2,1		;YES-BUMP RH
	ADDM 2,BATCNT(1)	;BUMP COUNT FIELD
	HLRZ 2,BATCNT(1)	;GET INITIAL COUNT
	HRRZ 3,BATCNT(1)	;AND ADDED COUNT
	ADDI 2,(3)		;2/ OFFSET INTO DATA AREA OF BAT BLK
	ADDI 2,BATDAT-1(1)	;2/ ADR OF FREE ENTRY (-1 CAUSE WE BUMPED)
	MOVE 1,$CSEC		;GET SAVED HARDWARE ENTRY
	MOVEM 1,(2)		;ENTER IT
	JRST BATEN7		;DO REST OF SECTORS REQUESTED


;HERE WHEN DONE PROCESSING CSEC SUCCESSFULLY AND WISH TO CONTINUE
;LOOPING FOR REQUESTED SECTOR COUNT

BATEN7:	MOVE 1,$SECAP		;AOBJN THRU REQUESTED SECTORS
	AOBJN 1,BATEN8		;LOOP FOR EM
	 JRST BATEN9		;DONE
BATEN8:	MOVEM 1,$SECAP		;UPDATE AOBJN SAVER
	JRST BATEN0		;LOOP

BATEN9:	AOS (P)			;SUCCESS
BATE10:	RET			;NOSKIP FAILURE

	PURGE %SSEC,%NSEC,%BAT,%FLAGS
	PURGE $SECAP,$CSEC,$BATAP,$RCNT



;CALL DOBAT FOR ALL PACKS FOR DISK ADRS

DOBDSA:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	HRROI 1,[ASCIZ/
Assigning DISK addresses found in BAT blocks./]
	PSOUT
	MOVSI 3,-NPACKS		;AOBJN FOR PACKS
DOBDS1:	HRRZ 1,3		;LOGICAL PACK # IN 1
	MOVSI 2,(1B0)		;DISK ADRS ONLY
	CALL DOBAT
	AOBJN 3,DOBDS1
	RET

	PURGE %AC1,%AC2,%AC3,%AC4

;CALL DOBAT FOR ALL PACKS FOR DRUM ADRS

DOBDRA:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	MOVEI 1,DRMBND		;CHECK DRUM NOT TOUCHED YET
	IMULI 1,DRMSEC
	CAME 1,DRMFRE
	 BUG (HLT,<DOBDRA: DRUM ADR ASSIGNED BEFORE BAT BLOCKS USED>)
	HRROI 1,[ASCIZ/
Assigning DRUM addresses found in BAT blocks./]
	PSOUT
	MOVSI 3,-NPACKS		;AOBJN FOR PACKS
DOBDR1:	HRRZ 1,3		;LOGICAL PACK # IN 1
	MOVSI 2,(1B1)		;DRUM ADRS ONLY
	CALL DOBAT
	AOBJN 3,DOBDR1
	RET

	PURGE %AC1,%AC2,%AC3,%AC4

;CALL DOBAT FOR ALL PACKS FOR BOTH DISK AND DRUM ADRS

DOBDDA:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	MOVEI 1,DRMBND		;CHECK DRUM NOT TOUCHED YET
	IMULI 1,DRMSEC
	CAME 1,DRMFRE
	 BUG (HLT,<DOBDDA: DRUM ADR ASSIGNED BEFORE BAT BLOCKS USED>)
	HRROI 1,[ASCIZ/
Assigning DISK and DRUM addresses found in BAT blocks./]
	PSOUT
	MOVSI 3,-NPACKS		;AOBJN FOR PACKS
DOBDD1:	HRRZ 1,3		;LOGICAL PACK # IN 1
	MOVSI 2,(1B0!1B1)	;BOTH DISK AND DRUM ADRS
	CALL DOBAT
	AOBJN 3,DOBDD1
	RET

	PURGE %AC1,%AC2,%AC3,%AC4



;ASSIGNS ALL DISK AND DRUM ADRS FOUND IN BAT BLOCK FOR PACK
;BASED ON PROCESSING FLAGS

;ACCEPTS 1/ LOGICAL UNIT #
;ACCEPTS 2/ 1B0 DO DISK ASSIGNS
;	    1B1 DO DRUM ASSIGNS

DOBAT:	ACMAC <%UNIT,%FLAGS,%AC3,%AC4>
	VARMAC <$PAGE,$JFN,$BBN>
	MOVE 1,%UNIT
	MOVEI 2,1			;PRIMARY
	MOVEM 2,$BBN
	CALL MAPBAT			;MAP BAT BLOCK TO A PAGE
	 BUG (HLT,<DOBAT: FAILED TO MAP BAT BLOCK>)
	MOVEM 3,$PAGE			;SAVE MAPPED ADR
	MOVEM 4,$JFN			;AND JFN ASSIGNED
	MOVE 1,$PAGE
	CALL CHKBAT			;LOOK OK?
	 CAIA
	JRST DOBAT1			;OK, USE IT
	BUG (CHK,<DOBAT: BAD PRIMARY BAT, $P TO USE SECONDARY BAT>)
	MOVE 1,%UNIT
	MOVE 2,$BBN			;UNMAP PRIMARY
	MOVE 3,$PAGE			;1B0 OFF, DON'T WRITE IT TO DISK
	MOVE 4,$JFN			;SYS HACK SHOULD INVESTIGATE
	CALL RELBAT
	 BUG (HLT,<DOBAT: FAILED TO BREAK BAT BLOCK MAPPING>)
	MOVE 1,%UNIT
	MOVEI 2,2			;SECONDARY
	MOVEM 2,$BBN			;REMEMBER WHICH ONE
	CALL MAPBAT
	 BUG (HLT,<DOBAT: FAILED TO MAP BAT BLOCK>)
	MOVEM 3,$PAGE
	MOVEM 4,$JFN
	MOVE 1,$PAGE
	CALL CHKBAT
	 CAIA
	JRST DOBAT1
	BUG (HLT,<DOBAT: BAD SECONDARY BAT, YOU LOSE>)
	JRST DOBAT3			;INCASE WANT TO RESTART AND IGNORE BAT

;HERE WITH GOOD BAT BLOCK MAPPED TO $PAGE VIA $JFN

DOBAT1: MOVE 3,$PAGE			;WHERE ITS MAPPED TO
	HLRZ 4,BATCNT(3)		;GET INITIAL COUNT
	HRRZ 2,BATCNT(3)		;AND ADDED COUNT
	ADD 4,2				;4/ TOTAL IN USE
	JUMPE 4,DOBAT3			;JUMP IF NONE TO DO
	CAMLE 4,BATMAX			;LOTS OF SPOTS?
	 JRST [ MOVE 1,%FLAGS		;REPORT ONLY IF DOING DRUM
		TLNN 1,(1B1)		;SO ONLY SEE MSG ONCE
		 JRST .+1
		HRROI 1,[ASCIZ/
[Drive /]
		PSOUT
		MOVEI 1,101
		MOVE 2,%UNIT
		MOVEI 3,12
		NOUT
		 JFCL
		HRROI 1,[ASCIZ/ has more bad spots than allowed by CDC.]
/]
		PSOUT
		JRST .+1]
	MOVNS 4				;NEG FOR AOBJN
	HRLZS 4
	MOVE 3,$PAGE			;INCASE LITERAL CLOBBERED IT
	HRRI 4,BATDAT(3)		;PT TO DATA AREA OF BLOCK
	MOVE 1,%UNIT
	MOVE 3,%FLAGS			;PASS FLAGS
	TLO 3,(1B2)			;FORCED DISK ASSIGNS
DOBAT2:	MOVE 2,(4)			;GET AN ENTRY
	CALL ASGBAT			;DO IT
	 BUG (HLT,<DOBAT: FAILED TO FORCE ASSIGNMENT VIA BAT BLKS>)
	AOBJN 4,DOBAT2			;LOOP FOR ALL ENTRIES
DOBAT3:	MOVE 1,%UNIT
	MOVE 2,$BBN
	MOVE 3,$PAGE			;1B0 OFF, DON'T WRITE TO DISK
	MOVE 4,$JFN
	CALL RELBAT
	 BUG (HLT,<DOBAT: FAILED TO BREAK BAT BLOCK MAPPING>)
	RET

	PURGE %UNIT,%FLAGS,%AC3,%AC4
	PURGE $PAGE,$JFN,$BBN



;ASSIGN DISK AND DRUM PAGES AS APPROPRIATE GIVEN BAT BLOCK ENTRY
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ BAT BLOCK ENTRY
;	 3/ 1B0 TO DO DISK ASSIGNS
;	    1B1 TO DO DRUM ASSIGNS
;	    1B2 TO FORCE DISK ASSIGNMENTS (WIN IF ASSIGNED ALREADY)

;RETURNS +1 FAILED, 1/ HDWR ADR THAT COULD NOT BE ASSIGNED (OR ALREADY IS)
;		    2/ <1B0 => DISK ADR, 1B1 => DRM ADR>! SOFTWARE ADR
;	 +2 SUCCESS

ASGBAT:	ACMAC <%UNIT,%ENT,%FLAGS,%AC4>
	VARMAC <$LNADR,$CNT,$TYADR>
	TLNN 3,(1B0!1B1)		;USER KNOWS WHAT HES DOING?
	 BUG (HLT,<ASGBAT: NO PROCESSING FLAGS GIVEN>)
	DPB 1,[BATSCT 2]		;ENTER UNIT INTO DISK ADR
	MOVE 1,2
	CALL CDSKVA			;CONVERT TO LINEAR ADR
	MOVEM 1,$LNADR			;SAVE 1ST DISK ADR OF CONCERN
	LDB 2,[BATSCT %ENT]		;GET CNT FROM BAT ENTRY
	MOVEM 2,$CNT			;SAVE SECTOR (PAGE) COUNT
ASGBA0:	IDIVI 1,NSECTK
	IDIVI 1,NTKUN			;SEE IF SWAPPING ADR
	CAIL 2,SWPTK
	CAIL 2,SWPTKH
	 JRST ASGBA1			;NO-REAL LINEAR DISK ADR
	MOVE 2,%FLAGS
	TLNN 2,(1B1)			;DOING DRUM ADRS?
	 JRST ASGBA2			;NO-ONTO NEXT ONE, IGNORE
	MOVE 1,$LNADR			;GET DISK LINEAR ADR
	CALL CVADSW			;CONVERT TO DRUM ADR
	MOVEM 1,$TYADR			;SAVE DRUM ADR FOR ERROR RET
	CALL ASDRMS			;ASSIGN IT
	 JRST ASGBA3			;BAD ADDRESS???
	  JRST ASGBA3			;NOT AVAILABLE
	JRST ASGBA2			;SUCCESS, ON TO NEXT ONE

ASGBA1:	MOVE 2,%FLAGS
	TLNN 2,(1B0)			;DOING DISK ADRS?
	 JRST ASGBA2			;NO-ONTO NEXT ONE, IGNORE
	MOVE 1,$LNADR			;GET LINEAR DISK ADR
	MOVEM 1,$TYADR			;SAVE DISK ADR FOR ERROR RET
	TLNE 2,(1B2)			;WANT FORCE FLAG?
	 TLO 1,(1B0)			;YES-SET IT FOR DSKASA
	CALL DSKASA			;ASSIGN IT
	 JRST ASGBA4			;FAILED
ASGBA2:	SOSG $CNT			;ANYMORE TO DO?
	 JRST ASGBA6			;NO-SUCCESS
	MOVEI 1,NSECPG			;BUMP LINEAR ADR
	ADDB 1,$LNADR			;1/ NEW LINEAR ADR TO DO
	JRST ASGBA0			;GO ON TO ASSIGN NEXT ADR

;HERE ON DRUM FAILURE, FAILING LINEAR ADR IN $LNADR, DRUM ADR IN $TYADR

ASGBA3:	MOVSI 1,(1B1)			;DRUM ADR FAILED
	JRST ASGBA5

;HERE ON DISK FAILURE, FAILING LINEAR ADR IN $LNADR, DISK ADR IN $TYADR

ASGBA4:	MOVSI 1,(1B0)			;DISK ADR FAILED
ASGBA5:	IOR 1,$TYADR			;OR IN ADR OF PROPER TYPE
	MOVEM 1,%ENT			;SAY TYPE OF FAILURE IN AC 2 WITH ADR
	MOVE 1,$LNADR			;GET BACK DISK LINEAR ADR
	CALL CVDSK			;MAKE IT HARDWARE ADR
	MOVEM 1,%UNIT			;RETURN IT IN AC 1
	RET				;NOSKIP FAILURE

;HERE ON SUCCESS

ASGBA6:	AOS (P)				;SKIP SUCCESS
	RET



;POTENTIAL BACKEND TO USER JSYS FOR MAKING BAT BLOCK ENTRIES
;TRIES TO ASSIGN SPOT ON DISK OR DRUM.
;BOTH BAT BLOCKS MUST BE IN GOOD SHAPE TO DO THIS FOR NOW.
;IF NOT, JUST LOSE

;ACCEPTS 1/ HARWARE DISK ADR (OK IF IN DRUM AREA)
;	    1B0 TO MAKE ENTRY EVEN FOR DSK ADR ALREADY ASSIGNED

;RETURNS +1 FOR FAILURE
;	 +2 FOR SUCCESS

NTRBAT:	ACMAC <%F.ADR,%AC2,%AC3,%AC4>
	VARMAC <$UNIT,$PAGE1,$JFN1,$PAGE2,$JFN2,$ASGWN>
	SETZM $PAGE1				;NON-0 IF IN USE
	SETZM $PAGE2
	SETZM $ASGWN				;NON 0 IF ASGBAT WON
	LDB 1,[BATSCT %F.ADR]			;GET UNIT #
	MOVEM 1,$UNIT				;REMEMBER IT
	MOVE 2,%F.ADR				;SETUP FOR
	TLZ 2,(1B0)				;CLEAR POSSIBLE FLAG
	MOVEI 3,1				;ONLY 1 SECTOR! CRITICAL!!
	DPB 3,[BATSCT 2]			;ENTER SECTOR COUNT IN ADR
	MOVSI 3,(1B0!1B1!0B2)			;ALLOW BOTH DISK AND DRUM
	CALL ASGBAT				;TRY TO ASSIGN IT, NO FORCING
	 JRST [	MOVE 4,%F.ADR			;GET CALLER'S FLAG
		TLNN 4,(1B0)			;OK IF IS ALREADY ASSIGNED?
		 JRST NTRBA2			;NO-ITS ASSIGNED ALREADY, BAD
		JRST NTRBA0]			;YES-CONTINUE THEN
	SETOM $ASGWN				;REMEMBER WE ASSIGNED IT
NTRBA0:	MOVE 1,$UNIT				;MAP BAT NOW, MAYBE ASSIGNED
	MOVEI 2,1				;PRIMARY
	CALL MAPBAT
	 JRST NTRBA2
	MOVEM 3,$PAGE1
	MOVEM 4,$JFN1
	MOVE 1,3
	CALL CHKBAT				;LOOK OK?
	 JRST NTRBA2				;UNMAP PRIMARY AND NO SKIP
	MOVE 1,$UNIT				;NOW MAP SECONDARY
	MOVEI 2,2
	CALL MAPBAT
	 JRST NTRBA2				;UNMAP PRIMARY AND NO SKIP
	MOVEM 3,$PAGE2
	MOVEM 4,$JFN2
	MOVE 1,3
	CALL CHKBAT				;LOOK OK?
	 JRST NTRBA2				;UNMAP BOTH AND NO SKIP



;HERE WHEN BOTH BAT BLOCKS MAPPED AND LOOK OK, MAKE ENTRY IN EACH

	LDB 1,[BATADR %F.ADR]			;GET JUST HDWR ADR
	CALL CDSKVA				;GET PACK RELATIVE LINEAR ADR
	MOVEI 2,1				;ONLY DOING 1 SECTOR
	MOVE 3,$PAGE1				;ENTER IT INTO PRIMARY
	MOVSI 4,(1B1)				;SAY ADDED ENTRY
	NOSKED					;NO TURNING BACK
	CALL BATENT
	 JRST NTRBA1				;FAILED TO MAKE ENTRY IN BAT
	HRL 1,$PAGE1				;NOW COPY PRIMARY TO SECONDARY
	HRR 1,$PAGE2
	HRRZ 3,$PAGE2
	BLT 1,BATLEN-1(3)
	MOVE 1,[SIXBIT/2/]			;AND FIX IT UP
	MOVEM 1,BATID(3)
	MOVE 2,$UNIT
	LDB 1,[BATADR BB2TBL(2)]		;GET JUST CYL,HD,SEC OF SELF
	MOVEM 1,BATSLF(3)
	OKSKED					;DONE WITH BATS
	MOVSI 1,(1B0)				;FLAG BOTH BATS
	IORM 1,$PAGE1				;FOR WRITING TO DISK
	IORM 1,$PAGE2				;SINCE WE CHANGED THEM
	AOS (P)					;SUCCESS SKIP RET, MUST UNMAP
	JRST NTRBA4				;NOW JUST UNMAP THEM

;HERE WHEN SOMETHING WENT WRONG, DEASSIGN ADR WE ASSIGNED, UNMAP BLOCKS

NTRBA1:	OKSKED
NTRBA2:	SKIPN $ASGWN				;DID WE ASSIGN IT?
	 JRST NTRBA4				;NO-DON'T DEASSIGN IT THEN
	MOVE 1,%F.ADR				;HERE TO UNDO WHAT ASGBAT DID
	TLZ 1,(1B0)				;CLEAR POSSIBLE FLAG
	CALL CDSKVA				;CONVERT TO SOFT LINEAR
	MOVE 2,1
	IDIVI 2,NSECTK
	IDIVI 2,NTKUN
	CAIL 3,SWPTK				;DRUM?
	CAIL 3,SWPTKH
	 JRST NTRBA3				;NO, DISK
	CALL CVADSW				;CONVERT TO DRUM ADR
	PUSH P,5				;WILL GET CLOBBERED
	PUSH P,6
	CALL DEDRM				;DEASSIGN
	 JFCL					;BAD ADDRESS??
	  BUG (HLT,<NTRBAT: FAILED TO DEASSIGN DRUM ADR>)
	POP P,6					;RESTORE CLOBBERED ACS
	POP P,5
	JRST NTRBA4				;NOW DO UNMAPPINGS

NTRBA3:	CALL DEDSK				;DEASSIGN DISK ADR
	 BUG (HLT,<NTRBAT: FAILED TO DEASSIGN DISK ADR>)
NTRBA4:	SKIPN 3,$PAGE1				;GOT PRIMARY MAPPED?
	 JRST NTRBA5				;NO-TRY FOR SECONDARY
	MOVE 4,$JFN1
	MOVE 1,%UNIT
	MOVEI 2,1
	CALL RELBAT				;POSSIBLE WRITE OUT FLAG ON
	 BUG (HLT,<NTRBAT: FAILED TO UNMAP PRIMARY BAT BLOCK>)
NTRBA5:	SKIPN 3,$PAGE2				;GOT SECONDARY MAPPED?
	 RET					;NO
	MOVE 1,%UNIT
	MOVEI 2,2
	MOVE 4,$JFN2
	CALL RELBAT				;POSSIBLE WRITE OUT FLAG ON
	 BUG (HLT,<NTRBAT: FAILED TO UNMAP SECONDARY BAT BLOCK>)
	RET


	PURGE %F.ADR,%AC2,%AC3,%AC4
	PURGE $UNIT,$PAGE1,$JFN1,$PAGE2,$JFN2,$ASGWN




;UTILITY ROUTINES FOR ABOVE HOMEBLOCK AND BATBLOCK ROUTINES.
;SOME OF THESE ROUTINES EXAMINE HBXSTF FOR EXISTANCE OF HOMBAT FILE
;TO DETERMINE ACTIONS TAKEN WITHIN ROUTINE.

;PROCESSING BLOCK TYPES
;THESE NUMBERS ALSO INDICATE WHICH PAGE OF THE HOMBAT FILE THE BLKS ARE AT

TYPHOM==0				;HOME BLOCK IS PAGE 0
TYPBAT==1				;BAT BLOCK IS PAGE 1


;ASSIGN AND MAP XB FOR BLOCK TYPE INDICATED IN 3
;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL UNIT #
;	 2/ BLOCK #

;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ OFN


MAPXB:	ACMAC <%UNIT,%BN,%PAGE,%OFN>
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	BUG (HLT,<MAPXB: ILLEGAL BLOCK TYPE REQUESTED>)
	MOVEI 1,XB1TBL			;ASSUME PRIMARY
	CAIE 2,1
	 MOVEI 1,XB2TBL			;NO-SECONDARY
	ADD 1,%UNIT			;ADD IN PACK OFFSET
	MOVE 1,(1)			;GET XB ADR
	CALL CDSKVA			;CONVERT TO SOFT LINEAR ADR
	PUSH P,1			;SAVE SOFT ADR
	SKIPE HBXSTF			;DOES FILE ALREADY EXIST?
	 JRST MAPXB1			;YES-XB MUST ALREADY BE ASSIGNED
	CALL DSKASA			;ASSIGN IT
	 BUG (HLT,<MAPXB: FAILED TO ASSIGN INDEX BLOCK>)
	JRST MAPXB2

MAPXB1:	CALL DSKASA			;MUST FAIL
	 JRST MAPXB2
	BUG (HLT,<MAPXB: EXISTANT XB FOUND TO BE UNASSIGNED>)

MAPXB2:	POP P,1				;RESTORE XB SOFT ADR
	TLO 1,(1B3!1B13!DSKABT)		;NEW FILE, CLASS BIT, DSKABT
	CALL ASOFN			;GET OFN FOR XB
	 BUG (HLT,<MAPXB: FAILED TO ASOFN XB>)
	MOVEM 1,%OFN			;SAVE IT
	CALL ASGPAG			;GET A PAGE IN JOB AREA TO MAP TO
	 BUG (HLT,<MAPXB: FAILED TO ASGPAG FOR XB>)
	MOVEM 1,%PAGE			;SAVE THE PAGE
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,,PAGE ADR
	MOVE 1,%OFN
	CALL SETMPG			;MAP IT
	RET				;RESTORES TO RETURNED VALUES

	PURGE %UNIT,%BN,%PAGE,%OFN


;FILL OUT XB AND ASSIGN BLOCK SO NOT POINTING TO UNASSIGNED PAGE
;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL PACK #
;	 2/ BLOCK #
;	 3/ PAGE ITS MAPPED TO

SETXB:	ACMAC <%UNIT,%BN,%PAGE,%OFN>
	VARMAC <$TYPE>
	MOVEM 0,$TYPE
	CAIE 0,TYPHOM
	 JRST SETXB1
	MOVEI 1,HM1TBL			;ASSUME HOME BLOCK 1
	CAIE 2,1			;IS IT?
	 MOVEI 1,HM2TBL			;NO-HOME BLOCK 2
	JRST SETXB2			;INTO COMMON CODE

SETXB1:	CAIE 0,TYPBAT
	 BUG (HLT,<SETXB: ILLEGAL BLOCK TYPE REQUESTED>)
	MOVEI 1,BB1TBL			;ASSUME BAT BLOCK 1
	CAIE 2,1			;IS IT?
	 MOVEI 1,BB2TBL			;NO-BAT BLOCK 2
SETXB2:	ADD 1,%UNIT			;ADD IN PACK OFFSET
	MOVE 1,(1)			;GET BLOCK ADR
	CALL CDSKVA			;CONVERT TO SOFT LINEAR ADR
	CALL DSKASA			;ASSIGN THE BLOCK PAGE FIRST
	 BUG (HLT,<SETXB: FAILED TO ASSIGN BLOCK>)
	MOVE 2,%PAGE
	SKIPE HBXSTF			;DOES THE FILE ALREADY EXITS?
	 JRST SETXB3			;YES-DON'T CLOBBER PREVIOUS ENTRIES
	HRLI 3,(2)
	HRRI 3,1(2)
	SETZM (2)
	BLT 3,777(2)			;CLEAN OUT XB
SETXB3:	TLO 1,(DSKABT)			;TURN ON DSKABT
	TLO 1,RWXB			;GIVE ACCESS
	ADD 2,$TYPE			;PT AT RIGHT PAGE OF HOMBAT FILE
	MOVEM 1,(2)			;ENTER PTR TO BLOCK
	RET

	PURGE %UNIT,%BN,%PAGE,%OFN
	PURGE $TYPE

;UNMAP AND RELEASE XB
;ACCEPTS 0/ BLOCK TYPE
;	 3/ PAGE ITS MAPPED TO
;	 4/ OFN

RELXB:	ACMAC <%AC1,%AC2,%PAGE,%OFN>
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG			;UNMAP IT
	MOVE 1,%PAGE
	CALL RELPAG			;RELEASE JOB AREA PAGE ASSIGNMENT
	MOVE 1,%OFN
	CALL RELOFN			;BYE
	RET

	PURGE %AC1,%AC2,%PAGE,%OFN


;CREATES AND RELEASES FILE PTING TO PROPER XB
;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL UNIT #
;	 2/ # OF BLOCK INVOLVED

MAKFL:	ACMAC <%UNIT,%BN,%AC3,%AC4>
	VARMAC <$TYPE,$JFNAC,$DEVAC,<$STRNG,10>>
	SKIPE HBXSTF			;DOES FILE ALREADY EXIST?
	 RET				;YES, WORK HAS BEEN DONE ALREADY
	MOVEM JFN,$JFNAC		;DON'T CLOBBER THESE GUYS
	MOVEM DEV,$DEVAC
	MOVEM 0,$TYPE			;SAVE BLOCK TYPE
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	BUG (HLT,<MAKFL: ILLEGAL BLOCK TYPE REQUESTED>)
	MOVE 1,%UNIT
	MOVE 2,%BN
	HRROI 3,$STRNG
	CALL MKSTNG			;1 AND 2 SETUP
	MOVSI 1,200001			;NEW FILE ONLY WINS
	HRROI 2,$STRNG
	GTJFN
	 BUG (HLT,<MAKFL: FAILED TO GTJFN FOR FILE>)
	MOVE JFN,1			;LOOKOUT, JFN IS AN AC!
	LSH JFN,SJFN
	HRROI DEV,DSKDTB
	SETZ 0,				;CLEAR FLAGS FOR GETFDB
	CALL GETFDB
	 BUG (HLT,<MAKFL: FAILED TO GETFDB FOR FILE>)
	MOVE 3,%BN
	MOVEI 2,XB1TBL			;ASSUME WANT HOMBAT 1 XB ADR
	CAIE 3,1			;IS IT?
	 MOVEI 2,XB2TBL			;NO-USE HOMBAT 2 XB ADR
	ADD 2,%UNIT			;ADD IN UNIT OFFSET
	PUSH P,1			;SAVE RETURN FROM GETFDB
	MOVE 1,(2)			;GET XB ADR
	CALL CDSKVA			;CONVERT TO SOFT LINEAR ADR
	POP P,2				;RESTORE GETFDB RETURN TO WRONG AC
	EXCH 1,2			;1/ GETFDB RET, 2/ LINEAR XB ADR
	TLO 2,(DSKABT)			;TURN ON DSKABT
	MOVEM 2,FDBADR(1)		;INTO FDB OF FILE
	MOVSI 2,FDBNXF
	ANDCAM 2,FDBCTL(1)		;IT EXISTS
	MOVSI 2,FDBPRM!FDBUND
	IORM 2,FDBCTL(1)		;PROTECT IT
	MOVE 2,[102340,,7020]		;THE DAY THE EARTH STOOD STILL
	MOVEM 2,FDBCRE(1)		;DATES
	MOVEM 2,FDBCRV(1)
	MOVEM 2,FDBWRT(1)
	MOVSI 2,(0B5!44B11)
	IORM 2,FDBBYV(1)		;VER RETAIN,BYTE SIZE
	MOVEI 2,2000			;BYTE COUNT FOR 2 PAGES
	MOVEM 2,FDBSIZ(1)
	MOVEI 2,1			;ASSUME SYSTEM IS 1
	HRLM 2,FDBUSE(1)		;UPDATE CREATOR
	CALL USTDIR
	MOVE 1,JFN
	LSH 1,-SJFN
	RLJFN
	 BUG (HLT,<MAKFL: FAILED TO RLJFN FILE>)
	MOVE JFN,$JFNAC			;RESTORE THESE GUYS
	MOVE DEV,$DEVAC
	RET

	PURGE %UNIT,%BN,%AC3,%AC4
	PURGE $TYPE,$JFNAC,$DEVAC,$STRNG


;MAKE FILENAME STRING IN PTR IN 3
;ACCEPTS 1/ UNIT #
;	 2/ BLOCK #
;	 3/ PTR FOR STRING

MKSTNG:	ACMAC <%UNIT,%BN,%PTR,%AC4>
	MOVE 1,%PTR
	HRROI 2,[ASCIZ/<SYSTEM>HOMBAT-/]
	SETZ 3,
	SOUT
	MOVE 2,%BN
	MOVEI 3,1
	MOVEI 4,2
	CALL MKNMBR
	HRROI 2,[ASCIZ/.PACK-/]
	SETZ 3,
	SOUT
	MOVE 2,%UNIT
	MOVEI 3,0			;MIN OF 0
	MOVEI 4,^D99			;MAX OF ^D99
	CALL MKNMBR			;TACK ONTO PTR IN 1
	HRROI 2,[ASCIZ/;1;P404000/]	;VERSION 1 ONLY!
	SETZ 3,
	SOUT
	RET

	PURGE %UNIT,%BN,%PTR,%AC4

;TACK ASCIZ # ONTO PTR
;ACCEPTS 1/ PTR
;	 2/ #
;	 3/ MIN ALLOWED
;	 4/ MAX ALLOWED

;RETURNS 1/ UPDATED PTR, ASCIZ

MKNMBR:	ACMAC <%PTR,%NUM,%MIN,%MAX>
	CAML 2,%MIN			;RANGE CHECK
	CAMLE 2,%MAX
	 BUG (HLT,<MKNMBR: NUMBER OUT OF RANGE>)
	IDIVI 2,^D10
	JUMPE 2,MKNMB1			;NO LEADING ZEROES
	ADDI 2,"0"			;ASCII
	IDPB 2,1
MKNMB1:	ADDI 3,"0"
	IDPB 3,1
	MOVEM 1,%PTR			;UPDATE RETURNED PTR
	SETZ 2,
	IDPB 2,1
	RET

	PURGE %PTR,%NUM,%MIN,%MAX



;MAP BLOCK TO PAGE, READ AND WRITE
;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL UNIT #
;	 2/ BLOCK #

;RETURNS 3/ PAGE ADR
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP POSSIBLY WITH ERROR CODE IN 1

MAPBLK:	ACMAC <%UNIT,%BN,%PAGE,%JFN>
	VARMAC <$TYPE,<$STRNG,10>>
	MOVEM 0,$TYPE			;SAVE BLOCK TYPE
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	RET				;LOSE-ERROR # NOT VALID (TS)
	CALL ASGPAG			;GET PAGE FOR IT
	 RET				;LOSE-ERROR # NOT VALID (TS)
	MOVEM 1,%PAGE			;REMEMBER PAGE
	MOVE 1,%UNIT
	MOVE 2,%BN
	HRROI 3,$STRNG
	CALL MKSTNG			;MAKE FILENAME STRING
	MOVSI 1,100001			;OLD FILE ONLY
	HRROI 2,$STRNG
	GTJFN
	 RET
	MOVEM 1,%JFN
	MOVE 2,[440000,,300000]		;FOR READ AND WRITE
	OPENF
	 JRST [PUSH P,1			;SAVE ERROR CODE
		MOVE 1,%JFN
		RLJFN
		 JFCL
		POP P,1
		RET]			;OPENF ERROR CODE IN 1
	HRLZ 1,%JFN			;JFN,,
	HRR 1,$TYPE			;   ,,PAGE #
	SFRAME				;PRESERVE FRAME PTRS
	CALL JFNOFN			;GET OFN,,0
	 BUG (HLT,<MAPBLK: JFNOFN FAILED FOR BLOCK>)
	RFRAME				;RESTORE FRAM PTRS
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,,PAGE ADR
	CALL SETMPG
	AOS (P)				;SKIP SUCCESS
	RET

	PURGE %UNIT,%BN,%PAGE,%JFN
	PURGE $TYPE,$STRNG



;UNMAP AND RELEASE BLOCK
;ACCEPTS 0/ BLOCK TYPE
;	 3/ PAGE ADR ITS MAPPED TO
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

RELBLK:	ACMAC <%AC1,%AC2,%PAGE,%JFN>
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG
	MOVE 1,%JFN
	CLOSF
	 RET
	MOVE 1,%PAGE
	CALL RELPAG
	AOS (P)				;SKIP SUCCESS
	RET

	PURGE %AC1,%AC2,%PAGE,%JFN



;READS BLOCK TO PAGE WHEN FILESYSTEM NOT AVAILABLE
;SKIPS FOR SUCCESS

;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL UNIT #
;	 2/ BLOCK #

;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ REAL CORE ADR USED (LOCKED)


MP.BLK:	ACMAC <%UNIT,%BN,%PAGE,%RCORE>
	VARMAC <$TYPE>
	MOVEM 0,$TYPE
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	RET				;LOSE-ERROR # NOT VALID (TS)
	CALL ASGPAG			;GET A VIRTUAL PAGE FOR READ
	 RET				;YOU LOSE
	MOVEM 1,%PAGE			;SAVE VIRTUAL ADR
	MOVES (1)			;WHAT IS EXISTANCE?
	CALL FPTA			;MAKE OFN,,PAGE
	CALL MLKPG			;LOCK AND MAKE 1/ REAL CORE PAGE
	MOVSI 2,(CORMB)			;WE ARE GONNA MODIFY IT
	IORM 2,CST0(1)
	LSH 1,^D9			;MAKE REAL CORE ADR
	MOVEM 1,%RCORE			;RETURN REAL CORE ADR IN 4
	MOVE 1,$TYPE			;TYPE
	MOVE 2,%BN			;BLOCK #
	CAIE 1,TYPHOM
	 JRST MP.BL1
	MOVEI 1,HM1TBL			;GET HDWR ADR TABLE
	CAIE 2,1
	 MOVEI 1,HM2TBL
	JRST MP.BL2			;INTO COMMON CODE

MP.BL1:	MOVEI 1,BB1TBL
	CAIE 2,1
	 MOVEI 1,BB2TBL
MP.BL2:	ADD 1,%UNIT			;ADD IN UNIT OFFSET
	MOVE 1,(1)			;GET HDWR ADR OF BAT BLOCK WE WANT
	MOVEI 2,1000			;READ 1000 WORDS
	MOVE 3,%RCORE			;TO THIS REAL CORE ADR
	CALL UDSKIO			;RETURN WHEN DONE
	SKIPN 1				;NO SKIP IF ERROR BITS RETURNED
	 AOS (P)			;SKIP SUCCESS
	RET

	PURGE %UNIT,%BN,%PAGE,%RCORE
	PURGE $TYPE


;RELEASE BAT BLOCK WITHOUT AID OF FILESYSTEM
;WRITES IT OUT IF 1B0 OF AC3 IS ON
;SKIPS FOR SUCCESS

;ACCEPTS 0/ BLOCK TYPE
;	 1/ UNIT
;	 2/ BLOCK #
;	 3/ PAGE ITS MAPPED TO, 1B0 ON FOR WRITE IT OUT TO DISK
;	 4/ REAL CORE ADR THAT WAS USED (LOCKED)

RL.BLK:	ACMAC <%UNIT,%BN,%PAGE,%RCORE>
	VARMAC <$TYPE>
	MOVEM 0,$TYPE
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	RET				;LOSE-ERROR # NOT VALID (TS)
	MOVE 1,$TYPE			;TYPE
	MOVE 2,%BN			;BLOCK #
	CAIE 1,TYPHOM
	 JRST RL.BL1
	MOVEI 1,HM1TBL			;GET HDWR ADR TABLE
	CAIE 2,1
	 MOVEI 1,HM2TBL
	JRST RL.BL2			;INTO COMMON CODE

RL.BL1:	MOVEI 1,BB1TBL			;GET HDWR ADR TABLE
	CAIE 2,1
	 MOVEI 1,BB2TBL
RL.BL2:	ADD 1,%UNIT			;ADD IN UNIT OFFSET
	MOVE 1,(1)			;GET HDWR ADR OF BAT BLOCK WE WANT
	MOVE 2,[1B14!1000B35]		;WRITE 1000 WORDS
	MOVE 3,%RCORE			;REAL CORE ADR
	SKIPL %PAGE			;WANT IT WRITTEN?
	 JRST RL.BL3			;NO
	CALL UDSKIO			;1/ CORE ADR, 2/ DISK ADR
	SKIPE 1				;ERROR IF ERROR BITS RETURNED
	 RET
RL.BL3:	MOVE 1,%PAGE			;GET VIRTUAL ADR
	TLZ 1,(1B0)			;INCASE WRITE FLAG WAS ON
	CALL FPTA			;MAKE OFN.PN
	CALL MULKPG			;UNLOCK IT
	MOVE 1,%PAGE			;GET VIRTUAL ADR AGAIN
	TLZ 1,(1B0)			;INCASE WRITE FLAG WAS ON
	CALL RELPAG			;RELEASE PAGE
	MOVSI 1,(1B0)			;TURN OFF WRITE REQUEST FLAG
	ANDCAM 1,%PAGE			;AND RETURN IT TO USER
	AOS (P)				;WIN
	RET

	PURGE %UNIT,%BN,%PAGE,%RCORE
	PURGE $TYPE



;PARALLEL TABLES FOR GETTING PARAMETERS FOR DIFFERENT TYPES OF FILES

;PROCESSING FILE TYPES, INDEXES INTO FOLLOWING TABLES

TYPMON==0			;DEFAULT MONITOR
TYPCDL==1			;CRASH DUMP LOW 512
TYPCDH==2			;CRASH DUMP HIGH 512
TYPMIC==3			;MICROCODE (ALL PACKS)
TYPMCD==4			;MICRO DIAGNOSTICS (ALL PACKS)
TYPBOT==5			;BOOTSTRAP (ALL PACKS)

NTYPES==6			;# TYPES

;FILE NAMES
;0B0 INDICATES EXTENSION IS COMPLETE
;1B0 INDICATES EXTENSION SHOULD BE COMPLETED WITH PACK #

TYPNAM:	[ASCIZ/<SYSTEM>MONITR.SAV/]
	[ASCIZ/<SYSTEM>CORDMP.LOW/]
	[ASCIZ/<SYSTEM>CORDMP.HGH/]
	400000,,[ASCIZ/<SYSTEM>MICROCODE.PACK-/]
	400000,,[ASCIZ/<SYSTEM>MICRODIAG.PACK-/]
	400000,,[ASCIZ/<SYSTEM>BOOTSTRAP.PACK-/]

; - # PACKS,,STARTING PACK TO PUT FILES ON

TYPUNT:	-1,,PRMUNT		;MONITR.SAV
	-1,,PRMUNT		;CORE DUMP LOW
	-1,,PRMUNT		;CORE DUMP HIGH
	-NPACKS,,PRMUNT		;MICROCODE (ALL PACKS)
	-NPACKS,,PRMUNT		;MICRODIAG (ALL PACKS)
	-NPACKS,,PRMUNT		;BOOTSTRAP (ALL PACKS)


;HARWARE ADR OF XB'S
;NATURE OF HARWARE ADR IS SUCH THAT SIGN BIT IS NEVER ON AND THEREFORE
;0B0 INDICATES HARDWARE ADR COMPLETE
;1B0 INDICATES TABLE OF COMPLETE HARDWARE ADRS INDEXED BY UNIT #

TYPXBA:	MONADR			;HARDWARE ADR (PRIMARY PACK ONLY)
	CDLADR			;HARDWARE ADR (PRIMARY PACK ONLY)
	CDHADR			;HARDWARE ADR (PRIMARY PACK ONLY)
	400000,,MICTBL		;TABLE OF HARDWARE ADRS INDEXED BY PACK #
	400000,,MCDTBL		;TABLE OF HARDWARE ADRS INDEXED BY PACK #
	400000,,BOTTBL		;TABLE OF HARDWARE ADRS INDEXED BY PACK #

;# OF DATA PAGES TO ASSIGN INITIALLY
;0 YIELDS ZERO LENGTH FILE

TYPNPG:	0			;ASSIGN NO MONITR.SAV PAGES INITIALLY
	^D512			;CORE DUMP LOW 512 PAGES
	^D512			;CORE DUMP HIGH 512 PAGES
	^D32			;MICROCODE.PACK-X
	^D32			;MICRODIAG.PACK-X
	^D32			;BOOTSTRAP.PACK-X



;THE FOLLOWING CALCULATION OF SWPTK IS NECESSARY SO CAN BE USED
;AS NON-EXTERNAL IN FOLLOWING TABLES

HSECTK==NSURFS*NSECS
HPGTK==HSECTK*NWSEC/1000
HSKNST==<<<<NDST+HPGTK-1>/HPGTK>+NPACKS-1>/NPACKS>*NPACKS
HWPTK==NTKUN/2-<HSKNST/NPACKS>/2	;HWPTK = SWPTK

;HARDWARE ADR OF 0TH PAGE OF FILE
;NATURE OF HARWARE ADR IS SUCH THAT SIGN BIT IS NEVER ON AND THEREFORE
;0B0 INDICATES COMPLETED HDWR ADR
;1B0 INDICATES TABLE OF HDWR ADRS INDEXED BY UNIT #
;SUCCEEDING PAGES WILL BE ASSIGNED CONTIGUOUSLY VIA DSKASN
;NOTE CONTIGUITY MAY BE AFFECTED BY BAD SPOTS, STILL NEED XB MAPPING
;STARTING NEAR SWAPPING TRACKS INSURES DSKASN WILL KEEP ENTIRE FILE ON 1 PACK
;LESS EFFICIENT SEEK WISE (POSSIBLY NEGLIGIBLE) BUT SIMPLE

TYPPG0:	<PRMUNT>B<UNTLSB>+<HWPTK-1>B<CYLLSB>+0B<SRFLSB>+0B<SECLSB> ;MONITR.SAV
	<PRMUNT>B<UNTLSB>+<HWPTK-1>B<CYLLSB>+0B<SRFLSB>+0B<SECLSB> ;CORDMP LOW
	<PRMUNT>B<UNTLSB>+<HWPTK-1>B<CYLLSB>+0B<SRFLSB>+0B<SECLSB> ;CORDMP HIGH
	400000,,FILSAD						   ;MICROCODE
	400000,,FILSAD						   ;MICRODIAG
	400000,,FILSAD						   ;BOOTSTRAP


;TABLE OF START HARDWARE ADRS FOR FILES FOUND ON MULTIPLE PACKS
;INDEXED BY UNIT #

..U==0
FILSAD:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<HWPTK-1>B<CYLLSB>+0B<SRFLSB>+0B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS




;CREATE ALL SPECIAL FILES

CRTSFA:	PUSH P,1
	PUSH P,2
	HRROI 1,[ASCIZ/
Creating special system files./]
	PSOUT
	MOVSI 2,-NTYPES
CRTSF1:	HRRZ 1,2			;TYPE IN 1
	CALL CRTFIL
	AOBJN 2,CRTSF1
	POP P,2
	POP P,1
	RET

;CREATE FILE
;ACCEPTS TYPE IN 1

CRTFIL:	ACMAC <%TYPE,%AC2,%AC3,%AC4>
	VARMAC <$AOBJN,$PAGE,$OFN,$JFN>
	MOVE 2,%TYPE
	MOVE 2,TYPUNT(2)		;GET AOBJN FOR PACKS
CRTFI1:	MOVEM 2,$AOBJN			;UPDATE AOBJN PTR
	MOVE 1,%TYPE			;TYPE IN 1
	HRRZ 2,$AOBJN			;CURRENT UNIT IN 2
	CALL MP1XB			;MAP THE INDEX BLOCK
	MOVEM 3,$PAGE
	MOVEM 4,$OFN
	MOVE 1,%TYPE
	HRRZ 2,$AOBJN
	CALL ST1XB			;SET UP XB AND ASSIGN ALL DATA PAGES
	MOVE 3,$PAGE
	MOVE 4,$OFN
	CALL RL1XB			;RELEASE THE XB
	MOVE 1,%TYPE
	HRRZ 2,$AOBJN
	CALL MK1FL			;MAKE THE FILE
	MOVE 1,%TYPE
	HRRZ 2,$AOBJN
	CALL MP1FL			;NOW MAP THE FILE
	 BUG (HLT,<CRTFIL: FAILED TO MAP JUST CREATED FILE>)
	MOVEM 3,$PAGE
	MOVEM 4,$JFN
	MOVE 1,%TYPE
	HRRZ 2,$AOBJN
	CALL CL1PG			;CLEAN IT OUT
	MOVE 3,$PAGE
	MOVE 4,$JFN
	CALL RL1FL			;UNMAP AND RELEASE
	 BUG (HLT,<CRTFIL: FAILED TO RELEASE JUST CREATED FILE>)
	MOVE 2,$AOBJN
	AOBJN 2,CRTFI1			;LOOP FOR ALL PACKS DESIRED
	RET

	PURGE %TYPE,%AC2,%AC3,%AC4
	PURGE $AOBJN,$PAGE,$OFN,$JFN



;ASSIGN AND MAP XB FOR FILE
;ACCEPTS 1/ TYPE
;	 2/ UNIT
;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ OFN

MP1XB:	ACMAC <%TYPE,%UNIT,%PAGE,%OFN>
	MOVE 1,%TYPE
	MOVE 1,TYPXBA(1)		;XB ADR TABLE
	TLNN 1,(1B0)			;IS ENTRY PTR TO TABLE?
	 JRST MP1XB1			;NO-ENTRY IS HDWR ADR
	ADD 1,%UNIT			;YES-ADD IN UNIT OFFSET
	MOVE 1,(1)			;GET TABLE ENTRY
MP1XB1:	CALL CDSKVA			;CONVERT TO LINEAR ADR
	CALL DSKASA			;ASSIGN THE XB
	 BUG (HLT,<MP1XB: DSKASA FAILED FOR XB>)
	TLO 1,(1B3!1B13!DSKABT)		;NEW FILE, CLASS BIT, DSKABT
	CALL ASOFN			;GET OFN FOR XB
	 BUG (HLT,<MP1XB: ASOFN FAILED FOR XB>)
	MOVEM 1,%OFN
	CALL ASGPAG			;GET A JOB AREA PAGE TO MAP TO
	 BUG (HLT,<MP1XB: ASGPAG FAILED FOR XB>)
	MOVEM 1,%PAGE
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,, PAGE ADR
	MOVE 1,%OFN
	CALL SETMPG			;MAP IT
	RET

	PURGE %TYPE,%UNIT,%PAGE,%OFN



;FILL OUT XB AND ASSIGN ALL DATA PAGES
;ACCEPTS 1/ TYPE
;	 2/ UNIT
;	 3/ PAGE ITS MAPPED TO

ST1XB:	ACMAC <%TYPE,%UNIT,%PAGE,%OFN>
	VARMAC <$AOBJN,$ADR>
	MOVE 1,%PAGE
	HRLI 2,(1)
	HRRI 2,1(1)
	SETZM (1)
	BLT 2,777(1)			;CLEAN OUT XB
	MOVE 1,%TYPE
	MOVN 2,TYPNPG(1)		;# DATA PAGES TO ASSIGN
	JUMPE 2,ST1XB5			;JUMP IF NONE
	HRLS 2				;NEGATIVE INTO LH FOR AOBJN
	HRR 2,%PAGE			;STEPS THRU XB
ST1XB2:	MOVEM 2,$AOBJN			;UPDATE AOBJN SAVER
	MOVE 1,%TYPE			;GET TYPE
	MOVE 1,TYPPG0(1)		;DATA PAGE 0 OF FILE
	TLNN 1,(1B0)			;IS IT PTR TO TABLE?
	 JRST ST1XB4			;NO-ENTRY IS ADR
	ADD 1,%UNIT			;YES-ADD IN UNIT OFFSET
	MOVE 1,(1)			;NOW GET TABLE ENTRY HDWR ADR
ST1XB4:	CALL CDSKVA			;CONVERT TO SOFT LINEAR ADR
	CALL DSKASN			;GET A PAGE ASSIGNED NEAR AS POSSIBLE
	 BUG (HLT,<ST1XB: FAILED TO DSKASN DATA PAGE>)
	MOVE 2,$AOBJN			;RESTORE AOBJN PTR
	TLO 1,(DSKABT)			;DSKABT
	TLO 1,RWXB			;GIVE IT ACCESS
	MOVEM 1,(2)			;ENTER IT IN XB
	AOBJN 2,ST1XB2			;LOOP FOR ALL PAGES
ST1XB5:	RET

	PURGE %TYPE,%UNIT,%PAGE,%OFN
	PURGE $AOBJN,$ADR

;UNMAP AND RELEASE XB
;ACCEPTS 3/ PAGE ITS MAPPED TO
;	 4/ OFN

RL1XB:	ACMAC <%AC1,%AC2,%PAGE,%OFN>
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG			;UNMAP IT
	MOVE 1,%PAGE
	CALL RELPAG			;RELEASE JOB AREA PAGE ASSIGNMENT
	MOVE 1,%OFN
	CALL RELOFN			;BYE
	RET

	PURGE %AC1,%AC2,%PAGE,%OFN



;CREATES AND RELEASES FILE PTING TO XB
;ACCEPTS 1/ TYPE
;	 2/ UNIT

MK1FL:	ACMAC <%TYPE,%UNIT,%AC3,%AC4>
	VARMAC <$JFNAC,$DEVAC,<$STRNG,10>>
	MOVEM JFN,$JFNAC		;SAVE THESE GUYS
	MOVEM DEV,$DEVAC
	MOVE 1,%TYPE
	MOVE 2,%UNIT
	HRROI 3,$STRNG
	CALL MK1STG			;BUILD NAME IN STRING
	MOVSI 1,200001
	HRROI 2,$STRNG
	GTJFN
	 BUG (HLT,<MK1FL: FAILED TO GTJFN FOR FILE>)
	MOVE JFN,1			;LOOKOUT, JFN IS AN AC!
	LSH JFN,SJFN
	HRROI DEV,DSKDTB
	SETZ 0,				;CLEAR FLAGS FOR GETFDB
	CALL GETFDB
	 BUG (HLT,<MK1FL: FAILED TO GETFDB FOR FILE>)
	PUSH P,1			;SAVE RETURN FROM GETFDB
	MOVE 1,%TYPE
	MOVE 1,TYPXBA(1)
	TLNN 1,(1B0)			;TABLE PTR?
	 JRST MK1FL1			;NO
	ADD 1,%UNIT			;YES-ADD IN UNIT OFFSET
	MOVE 1,(1)			;AND GET THE HDWR XB ADR
MK1FL1:	CALL CDSKVA			;CONVERT TO LINEAR ADR
	MOVE 2,1			;SHUFFLE THINGS
	POP P,1				;RESTORE GETFDB RETURN
	TLO 2,(DSKABT)			;TURN ON DSKABT
	MOVEM 2,FDBADR(1)		;INTO FDB OF CD FILE
	MOVSI 2,FDBNXF
	ANDCAM 2,FDBCTL(1)		;IT EXISTS
	MOVSI 2,FDBPRM!FDBUND
	IORM 2,FDBCTL(1)		;PROTECT IT
	MOVE 2,[102340,,7020]		;THE DAY THE EARTH STOOD STILL
	MOVEM 2,FDBCRE(1)		;DATES
	MOVEM 2,FDBCRV(1)
	MOVEM 2,FDBWRT(1)
	MOVSI 2,(0B5!44B11)
	IORM 2,FDBBYV(1)		;VER RETAIN,BYTE SIZE
	MOVE 2,%TYPE
	MOVE 2,TYPNPG(2)		;# PAGES
	LSH 2,^D9			;TIMES 512 WORDS PER PAGE
	MOVEM 2,FDBSIZ(1)
	MOVEI 2,1			;ASSUME SYSTEM IS 1
	HRLM 2,FDBUSE(1)		;UPDATE CREATOR
	CALL USTDIR
	MOVE 1,JFN
	LSH 1,-SJFN
	RLJFN
	 BUG (HLT,<MK1FL: FAILED TO RLJFN FILE>)
	MOVE JFN,$JFNAC			;RESTORE THESE GUYS
	MOVE DEV,$DEVAC
	RET

	PURGE %TYPE,%UNIT,%AC3,%AC4
	PURGE $JFNAC,$DEVAC,$STRNG



;BUILD FILENAME

;ACCEPTS 1/ TYPE
;	 2/ UNIT
;	 3/ PTR TO STRING STORAGE

MK1STG:	ACMAC <%TYPE,%UNIT,%PTR,%AC4>
	MOVE 1,%PTR
	MOVE 2,%TYPE
	HRRO 2,TYPNAM(2)		;GET ENTRY
	SETZ 3,
	SOUT
	MOVE 2,%TYPE
	MOVE 2,TYPNAM(2)
	TLNN 2,(1B0)			;DOES EXTENSION NEED COMPLETION
	 JRST MK1ST1			;NO
	MOVE 2,%UNIT
	MOVEI 3,0
	MOVEI 4,^D99
	CALL MKNMBR			;TACK ON DRIVE NUMBER
MK1ST1:	HRROI 2,[ASCIZ/;1;P404000/]
	SETZ 3,
	SOUT
	RET

	PURGE %TYPE,%UNIT,%PTR,%AC4


;MAP FILE PAGE 0 TO PAGE, READ AND WRITE
;RETURNS 1/ TYPE
;	 3/ PAGE ADR
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

MP1FL:	ACMAC <%TYPE,%UNIT,%PAGE,%JFN>
	VARMAC <<$STRNG,10>>
	CALL ASGPAG			;GET PAGE FOR IT
	 RET				;LOSE-ERROR # NOT VALID (TS)
	MOVEM 1,%PAGE			;REMEMBER PAGE
	MOVE 1,%TYPE
	MOVE 2,%UNIT
	HRROI 3,$STRNG
	CALL MK1STG			;BUILD FILEPATH
	MOVSI 1,100001
	HRROI 2,$STRNG
	GTJFN
	 RET
	MOVEM 1,%JFN
	MOVE 2,[440000,,300000]		;FOR READ AND WRITE
	OPENF
	 JRST [PUSH P,1			;SAVE ERROR CODE
		MOVE 1,%JFN
		RLJFN
		 JFCL
		POP P,1
		RET]			;OPENF ERROR CODE IN 1
	HRLZ 1,%JFN			;JFN,,0
	SFRAME				;PRESERVE FRAME PTRS
	CALL JFNOFN			;GET OFN,,0
	 BUG (HLT,<MP1FL: JFNOFN FAILED FOR FILE>)
	RFRAME				;RESTORE FRAM PTRS
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,,PAGE ADR
	CALL SETMPG
	AOS (P)				;SKIP SUCCESS
	RET

	PURGE %TYPE,%UNIT,%PAGE,%JFN
	PURGE $STRNG

;UNMAP AND RELEASE FILE
;ACCEPTS 3/ PAGE ADR ITS MAPPED TO
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

RL1FL:	ACMAC <%AC1,%AC2,%PAGE,%JFN>
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG
	MOVE 1,%JFN
	CLOSF
	 RET
	MOVE 1,%PAGE
	CALL RELPAG
	AOS (P)				;SKIP SUCCESS
	RET

	PURGE %AC1,%AC2,%PAGE,%JFN



;CLEARS OUT ALL FILE PAGES FOR FILE
;ACCEPTS 1/ TYPE
;	 3/ PAGE 0TH PAGE IS MAPPED TO
;	 4/ JFN
;RETURNS LAST PAGE STILL MAPPED

CL1PG:	ACMAC <%TYPE,%AC2,%PAGE,%JFN>
	VARMAC <$AOBJN>
	MOVE 1,%TYPE
	MOVN 1,TYPNPG(1)		;# DATA PAGES TO CLEAR
	JUMPE 1,CL1PG3			;DON'T FAULT IF NONE TO DO
	HRLZM 1,$AOBJN			;NEGATIVE INTO LH FOR AOBJN
	JRST CL1PG2			;0TH PAGE ALREADY MAPPED

CL1PG1:	MOVEM 1,$AOBJN			;UPDATE AOBJN SAVER
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG			;UNMAP CLEARED PAGE
	HRL 1,%JFN
	HRR 1,$AOBJN			;NEXT PAGE #
	SFRAME				;PRESERVE FRAME PTRS
	CALL JFNOFN			;MAKE OFN,,PAGE
	 BUG (HLT,<CL1PG: JFNOFN FAILED FOR FILE PAGE>)
	RFRAME				;RESTORE FRAM PTRS
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,,PAGE ADR
	CALL SETMPG
CL1PG2:	MOVE 2,%PAGE
	HRLI 1,(2)
	HRRI 1,1(2)
	SETZM (2)
	BLT 1,777(2)			;CLEAR A PAGE
	MOVE 1,$AOBJN
	AOBJN 1,CL1PG1			;LOOP FOR ALL PAGES
CL1PG3:	RET				;DONE, LEAVE LAST PAGE MAPPED

	PURGE %TYPE,%AC2,%PAGE,%JFN
	PURGE $AOBJN


;HOMBAT PARAMETER TABLE
;SPECIFIES WHERE VARIOUS HOMBAT RELATED PAGES LIVE
;1B0 MEANS ON ALL PACKS, 0B0 MEANS ON PRIMARY PACK OF STRUCTURE ONLY


HOMBAT:	VERHOM,,HOMLEN		;LATEST HOME BLOCK VER,,LEN KNOWN TO MONITOR
	VERBAT,,BATLEN		;LATEST BAT BLOCK VER,,LEN KNOWN TO MONITOR
	FREBAT			;INITAL FREE COUNT FOR VERBAT VERSON OF BAT BLK
	BATSCT			;POINTER TO SECTOR COUNT FIELD FOR VERBAT
	BATADR			;POINTER TO HDWR DSK ADR FIELD FOR VERBAT
	PRMUNT			;PRIMARY UNIT OF A STRUCTURE
	1B0!<CYLALL>B<CYLLSB>!<SRFXB1>B<SRFLSB>!<SECXB1>B<SECLSB> ;XB1
	1B0!<CYLALL>B<CYLLSB>!<SRFHM1>B<SRFLSB>!<SECHM1>B<SECLSB> ;HM1
	1B0!<CYLALL>B<CYLLSB>!<SRFBB1>B<SRFLSB>!<SECBB1>B<SECLSB> ;BB1
	1B0!<CYLALL>B<CYLLSB>!<SRFXB2>B<SRFLSB>!<SECXB2>B<SECLSB> ;XB2
	1B0!<CYLALL>B<CYLLSB>!<SRFHM2>B<SRFLSB>!<SECHM2>B<SECLSB> ;HM2
	1B0!<CYLALL>B<CYLLSB>!<SRFBB2>B<SRFLSB>!<SECBB2>B<SECLSB> ;BB2
	1B0!<CYLALL>B<CYLLSB>!<SRFMIC>B<SRFLSB>!<SECMIC>B<SECLSB> ;MIC
	1B0!<CYLALL>B<CYLLSB>!<SRFMCD>B<SRFLSB>!<SECMCD>B<SECLSB> ;MCD
	1B0!<CYLALL>B<CYLLSB>!<SRFBOT>B<SRFLSB>!<SECBOT>B<SECLSB> ;BOT
	0B0!<CYLALL>B<CYLLSB>!<SRFMON>B<SRFLSB>!<SECMON>B<SECLSB> ;MON
	0B0!<CYLALL>B<CYLLSB>!<SRFCDL>B<SRFLSB>!<SECCDL>B<SECLSB> ;CDL
	0B0!<CYLALL>B<CYLLSB>!<SRFCDH>B<SRFLSB>!<SECCDH>B<SECLSB> ;CDH
NHOMBA==.-HOMBAT


;READS CRASH DUMP XB AND WRITES OUT ALL OF CORE
;WRITE LOW 512 THEN HIGH 512.  IF THAT CONSITITUTES NXM THEN TOUGH SHIT.
;DISK DRIVER IS TOO STUPID TO HANDLE ERRORS INTELLIGENTLY RIGHT NOW.

CRASH:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	VARMAC <$XBDAD,$XBVAD,$XBRAD,$AOBJN,$OFN.P>
	MOVE 1,[CDLADR]			;INIT XB DISK ADR
	MOVEM 1,$XBDAD
	CALL ASGPAG			;GET A VIRTUAL PAGE FOR XB READ
	 RET				;YOU LOSE
	MOVEM 1,$XBVAD			;SAVE VIRTUAL ADR
	MOVES (1)			;WHAT IS EXISTANCE?
	CALL FPTA			;MAKE OFN,,PAGE
	MOVEM 1,$OFN.P			;SAVE IT FOR UNLOCKING
	CALL MLKPG			;LOCK AND MAKE 1/ REAL CORE PAGE
	MOVSI 2,(CORMB)			;WE ARE GONNA MODIFY IT
	IORM 2,CST0(1)
	LSH 1,^D9			;MAKE REAL CORE ADR
	MOVEM 1,$XBRAD			;REMEMER IT
CRASH1:	MOVSI 1,-1000			;INIT AOBJN
	MOVEM 1,$AOBJN			;SAVE IT
	MOVE 1,$XBDAD			;GET HDWR DISK ADR FOR XB
	MOVEI 2,1000			;READ 1000 WORDS
	MOVE 3,$XBRAD			;GET REAL CORE ADR TO READ TO
	CALL UDSKIO			;READ IT
	SKIPE 1				;ANY ERRORS?
	 JRST CRASH5			;YES-RELEASE PAGE AND NO SKIP FAILURE
	SKIPA 1,$AOBJN			;LOAD AOBJN PTR INTO 1
CRASH2:	MOVEM 1,$AOBJN			;UPDATE AOBJN PTR SAVER
	ADD 1,$XBVAD			;PT AT VIRTUAL SLOT
	MOVE 1,(1)			;GET IT
	TLNN 1,(DSKABT)			;POINTING TO DISK?
	 JRST CRASH6			;NO-DON'T CHASE IT DOWN, LOSE THIS PAGE
	CALL CVDSK			;CONVERT TO HARDWARE DISK ADR
	MOVE 2,[1B14!1000B35]		;WRITE 1000 WORDS
	HRRZ 3,$AOBJN			;GET PAGE TO SPIT
	LSH 3,^D9			;MAKE REAL CORE ADR
	CALL UDSKIO			;WRITE A CORE PAGE TO CRASH DUMP
	SKIPE 1				;ANY ERRORS?
	 JRST CRASH6			;YES-REPORT IT
CRASH3:	MOVE 1,$AOBJN
	AOBJN 1,CRASH2			;LOOP FOR ALL CORE PAGES
	MOVE 1,$XBDAD			;GET XB DISK ADR WE JUST USED
	CAMN 1,[CDHADR]			;JUST DID HI?
	 JRST CRASH4			;YES-DONE
	MOVE 1,[CDHADR]			;NO, DID LO, DO HI NOW
	MOVEM 1,$XBDAD
	JRST CRASH1

CRASH4:	AOS (P)				;SKIP RET
CRASH5:	MOVE 1,$OFN.P			;GET OFN.PAGE
	CALL MULKPG			;UNLOCK IT
	MOVE 1,$XBVAD			;GET VIRTUAL ADR OF PAGE
	CALL RELPAG
	RET

CRASH6:	HRROI 1,[ASCIZ/
Crash dump core page /]
	PSOUT
	MOVE 1,$XBDAD
	SETZ 2,
	CAME 1,[CDLADR]			;LOW?
	 MOVEI 2,1000			;NO-HIGH
	HRRZ 1,$AOBJN
	ADD 2,1				;2/ PAGE # WE ARE WORKING ON
	MOVEI 1,101
	MOVEI 3,10
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/ will be garbaged.
/]
	PSOUT
	JRST CRASH3			;CONTINUE

	PURGE %AC1,%AC2,%AC3,%AC4
	PURGE $XBDAD,$XBVAD,$XBRAD,$AOBJN,$OFN.P



;RESIDENT MONITOR RELOADER
;NO ACMAC OR VARMAC IN HERE SINCE CAN'T RELY ON SUPPORT ROUTINES

RLDSTR==36				;1ST LOC RELOADED

RLDCDA==3000				;WHERE TO RUN THIS CODE
RLDXBA==RLDCDA+1000			;WHERE TO READ XB
RLDM0A==RLDXBA+1000			;WHERE TO READ MAP INFO PAGES
RLDM1A==RLDM0A+1000			;2 PAGES WORTH POSSIBLE
RLDCDE==RLDM1A+1000-1			;END OF PAGE THIS STUFF LIVES ON

;RELOCATES RESIDENT MONITOR RELOADER AND JUMPS TO IT

RELOAD:	MOVE 1,[RESRDB,,RLDCDA]
	BLT 1,RLDCDA+777		;RELOCATE RELOAD CODE
	MOVEI 1,PPRMPG*1000		;LOAD UP TO (NOT INCL) SWAPPABLE MON
	MOVEI 2,SYSGO			;WHERE TO JUMP TO WHEN RELOADED
	JRST RDRESM			;GO TO IT, RELOCATED

	LIT				;GET ALL LITERALS OUT OF THE WAY

RESRDB:					;SYMBOL FOR START OF BLT

	PHASE RLDCDA			;START OF PHASED CODE

;CODE BETWEEN HERE AND ;******* LINE MUST BE AT MOST 1 PAGE.
;CALCULATION AND CHECKING AT ASSEMBLY TIME WON'T WORK DUE TO
;BUGS IN PHASE AND DEPHASE PSEUDO OPS IN MACRO (V 50 ANYWAY)

RLDPDL:	BLOCK 20			;LOCAL PHASED STACK
RLDPDP:	IOWD 20,RLDPDL			;STACK PTR

;READS RESIDENT MONITOR FROM SSAVE FORMAT FILE ON DISK.
;THE 0TH PAGE LOW CORE UP TO RLDSTR IS NOT READ OVER.
;THE WAY THINGS ARE ADJUSTED, PAGE 0 MUST BE READ BEFORE PAGE 1.
;BUT OTHER PAGES CAN BE READ IN ANY ORDER.
;CLEANS UP ALL RESIDENT CORE NOT READ IN INCLUDING CORE IT RUNS IN.

;ACCEPTS 1/ TOP BOUNDRY PAGE (START OF SWPAPPABLE MONITOR)
;	 2/ RETURN LOCATION DESIRED

RDRESM:	MOVE P,RLDPDP			;NEW STACK
	PUSH P,2			;SAVE RETURN LOC DESIRED
	PUSH P,1			;SAVE BOUND
	PUSH P,1			;RESERVE SPACE FOR AOBJN SAVER
	CALL RLDCLR			;CLEAR OUT ALL MEMORY UP TO BOUND
	MOVEI 1,RLDXBA			;REAL CORE ADR FOR FILE XB
	MOVE 2,[MONADR]			;HDWR DISK ADR OF MONITOR XB
	CALL DREAD			;READ IT
	SKIPN 2,RLDXBA			;ANY FILE OUT THERE?
	 JRST 4,RDRESM			;NO-HALT, TRY AGAIN IF ASKED TO
	CALL CVTSFT			;MAKE HARWARE ADR FOR PAGE 0
	MOVEI 1,RLDM0A			;TO HERE FOR MAPPING INFO
	CALL DREAD
	SKIPN 2,RLDXBA+1		;IS THERE A 2ND MAPPING INFO PAGE?
	 JRST RDRES1			;NO-IGNORE FILE PAGE 1
	CALL CVTSFT			;YES-CONVERT TO HDWR
	MOVEI 1,RLDM1A			;TO HERE FOR MORE MAPPING INFO
	CALL DREAD
	JRST RDRES1



;HERE WHEN XB AND ALL MAPPING INFO READ INTO CORE
;NOW SUCK UP THE PAGES
;SHADOW ACS GET CLOBBERED FOR PAGE 0 READ BUT NOT REAL ACS!!
;CAREFUL NOT TO CLOBBER PAGES IN USE
;READS IN ONLY THOSE BELOW GIVEN BOUND

RDRES1:	HRLZ 4,RLDM0A			;GET N PAGES
	MOVNS 4
	HRRI 4,RLDM0A+1			;AOBJN PTR, START AT WORD 1
RDRES2:	MOVEM 4,0(P)			;UPDATE AOBJN SAVER
	LDB 1,[POINT ^D9,(4),17]	;GET FORK PAGE
	CAML 1,-1(P)			;LESS THAN BOUNDRY GIVEN US?
	 JRST RDRES3			;NO-SKIP IT
	CAIN 1,0			;PAGE 0?
	 SKIPA 1,[RLDSTR]		;YES-START AT THIS LOC, ENDING IN PG 1
	LSH 1,^D9			;NOW-MAKE IT REAL CORE ADR
	CAIE 1,RLDCDA			;THIS PAGE?
	CAIN 1,RLDXBA			;OR XB PAGE?
	 JRST RDRES3			;YES-SKIP IT
	CAIE 1,RLDM0A			;OR MAP PAGES?
	CAIN 1,RLDM1A
	 JRST RDRES3			;YES-SKIP IT
	HRRZ 2,(4)			;GET FILE PAGE
	MOVE 2,RLDXBA(2)		;GET ITS ADR
	CALL CVTSFT			;MAKE HDWR DISK ADR
	PUSH P,1			;SAVE MEMORY START ADR
	CALL DREAD			;READ THE PAGE IN
	POP P,1				;RESTORE IT
	CAIN 1,RLDSTR			;WAS IT START PAGE 0 OFFSET?
	 JRST RDRES3			;NO-NOTHIN TO DO
	MOVE 1,[RLDSTR+RLDSTR,,RLDSTR]	;YES-GOT TO BLT IT DOWN
	BLT 1,777			;FIXING UP 0TH PAGE
	MOVE 1,[1000,,1001]		;AND CLEANUP PAGE OVERLAP
	SETZM 1000			;IN PAGE 1
	BLT 1,1000+RLDSTR-1
RDRES3:	MOVE 4,0(P)			;GET MAP INFO PTR AGAIN
	AOBJN 4,RDRES2			;LOOP FOR ALL PAGES
	POP P,1				;DISCARD SAVED AOBJN PTR
	POP P,1				;RESTORE BOUND
	MOVE 1,[CLRRLD,,3]		;RELOCATE CLEANUP TO ACS
	BLT 1,3+CLRRLS-1
	POP P,1				;RESTORE RETURN LOC TO AC 1
	JRST 3				;JUMP TO IT, CLEANUP, RETURN

;AC RUNNABLE CODE TO CLEAN OUT THE PAGES WE ARE RUNNING IN BEFORE RETURNING.
;HAS RETURN LOC IN AC 1 WHEN RUN

CLRRLD:	MOVE 2,[RLDCDA,,RLDCDA+1]	;AC3 - 2 IS SCRATCH REG
	SETZM RLDCDA			;AC4
	BLT 2,RLDCDE			;AC5 - CLEAN IT ALL OUT
	JRST (1)			;AC6 - HAS RETURN LOC DESIRED

CLRRLS==.-CLRRLD			;SIZE OF CLEANUP CODE


;CLEARS ALL RES MEMORY BETWEEN RLDSTR AND BOUND FOUND IN AC 1
;IS CAREFUL NOT TO COMMIT SUICIDE

RLDCLR:	PUSH P,1			;SAVE BOUND
	PUSH P,[0]			;INIT PAGE COUNTER
RLDCL1:	MOVE 1,0(P)			;GET PAGE TO CLEAR
	CAIN 1,0			;0TH PAGE?
	 SKIPA 1,[RLDSTR]		;YES-START AT SPECIAL PLACE
	LSH 1,^D9			;NO-MAKE ADR
	CAIE 1,RLDCDA			;THIS PAGE?
	CAIN 1,RLDXBA			;OR XB PAGE?
	 JRST RLDCL2			;YES-SKIP IT
	CAIE 1,RLDM0A			;OR MAP PAGES?
	CAIN 1,RLDM1A
	 JRST RLDCL2			;YES-SKIP IT
	HRL 2,1				;START ADR IN LH 2
	HRR 2,1				;AND RH
	ADDI 2,1			;BUMP RH TO START + 1
	SETZM (1)			;CLEAR 1ST LOC
	TRZ 1,777			;MASK OFF INDEX INTO PAGE
	BLT 2,777(1)			;CLEAR IT OUT
RLDCL2:	AOS 1,0(P)			;BUMP PAGE COUNTER
	CAMGE 1,-1(P)			;DONE?
	 JRST RLDCL1			;NO-DO NEXT PAGE
	POP P,1				;DISCARD PAGE COUNTER
	POP P,1				;RESTORE BOUND PAGE
	RET

;CONVERT SOFTWARE LINEAR DISK ADR IN 2 TO HDWR FORMAT IN 2
;SIMILAR TO CVDSK IN DSKPAK, HERE FOR PHASING

CVTSFT:	PUSH P,1			;CLOBBER NO ACS
	PUSH P,3
	PUSH P,4
	MOVE 1,2			;GET LINEAR ADR
	TLZ 1,DSKMSK			;FLUSH EXTRA BITS
	MOVEI 2,NTKUN			;GET AROUND EXTERNAL ARITHMETIC
	IMULI 2,NSECTK
	IDIV 1,2			;ISOLATE UNIT IN 1
	IDIVI 2,NSECTK			;ISOLATE CYLINDER IN 2
	IDIVI 3,NSECS			;ISOLATE SURFACE IN 3, SECTOR IN 4
	LSH 1,NCYLBT+NSRFBT+NSECBT	;SHIFT 1 TO HARDWARE UNIT FIELD
	LSH 2,NSRFBT+NSECBT		;SHIFT 2 TO HARDWARE CYLINDER FIELD
	LSH 3,NSECBT			;SHIFT 3 TO HARDWARE SURFACE FILED
	IOR 1,2				;MERGE CYLINDER WITH UNIT FIELDS
	IOR 1,3				;MERGE SURFACE FIELD
	IOR 1,4				;MERGE SECTOR FIELD
	MOVE 2,1			;RET IN AC2
	POP P,4				;RESTORE ACS
	POP P,3
	POP P,1
	RET


;ITSY BITSY POOLE DISK DRIVER COPIED FROM DSKPAK FOR PHASING

;CALL:	MOVE 1,[<MEMORY STARTING ADDRESS>]
;	MOVE 2,[BYTE(6)UNIT(13)CYLINDER(8)HEAD(8)SECTOR]
;	PUSHJ P,<DWRITE OR DREAD>
;	<RETURNS ON SUCCESS, HALTS AT DERROR ON ERROR>
;	  <AT DERROR, REG. 0 HAS ERROR BITS IN IT.>
;CLOBBERS 1,2,3


;DEFS. OF TEMP. IOTS

OPDEF LA[723000,,0]
OPDEF RA[717000,,0]
OPDEF LC[721000,,0]
OPDEF RC[715000,,0]
OPDEF LE[724000,,0]
OPDEF LM[722000,,0]
OPDEF RM[716000,,0]


;RIGHT HALF ERROR BITS

S.ANY==200
S.NACT==20

;LEFT HALF BITS

S.NBSY==1000
S.SERR==400000
S.IPE==10			;INTERNAL PARITY ERROR
S.OVRN==40			;DATA OVERRUN
S.WRP==200000			;UNIT IS WRITE PROTECTED
S.NRDY==100000			;UNIT NOT READY
S.SKER==20000			;SEEK ERROR (CODE BELOW DOES AUTO. RECALIBRATE)
S.FALT==10000			;UNIT FAULT

;LOCAL PHASED STORAGE

DA:	BLOCK 1
MA:	BLOCK 1
CMD:	BLOCK 1
RCNT:	BLOCK 1
ERRBIT:	BLOCK 1
DINTFG:	BLOCK 1



DREAD:	TDZA 3,3		;READ COMMAND IS ALL ZERO.

DWRITE:	MOVEI 3,11000		;WRITE COMMAND.
	PUSH P,0		;0 USED AS TEMP. BELOW
	MOVEM 2,DA		;SAVE DISK ADDRESS
	CALL DOOP		;DO THE OPERATION.
	POP P,0
	RET

DOOP:	MOVEM 1,MA		;RECORD THE DATA ADDRESS.
	MOVEM 3,CMD		;ALSO THE COMMAND.
	MOVEI 10		;RETRY COUNT
	MOVEM RCNT
	LE [2]			;RESET CTRL
DOOP1:	MOVE 1,DA		;GET DISK ADDRESS
	LA 1			;DESELECT
	TLO 1,2000		;INSTALL SELECT ENABLE BIT
	LA 1			;SELECT DRIVE AND LOAD DSK ADR.
	RC 0			;READ STATUS BITS.
	TLNN S.NRDY		;DRIVE NOT READY ?
	TLNE S.SERR		;SELECT ERROR ?
B.SERR:	JSP 2,B.ERR
	MOVEI 1,404000		;GIVE CLEAR FAULT COMMAND.
	SETZM DINTFG		;TELL GO TO WAIT FOR COMPLETION
	CALL GO
	JSP 2,B.ERR		;TIMEOUT RETURN
	MOVE 1,CMD		;NOW GIVE MAIN COMMAND.
	LM MA			;LOAD THE MEMORY ADDRESS.
	RC 0
	TLNN S.NRDY		;BETTER STILL BE READY...
	TRNE S.ANY		;...NO ERRORS SHOULD HAVE APPEARED...
R.ANY:	JSP 2,B.ERR
	SETOM DINTFG		;TELL GO TO RETURN IMMEDIATELY
	CALL GO
	JRST [	CALL RECAL	;RECALIBRATE IF TIMEOUT
		JRST ERR1]	;THEN GO RETRY IF NOT TOO MANY ERRORS
	TLNN S.IPE		;INTERNAL PARITY ERROR ?
	TRNE S.ANY		;ANY OTHER ERROR ?
G.ANY:	JSP 2,B.ERR
DOOPX:	RET



GO:	LE [2]			;INIT THE CONTROLLER.
	LC 1			;SEND THE COMMAND.
	LE [1]			;START THE CONTROLLER.
	SKIPE DINTFG		;ARE WE TO WAIT FOR COMPLETION?
	JRST GO2			;NO, RETURN IMMEDIATELY
	MOVEI 1,60000		;TIMEOUT DELAY
GOL:	RC 0
	IMULI 4,1		;STOP USING MEMORY FOR A WHILE.
	TRNN S.NACT		;CHECK FOR ACTIVE
	SOJG 1,GOL
	JUMPLE 1,.+2		;CHECK FOR TIMED OUT...
GO2:	AOS (P)			;SKIP RETURN IF NO ERROR...
	RET

B.ERR:	SUBI 2,1
	TLNE S.SERR		;SELECT ERROR ?
	 JRST DERROR		;DIE !
	TLNE S.SKER		;SEEK ERROR ?
	CALL RECAL		;YES, RECALIBRATE
ERR1:	SOSG RCNT		;HAVE WE RETRIED ENOUGH ?
	JRST DERROR		;YES.
	JRST DOOP1		;TRY, TRY, TRY AGAIN...


RECAL:	MOVE 1,[1404000]	;RECALIBRATE
	SETZM DINTFG		;TELL GO TO WAIT FOR COMPLETION
	CALL GO
	JRST DERROR		;DIE IF THIS TIMES OUT
	TRNE S.ANY
	JRST DERROR		;OR IF ANY ERROR OCCURED
	RET

DERROR:	MOVEM ERRBIT		;PRESERVE THE MAGIC BITS.
	POP P,(P)		;REMOVE DOOP'S RETURN ADR.
	POP P,0			;RESTORE 0.
	JRST 4,RDRESM		;HALT, START OVER IF ASKED TO
	RET

	LIT			;PHASE LITERALS TOO

	DEPHASE			;END OF PHASED CODE

;********			;MARKER FOR ABOVE COMMENT



	PURGE ..U,..N			;UTILITY SYMBOLS ZAPPED

	END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           