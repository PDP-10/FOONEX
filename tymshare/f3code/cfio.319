;CTYDSP CTYINT CTYIOT CTYDI CTYDO CTYCO CTYCI CTYCI2 CTYCI1 CTYCI9 CTYCI8 CTYCI3 CTYCO1
; CTYCO3 CTYCO4 CTYCO5 CTYRST ctyrs1 CTYCZ CTYCS
;------------------------------------------------------------------------------
;
;	CTY - Console Teletype				Device 120
;
;------------------------------------------------------------------------------

;
;A-MEM Usage
;
CTY-DISP = 0		;Instruction and interrupt dispatch
CTY-CONT = 1		;Control bits for UART, etc.
CTY-STATUS = 2		;Firmware status

;
;*** Meanings of hardware bits should be documented here.
;
;MAPF values

.REPEAT NTP [
TTY.DI = 0	;read data
TTY.WD = 12	;write data
TTY.WC = 14	;write control
  ] ;NTP

.REPEAT OTP [
TTY.DI = 0	;read data
TTY.WD = 4	;write data
TTY.WC = 10	;write control
  ] ;OTP

;*$*$*	This ORG is ready to be flushed.  It only remains to test the code
;	and merge the AREAs

	.ORG[CTYIOTDISP-ORG]	;CTY IOT DISPATCH TABLE

CTYDSP:	ILGIOT $	;BLKI
	NOP $
	D[CTY-STATUS + 10] DEST[Q] SPEC[IOB-IN] NORM $ ;DATAI
	MAPF[TTY.DI] D[IOD] DEST[AR] JUMP[CTYDI] CYLEN[IOB-IN] $
	ILGIOT $	;BLKO
	NOP $
	FIXM1 $		;DATAO
	D[CTY-STATUS + 10] DEST[Q] JUMP[CTYDO] NORM $ ; GET CONI BITS
	D[CTY-STATUS + 10] MASK[7] DEST[Q] NORM $ ;CONO, GET CONI BITS
	D[IR] MASK[7] ROT[40] ALU[-D&Q] DEST[Q] JUMP[CTYCO] NORM $ ;CLR THE CLR BITS
	D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
		; CONI, GET BITS
	D[AR] DEST[MEMSTO] MEMST $
	D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
		;CONSZ, GET BITS
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
		;CONSO, GET CONI BITS
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
;$*$*$ We may not be able to afford this in the future...  TVR-Apr80
LPTDSP:
.REPEAT 1 - LPT [
     .REPEAT 10 [ILGIOT $
	NOP $
];.REPEAT 10
];.REPEAT 1 - LPT

.REPEAT LPT [		;Allocate space for LPT dispatch
:. + 20
];.REPEAT LPT

;AREA51 starts here.


: 2130 ;CTY and 60 HZ CLOCK INTS COME HERE

CTYINT:
  .REPEAT NTP [;With new tape controller, 60HZ clk shares DEV 4 w/ CTY.
	START-IN SHORT $
	MAPF[5] D[IOD] ALU[NOTD] DEST[AR] C600 $
		;Read the NET interface status...
	D[AR] MASK[1] C550 -OBUS=0 JUMP[CLKINT] $
		;Is 60HZ clk requesting an int. ? Jump if so.
	NORM JUMP[CTYIN1] $
		;Else it is the CTY's turn.
: 2144
      ] ;NTP

CTYIN1:	D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
		; DO A CONI, GET BITS
	D[CTY-CONT + 10] MASK[11] DEST[IOD] SPEC[IOB-OUT] NORM $; DISABLE INTS
	MAPF[TTY.WC] CYLEN[IOB-OUT] D[CTY-STATUS + 10] MASK[3] DEST[Q AR] $
		; GET PI CHAN
	NORM  DEST[CLR-DEV-FROM-INTR] JUMP[PIGEN] $;CAUSE INTR.

;$*$*$ This one is referenced off the MAP dispatch
: 5210
	.PAIR
	UIOTRP[MUUO] $
CTYIOT:	IOTDIS [CTYIOTDISP-ORGARG]

CTYDI:	D[CONST 40] ALU[-D&Q] DEST-A-MEM DEST[CTY-STATUS] NORM $; CLR TTI FLAG
	D[CONST 10] ROT[3] DEST[Q] SHORT $
	D[CTY-CONT + 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $;CLR RCV. CHR
	MAPF[TTY.WC]  CYLEN[IOB-OUT] $
	D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[TTY.WC] CYLEN[IOB-OUT] $
	D[AR] MASK[10] DEST[MEMSTO] MEMST $
CTYDO:	D[MEM] DEST[IOD] SPEC[IOB-OUT] NORM $;SEND CHR.
	MAPF[TTY.WD] CYLEN[IOB-OUT] D[CONST 10] ALU[-D&Q] DEST[Q] $;CLR TTO FLAG
	D[CTY-CONT + 10] ALU[D+1] DEST[IOD] SPEC[IOB-OUT] NORM $
		;ENABLE UART STB
	MAPF[TTY.WC] CYLEN[IOB-OUT]
			D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM $
		;SET TTO BUSY
	D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR UART STB
	MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST 7] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] $ ; DONE IF NO PI CHAN
	D[CTY-CONT + 10] DEST[Q] SHORT $; GET IOB-OUT BITS
	D[CONST 4] ROT[11] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ ;ENABLE XMT INT
	MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
CTYCO:	D[CONST 17] ROT[3] ALU[D&Q] DEST[Q] NORM $;CLR PI BITS
	D[IR] MASK[7] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM JUMP[CTYCO1] NORM $
		;OR IN NEW PI BITS
CTYCI:	MAPF[TTY.DI] D[IOD] DEST[HOLD] CYLEN[IOB-IN] $;GET UART BITS
	D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[TTY.WC] D[MEM] ROT[26] MASK[1] COND[-OBUS=0] JUMP[CTYCI1] CYLEN[MAX,IOB-OUT,C550] $; J IF RCV RDY
CTYCI2:	D[CONST 10] ROT[3] ALU[-D&Q] DEST[Q AR] JUMP[CTYCI9] NORM $;CLR TTI BUSY
CTYCI1:	D[CONST 40] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI2] C550 $;J IF TTI FLAG ON
	D[CONST 10] ROT[3] ALU[D#Q] DEST[Q AR] NORM $;COMPL BUSY.
	D[CONST 10] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI9] C550 $;J IF BUSY NOW ON
	D[CONST 40] ALU[DORQ] DEST[Q AR] NORM $; SET TTI FLAG
CTYCI9:	D[MEM] ROT[25] MASK[1] COND[-OBUS=0] JUMP[CTYCI8] C550 $;J IF XMT RDY
	D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $
		;SET BUSY -- NOTE, NO "AR DEST" IS CORRECT
CTYCI8:	D[CONST 20] ALU[D&Q] COND[OBUS=0] JUMP[CTYCI3] C550 $; J IF BUSY OFF
	D[CONST 10] ALU[DORQ] DEST[Q] NORM $; SET FLAG
CTYCI3:	D[CONST 20] ALU[-D&Q] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $ ;CLR BUSY
CTYCO1:	D[IR] ROT[41] MASK[10] DEST[Q] NORM $; GET SET&CLR BITS
	D[CONST 10] ROT[3] ALU[D&Q] COND[OBUS=0] JUMP[CTYCO4] $
		; J IF CLR TTI FLAG OFF
	D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $;GET IOB-OUT BITS
	D[CONST 10] ROT[3] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
		;GET CLR RCV RDY BIT
CTYCO3:	MAPF[TTY.WC] CYLEN[IOB-OUT] $
	ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR IT
	MAPF[TTY.WC] CYLEN[IOB-OUT] $
CTYCO4:	D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $; GET IOB-OUT BITS
	D[CTY-STATUS + 10] MASK[3] COND[OBUS=0] JUMP[CTYCO5] C550 $
		; J IF NO PI CHAN
	D[CONST 2] ROT[11] ALU[DORQ] DEST[Q] SHORT $; ENBL RCV INT
	D[CTY-STATUS + 10] ROT[41] MASK[2] COND[OBUS=0] JUMP[CTYCO5] C550 $
		; J IF NO OUT FLAG OR BUSY
	D[CONST 4] ROT[11] ALU[DORQ] DEST[Q] SHORT $;ENBL XMT INT
CTYCO5:	ALU[Q] DEST[IOD] SPEC[IOB-OUT] SHORT $; FIX INT ENBLS
	MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
; **** HERE IS DEFN. OF CTY UART CONSTANTS ****

CTYRST:	D[CONST 4] DEST[DEV-ADR] NORM $
	D[CONST 4] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $
	D[CONST 74] ALU[DORQ] DEST[Q CTY-CONT] DEST-A-MEM NORM $
	D[CONST 3] ROT[6] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $; RESET UART
	MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[0] DEST[CTY-STATUS] DEST-A-MEM $
	ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM JUMP[CTYRS1] $
    .USE[AREA356] 	;$*$*$*$ Temporary ****
CTYRS1:
;Setup entry vectors: IOT vector in left half, interrupt vector in right half	
	MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST (CTYDSP / 100)] ROT[18. + 6.] DEST[Q] $
		;High order 6 IOT bits
	D[CONST (CTYDSP \ 100)] ROT[18.] ALU[DORQ] DEST[Q] NORM $
		;Low order 6 IOT bits
	D[CONST (CTYINT / 100)] ROT[6.] ALU[DORQ] DEST[Q] NORM $
		;High order 6 interrupt bits
	D[CONST (CTYINT \ 100)] ROT[0] ALU[DORQ]
			SPEC[DEST-A-MEM] DEST[CTY-DISP] POPJ NORM $
		;Low order 6 interrupt bits
		;Finish setting up vectors and return.

AREA52:	;$*$*$* Recover what space may be left???

;;;	.USE[AREA206]
;;;	debuguse = .

;;;:2074	;%$#@#$% SLOEXP didn't redefine AREA206 properly??? $*$*$*$

	.USE[NORMAL]

	.PAIR
CTYCZ:	D[AR] ALU[D&Q] COND[-OBUS=0] JUMP[MAIN] C550 $
	DOSKIP $
CTYCS:	D[AR] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $
	DOSKIP $





;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
;      be moved to the end of regular disk stuff.  TVR-Apr80
DSKRST:	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
	  ;SET DSK CTRL COMMAND REGISTER TO 0 (DISABLES INTS).
	MAPF[4] D[CONST 2] DEST[IOD] SPEC[IOB-OUT]
				CYLEN[IOB-OUT] $
	  ;NOW RESET THE CONTROLLER.
	MAPF[7] ALU[0] DEST[1] DEST-A-MEM  CYLEN[IOB-OUT]  POPJ $
	  ;ALSO CLEAR THE PI CHANNEL ASSIGNMENT.

SET-DSK-OUT:
	D[CONST 10] DEST[DEV-ADR] NORM COND[-USER] JUMP[SDSKO2] $
	UIOTRP[MUUO] $
		;Watch for IOT-USER mode.
SDSKO2:	D[MEM] DEST[IOD AR] SPEC[IOB-OUT] NORM POPJ $

;Kludge to allow disk controller status IOTs from IOT-USER Mode.  This is
;so a wizard can look at the state of the disk controller from MDDT (or UEDDT).
UDSKST:	UIOTRP[MUUO] $
		;Ignore SPEC[IOB-IN] we just did and trap if in user mode.
	D[IR] ROT[8 + 1 + 1] MASK[10.] DEST[Q] $
		;Extract opcode
	D[CONST 1] ALU[DORQ] DEST[Q] $
		;Skip first micro instruction that got us here
	D[CONST 2] ROT[9.] ALU[DORQ] SDISP CYLEN[DISP] SPEC[IOB-IN] $
		;Dispatch again to finish instruction

;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
;      be moved to the end of regular disk stuff.  TVR-Apr80
TYMRST:		;RESET TYMNET INTERFACE
	D[CONST 1] DEST[Q] PUSHJ[DEV6CL] NORM $
.REPEAT TYMNET [
	JUMP[TYMRS1] NORM $	;SET INITIAL COROUTINE ADR, INT ENBLS.
];TYMNET
.REPEAT 1 - tymnet [
	POPJ NORM $
]; 1 - tymnet

;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80

 .REPEAT OTP [

CLKRST:	  ;RESET 60HZ CLOCK FLAG AND DISABLE ITS INTERRUPTS.
	D[CONST 1] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
		;LOAD A MASK INTO Q AND GO TO COMMON ROUTINE.
	;FALLS IN
CLKCLR:	  ;CLEAR 60HZ CLOCK FLAG.
	D[CONST 6] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT]  ;THIS CLEARS THE FLAG.
.REPEAT 1 - KL [
	 D[10 + APRSTS] SPEC[A-MEM-APR] ROT[32] MASK[1] DEST[AR] $
		;FOR KA STYLE CONI WORD
];.REPEAT 1 - KL
.REPEAT KL [
	D[10 + APRSTS] SPEC[A-PR] ROT[13. + 1.] MASK[1] DEST[AR] $
	  ;GET THE CLOCK ENABLE FLAG IN AR35
];.REPEAT KL
	D[CONST 1] ALU[NOTD] DEST[Q] JUMP[DEV6ST] NORM $
	 ;SET OR CLEAR THE HARDWARE INTRPT. ENB. ACCORDING TO
	 ; STATE OF CLK INT ENB BIT IN APR 
  ] ;OTP

 .REPEAT NTP [

CLKRST:		;Fall in to CLKCLR
CLKCLR:	START-OUT D[CONST 4] DEST[DEV-ADR] NORM $
		;Clear clk flag.
.REPEAT 1 - KL [
CLKENB:	MAPF[7] D[10 + APRSTS] SPEC[A-MEM-APR] ROT[26.] DEST[IOD] C600 $
];.REPEAT 1 - KL
.REPEAT KL [
CLKENB:	MAPF[7] D[10 + APRSTS] SPEC[A-MEM-APR] ROT[13. + 1.] DEST [IOD] C600 $
];.REPEAT KL
	  	;GET THE APR CONDITIONS WD, PUT CLK INT ENB BIT IN BIT 35.
	START-OUT NORM $
	MAPF[6] C600 POPJ $
	 	;SET OR CLEAR THE HARDWARE INTRPT. ENB. ACCORDING TO
	 	; STATE OF CLK INT ENB BIT IN APR 
  ] ;NTP

.REPEAT OTP [  ;Tape and Timer interact only with old tape ctrl...

TAPRST:	 ;RESET THE TAPE CONTROLLER AND ASSOCIATED DEVICES.

	D[CONST 7] DEST[DEV-ADR] NORM $ ;SELECT DEVICE.
;;	ALU[0] DEST[] DEST-A-MEM NORM $
		;Set tape mode to CORE-DUMP
   .REPEAT KNYTAPE [ PUSHJ[KNYRST] $ 
			;Clear KENNEDY formatter, if any. ]

   	D[CONST 1] ROT[35.] DEST[Q] NORM $	;

   .REPEAT TIMER [  ;IF INTERVAL TIMER IS PRESENT...
	D[CONST 1] ROT[35. - 19.] ALU[DORQ] DEST[Q 1] DEST-A-MEM $
	   ;FORM DATA TO CLR TAPE ERR FF'S, ENABLE TIMER INTRPTS
     ] ;TIMER
   .REPEAT 1 - TIMER [  ;IF INTERVAL TIMER IS ABSENT...
	ALU[Q] DEST[Q 1] DEST-A-MEM $
	   ;FORM DATA TO CLR TAPE ERR FF'S, DISABLE TIMER INTRPTS
     ] ;1 - TIMER

	START-OUT D[CONST 1] ROT[35. - 6] ALU[DORQ] DEST[IOD] NORM $
	   ;DO SO;  ALSO CLEAR TIMER OVERFLOW INTRPT FLAG.
	MAPF[1] START-OUT D[CONST 1] ROT[35. - 9] DEST[Q IOD] C800 $
	   ;ALSO CLEAR ALL SIGNALS TO THE DEVICE, SET "CLOCK RUN"
	MAPF[6] ALU[Q] DEST[2] DEST-A-MEM  C800 $
	   ;RECORD THE "CLOCK RUN" BIT IN A-MEM[2]; EVERYONE WHO
	   ; LOADS THE CTL REG (MAPF[4]) SHOULD INCLUDE IT.
	D[CONST 60] ROT[35. - 15.] DEST[Q] NORM $
	D[CONST 30] ROT[35. - 21.] ALU[DORQ] DEST[Q] NORM $
	   ;ASSEMBLE -1000. AS 12-BIT NO. ENDING AT BIT 21.
	START-OUT D[CONST 41] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
	   ;THIS SETS TIMER CLOCK FOR 100 USEC TICKS, ZEROES COUNTER.
	MAPF[1] ALU[0] DEST[3] DEST-A-MEM C800 POPJ $
	   ;INIT THE TIMER REG. TO 0 AND RETURN.
   ] ;OTP

;$*$*$*$* This should be moved to CFKNYD.SLO   TVR-Sep80
  .REPEAT NTP [

TAPRST:	 ;RESET THE TAPE CONTROLLER.
	D[CONST 7] DEST[DEV-ADR] NORM $ ;SELECT DEVICE.
	START-OUT ALU[0]  DEST[IOD] $
	 ;Turn off "FORMATTER ENABLE"
	MAPF[2] LONG $
	  ;Fall in to TIMRST.

TIMRST:	D[CONST 5] DEST[DEV-ADR] NORM $
	START-OUT D[CONST TIMER] DEST[IOD] NORM $
		;Enable timer interrupts if TIMER is 1, else disable them.
	MAPF[10] ALU[0] DEST[1] DEST-A-MEM C600 $
		;Clear pi channel
	ALU[0] DEST[3] DEST-A-MEM NORM POPJ $
		;Clear timer reg.
   ] ;NTP

APRRST:
.REPEAT F2SW [
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $	;Clear Addr. Break
];REPEAT F2SW
	MAPF[1] ALU[0] DEST[APRSTS] SPEC[A-MEM-APR&DEST-A-MEM] CYLEN[IOB-OUT] POPJ $
;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80

CLRDEVINT:	   DEST[CLR-DEV-FROM-INTR] POPJ NORM $
		;CLEAR FLAG WHICH CAUSES DEV-ADR TO BE
		; ADR OF LAST INTERRUPTING DEVICE,
		; SO THE DEV-ADR REGISTER WILL WORK AGAIN.





;------------------------------------------------------------------------------
;
;	PI - Priority Interrupt Service			Device 4
;
;------------------------------------------------------------------------------

;PI SYSTEM USE OF APR AMEM---
; 4	MEM PAR ERR(BIT 19), MEM PAR ERR INTRPT ENB(BIT 20),
;	 PI SYSTEM ON(BIT 28) CHN1-7 ON (BITS 29-35)
; 5	WAITING RQ 1-7 (11-18)  IN PROG 1-7 (29-35)
; 6	RQ COUNTS - 4-BIT FIELDS, CHN. 7 AT RIGHT END OF WORD.
;
;Other uses of APR AMEM are documented at the beginning 

PI-GET-CHN:	;MAKE BINARY CHN. NO. FROM MASK IN AR.
	D[AR] ROT[34] DEST[AR] NORM $
		;PUT RQ 1 INTO BIT 1
	D[CONST 6] DEST[MA] NORM $
		;MA WILL GET 7-CHN (FOR USE IN SHIFTING)
PIL1:	D[AR] ROT[1] DEST[AR] C550
	   COND[OBUS<0] JUMP[PIGETMASK] $ ;FOUND FIRST BIT ?
	D[MA] ALU[D-1] DEST[MA] NORM JUMP[PIL1] $
		;NO. DECREMENT COUNT AND LOOP.
PIGETMASK:	D[MA] DEST[ROTR] NORM $ ;LOAD ROTATE AMT.
	D[CONST 1] ROT[R] DEST[AR] NORM 
	  POPJ $	;MAKE MASK OF FIRST BIT ONLY IN AR.


PI-CHECK-RQS:	 ;SEE IF IT IS TIME TO TAKE AN INTRPT.
.REPEAT STANSW [	;Determine which PI channels should be enabled for PAN
	D[14] SPEC[A-MEM-APR] ROT[35. - 10.] DEST[Q] PUSHJ[PANIST] NORM $
		;Select only those channels turned on and readyt to interrupt
	MAPF[PAN-INT-ENB] CYLEN[IOB-OUT] 
	 D[15] SPEC[A-MEM-APR] ROT[18.] MASK[7] DEST[AR]
	 COND[OBUS=0] JUMP[MAIN] $ ;ANY RQ'S ?
];.REPEAT STANSW
.REPEAT 1 - STANSW [
	D[15] SPEC[A-MEM-APR] ROT[18.] MASK[7] DEST[AR]
	  C550 COND[OBUS=0] JUMP[MAIN] $ ;ANY RQ'S ?
];.REPEAT 1 -STANSW
	ALU[0] DEST[DEV-ADR] NORM PUSHJ[PI-GET-CHN] $
		;GET UNARY CHN NO. IN AR, SHIFT AMT. IN MA, ROTR
	D[14] ROT[34] C550 COND[-OBUS<0] JUMP[MAIN] $
		;EXIT IF PI SYS NOT ON.
	D[MASK 7] ROT[R] DEST[Q] NORM $
		;MASK OF CHN AND ALL HIGHER CHNS.
	D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[MAIN] $
		;EXIT IF THIS OR HIGHER CHN IN PROGRESS.
	D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
	D[14] ALU[D&Q] C550 COND[OBUS=0] JUMP[MAIN] $
		;EXIT IF CHN NOT ON.
	D[MA] ROT[2] DEST[ROTR] NORM $
		;GET SHIFT AMT 4 TIMES LARGER, TO ACCESS CNT FIELD
	D[CONST 1] ROT[R] DEST[Q] NORM $
		;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
	D[16] ALU[D-Q] DEST[Q HOLD] NORM $
		;DECREMENT OUR WAITING RQ COUNT.
	D[16] ALU[D#Q] DEST[Q] NORM $ ;DID WE OVERFLOW ?
	D[CONST 20] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[.] $
	  ;LOOP HERE FOREVER IF WE OVERFLOWED 4-BIT CNT FIELD
	D[MEM] DEST[6 Q] DEST-A-MEM NORM $
		;PUT BACK WORD OF RQ COUNTS.
	D[CONST 17] ROT[R] ALU[D&Q] C550
	  COND[-OBUS=0] JUMP[PIINTGO] $ ;JUMP IF OUR COUNT NEQ 0
	D[AR] ROT[18.] ALU[NOTD] DEST[Q] NORM JUMP[PIL11] $
		;MASK FOR CLEARING THE WAITING RQ BIT.
PIINTGO:	D[CONST 0] ALU[NOTD] DEST[Q] NORM $
		;DON'T CLEAR THE BIT, RQ'S STILL WAITING
PIL11:	D[15] ALU[D&Q] DEST[Q] NORM $
		;GET STATUS B, EITHER DO OR DO NOT CLEAR RQ BIT
	D[AR] ALU[DORQ] DEST[5] DEST-A-MEM NORM $
		;SET IN PROGRESS BIT, STORE STATUS B.
	D[PC] DEST[Q AR] NORM $ ;GET PC INTO Q, AR.
	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $ ;CLR USR MODE

;;;	D[MA] ROT[18.] ALU[DORQ] DEST[1] DEST-A-MEM NORM $
;;; This is an obsolete bug trap -- DWP 9/80

.REPEAT 1 - KL [
	D[CONST 56] DEST[Q] NORM $
		;PREPARE TO CALC. INTRPT. ADDRESS.
	D[MA] ROT[1] ALU[Q-D] DEST[MA] NORM JUMP[PIMUUO] $
		;FETCH INTRPT. INSTR AND GO INTERPRET IT.
];.REPEAT 1 - KL
.REPEAT KL [;KL PI VECTORS ARE RELATIVE TO THE EPT

	D[CONST 1] DEST[DEV-ADR] NORM$
		;SET TO AMEM BLOCK 1 WHERE PAGING STUFF IS
	D[17] ROT[9.] MASK[9. + 13.] DEST[Q] PUSHJ[MAPOF] NORM $
		;GET EPT ADDRESS IN Q, TURN MAP OFF.
	D[CONST 56] ALU[D+Q] DEST[Q] NORM $
		;GET EPT+56 (IF CHANNEL 7)
	D[MA] ROT[1] ALU[Q-D] DEST[HI-ABS-MA MA] NORM $
		;START INSTRUCTION IN, TURN MAP ON (HAPPENS AFTER)
	ALU[0] DEST[HI-ABS-MA] NORM JUMP[PIMUUO] $
		;CLEAR OUT HI MA PART AND GO DO THE INSTRUCTION WITH MAP ON
		; AR HAS PC BEFORE WE TURNED OFF USER.
		; WILL GET NORMAL PAGE FAULT IF IT FAULTS, THIS IS PROBLEM.
];.REPEAT KL




PIGEN:	 ;ENTER WITH CHN IN AR TO REQUEST INTRPT.
	ALU[0] DEST[DEV-ADR] NORM PUSHJ[CLRDEVINT] $
	D[14] DEST[Q] NORM $
	D[CONST 1] ROT[18.] ALU[D+Q] DEST[4] DEST-A-MEM
		NORM $
	D[CONST 7] DEST[Q] NORM $
		;7-CHN IS AMT TO SHIFT BY FOR MASK BIT.
	D[AR] MASK[3] ALU[Q-D] DEST[MA] NORM
	  PUSHJ[PIGETMASK] $ ;LOAD ROTR, FORM MASK IN AR
PIGEN1:	D[14] ROT[34] C550 COND[-OBUS<0] JUMP[PIGENWT] $
		;BRANCH IF PI SYS NOT ON.
	MASK[7] D[2] ROT[R] DEST[Q] NORM $
		;MASK OF CHN AND ALL HIGHER CHNS.
	D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIGENWT] $
		;BRANCH IF THIS OR HIGHER CHN IN PROGRESS.
	D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
	D[14] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIINTGO] $
		;IF CHN ON, GO TAKE INTRPT.
PIGENWT:	  ;INTRPT CANNOT HAPPEN NOW, SO SET A WAITING RQ.
	D[MA] ROT[2] DEST[ROTR] NORM $
		;GET SHIFT AMT 4 TIMES LARGER, TO GET CNT FIELD
	D[CONST 1] ROT[R] DEST[Q] NORM $
		;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
	D[16] ALU[D+Q] DEST[Q HOLD] NORM $
		;INCREMENT OUR WAITING RQ COUNT.
	D[CONST 10] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[. + 2] $
	  ;DON'T LET COUNT GET HIGHER THAN 7.
	D[MEM] DEST[6] DEST-A-MEM NORM $
		;PUT BACK WORD OF RQ COUNTS.
	D[15] DEST[Q] NORM $
		;GET STATUS B.
	D[AR] ROT[18.] ALU[DORQ] DEST[5] DEST-A-MEM
	   NORM JUMP[UINT-DISMISS] $ ;SET WAITING RQ BIT.
			;NOTE THAT WE CAN BE HERE FROM CONO PI ALSO, SO THAT
			;MICROINTERRUPTDISMISS ISN'T EXACTLY RIGHT, BUT
			; IN THAT CASE NO TRAP FLAGS ARE SET
PI-DISMISS:
	D[15] SPEC[A-MEM-APR] MASK[7] DEST[AR]
	  C550 COND[-OBUS=0] PUSHJ[PI-GET-CHN] $
	D[15] SPEC[A-MEM-APR] DEST[Q] NORM $
	D[AR] ALU[-D&Q] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM]
		NORM JUMP[PI-CHECK-RQS] $




PICONO:  ;Here from any CONO PI,
	D[MA] MASK[7]  DEST[AR] NORM $
	ALU[0] DEST[DEV-ADR] NORM $
	D[14]  DEST[Q] NORM $ ;GET STATUS A
.REPEAT 1 - KL [;ONLY KA STYLE HAS APR STUFF IN CONO PI
	D[MA] ROT[21.]  C550 COND[-OBUS<0] JUMP[PIL7] $
	D[CONST 1] ROT[35. - 20.] ALU[DORQ] DEST[Q] NORM $ 
	 ; TURN ON PAR ERR INTRPT ENB.
PIL7:	D[MA] ROT[20.]  C550 COND[-OBUS<0] JUMP[PIL8] $
	D[CONST 1] ROT[35. - 20.] ALU[-D&Q] DEST[Q] NORM $ 
	 ;TURN OFF PAR ERR INT ENB
PIL8:	D[MA] ROT[19.] C550 COND[-OBUS<0] JUMP[PIL9] $
	D[CONST 1] ROT[35. - 19.] ALU[-D&Q] DEST[Q] NORM $ 
	 ;CLEAR MEM PAR ERR FLAG
];.REPEAT 1 - KL
PIL9:	D[MA] ROT[5]  C550 COND[OBUS18] PUSHJ[PI-RESET] $
	D[MA] ROT[12]  C550 COND[-OBUS18] JUMP[PIL3] $
	D[CONST 1] ROT[7] ALU[DORQ] DEST[Q] NORM $ ; PI ON
PIL3:	D[MA] ROT[11]  C550 COND[-OBUS18] JUMP[PIL4] $
	D[CONST 1] ROT[7] ALU[-D&Q] DEST[Q] NORM $ ; PI OFF
PIL4:	D[MA] ROT[7]  C550 COND[-OBUS18] JUMP[PIL5] $
	D[AR] ALU[DORQ] DEST[Q] NORM $ ; CHNS ON
PIL5:	D[MA] ROT[10]  C550 COND[-OBUS18] JUMP[PIL6] $
	D[AR] ALU[-D&Q] DEST[Q] NORM $ ; CHNS OFF
PIL6:	ALU[Q] DEST[4] DEST-A-MEM NORM $
	D[MA] ROT[6]  C550 COND[-OBUS18] JUMP[PI-CHECK-RQS] $
	D[AR] MASK[7] ALU[0-D] DEST[Q] NORM $
		;GENERATED INTRPTS REQUESTED. CHECK TO
		; MAKE SURE ONLY ONE CHN IS SPECIFIED.
	D[AR] MASK[7] ALU[D&Q] DEST[Q] NORM $
	D[AR] MASK[7] ALU[D-Q] C600
	  COND[-OBUS=0] JUMP[.] $ ;HANG HERE IF MORE THAN ONE.
	D[AR] MASK[7]  DEST[AR] NORM PUSHJ[PI-GET-CHN] $
		;GET BINARY CHN. NUMBER AND UNARY MASK.
	NORM JUMP[PIGEN1] $ ;GO GENERATE REQUEST.


PICONISUB:
	D[14] SPEC[A-MEM-APR] MASK[18.] DEST[Q] NORM $
	  ;GET SYS ON AND CHN ON BITS.
	D[15] SPEC[A-MEM-APR] MASK[10] DEST[AR] NORM $
	  ;GET PI IN PROG BITS
	D[AR] ROT[10] ALU[DORQ] DEST[AR Q] NORM $
	D[15] SPEC[A-MEM-APR] ROT[18.] MASK[10] DEST[AR] NORM $
	  ;GET WAITING RQ BITS, AND RETURN IN LEFT HALF.
	D[AR] ROT[18.] ALU[DORQ] DEST[AR Q] NORM POPJ $

PI-RESET:
	ALU[0] DEST[4] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	ALU[0] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	ALU[0] DEST[6 Q] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $

;;;	ALU[0] DEST[1] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $
;;; This is an obsolete bug trap -- DWP 9/80

END-OF-PI-CODE:




;; MBOOT MOVED TO PAGE WITH REST OF TAPE STUFF





;MAPIOT MAPIO1 MAPCO0 MAPCOB MAPCOC MFT1 MFT1A MFT1D MFRD MFOTH MBLT3 SETHLF QORCRY SETHFU BWRTA1 MBLT2 MAPCWT MAPCW1 MAPCW2
.REPEAT 1 - KL [
;------------------------------------------------------------------------------
;
; 	BBN Pager - Map CONO Dispatch Table
;
;*** What these things do should documented here.  It's hard enough to find it
;*** elsewhere!  TVR-Apr80
;
;	This code is all BBN dependent.  It will be replaced for other pagers.
;
;------------------------------------------------------------------------------

	.ORG[BBNMAPIOTDISP-ORG]	;$*$*$ This should be fixed

	JUMP[MAPCO0] NORM $		  ;CONO 0
	DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 1 -- START MAP CLEARING
	UAOP1 $				  ;CONO 2 -- Ill. Instruction
	DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 3 -- START MAP CLR
	D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 4
	D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 5
	JUMP[MAPCO6] NORM $		  ;CONO 6
	DEST[CLR-MAP] JUMP[MAPCO7] NORM $ ;CONO 7

	.USE[AREA51]
			;$*$*$	This is truely silly.  The CTY code appears
			;	after the map dispatch and the map code
			;	after the CTY dispatch!
	.PAIR
	UIOTRP[MUUO] $
MAPIOT:	D[IR] ROT[9.] COND[-OBUS<0] JUMP[MAIN] C550 $ ;NOP IF DEV. 20
	D[CONST 14] ALU[D#Q] COND[OBUS=0] JUMP[MAPIO1] C550 $; IS IT CONO ?
	D[CONST 13] ALU[D#Q] COND[OBUS=0] JUMP[MAPDO] C550 $; NO IS IT DATAO?
	ILGIOT $   ;ELSE ILLEGAL
MAPIO1:	D[IR] MASK[3] DEST[Q] NORM $
	D[BBNMAPIOTDISP-ORG / 100] ROT[6] ALU[DORQ] SDISP C600 $
MAPCO0:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $
	D[12] DEST[Q] NORM $; GET SIGN BIT = ENBL FOR EXEC 0-77777
	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] CYLEN[IOB-OUT] DEST[CLR-MAP] D[CONST 20] LLOAD $; TURN OFF MAPPING & START CLEARING MAP
	LOOP [.] C550 $  ;WAIT FOR MAP CLR TO FINISH -- OTHERWISE THE
	  	; READS OF 71 AND 72 BELOW DON'T HAPPEN (ON F2 #1).
	D[CONST 71] DEST[MA] SHORT $; FETCH MAGIC LOC
	D[CONST 1] DEST[DEV-ADR] CYLEN[FIXM]  $; WAIT FOR DATA
	D[MEM] MASK[13] DEST[AR] SHORT $
	D[AR] ROT[11] DEST-A-MEM DEST[4] NORM $; MBR
	D[MEM] ROT[18.] MASK[13] DEST[AR] SHORT $
	D[AR] ROT[11] DEST-A-MEM DEST[1] NORM $; UBR
.REPEAT 1 - WAITS [
	D[MEM] ROT[27] MASK[5] DEST[AR] SHORT $
	D[AR] ROT[4] DEST-A-MEM DEST[3] NORM $; AC BASE REG
];.REPEAT 1 - WAITS
	D[MEM] ROT[7] MASK[3] ALU[0-D] DEST[AR] COND[OBUS=0] JUMP[MAPCOB] C600 $; ADDRS LIMIT, J IF 0
	D[AR] MASK[3] DEST[AR] SHORT $
	D[AR] ROT[16] DEST[AR] JUMP[MAPCOC] NORM $; FORM SMALLEST ILLEGAL ADDRESS
MAPCOB:	D[CONST 20] ROT[16] DEST[AR] SHORT $
MAPCOC:	D[CONST 1] ROT[43] ALU[D&Q] DEST[Q] SHORT $; GET SIGN BIT = ENBL FOR EXEC 0-77777
	D[AR] ALU[DORQ] DEST-A-MEM DEST[AR 2] NORM $; ADDRS LIMIT
.REPEAT WAITS [
	D[11] DEST[HI-ABS-MA MA] SHORT $
		;Fetch first location of user page table
	D[MEM] MASK[13] DEST[3] DEST-A-MEM LONG $
		;Wait for memory to finish, then save page table entry.
];.REPEAT WAITS
	D[CONST 72] DEST[MA] SHORT $; GET NEXT WORD
	D[MEM] DEST[Q] LONG $	;LONG to wait for data to arrive.
	D[CONST 1] ROT[32] ALU[-D&Q] DEST-A-MEM DEST[5] JUMP[MAPCOE] NORM $; AGE & PROCESS BITS
];.REPEAT 1 - KL




.REPEAT KL [
;------------------------------------------------------------------------------
;
; 	KL Pager - Map IOTS
;						-PG
;
;	This code is all KL dependent.  It will be replaced for other pagers.
;
;------------------------------------------------------------------------------
	.USE[AREA51]
			;$*$*$	This is truely silly.  The CTY code appears
			;	after the map dispatch and the map code
			;	after the CTY dispatch!
;AMEM USAGE FOR KL PAGER:
;	0	SWITCH INTERRUPT ADDRESS (MAP CODE CANT USE)
;	1	FREE
;	2	FREE
;	3,4,5	TEMP STORAGE
;	6	DATAO PAG WORD
;	7	CONO PAG WORD

	.PAIR
	UIOTRP[MUUO] $		;DEC DEV 10 (FOONLY DEV 1)
MAPIOT:	D[CONST 4] ALU[D#Q] COND[OBUS=0] JUMP[MAPCO] C550 $;CONO ?
	D[CONST 5] ALU[D#Q] COND[OBUS=0] JUMP[MAPCI] C550 $;CONI ?
	D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[MAPDO] C550 $;DATAO?
	D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[MAPDI] C550 $;DATAI?
	D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[CLRPT] C550 $;CLRPT?
	ILGIOT $   ;ELSE ILLEGAL
MAPCO:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[IR] MASK[18.] DEST-A-MEM DEST[7 AR] NORM $
	DEST[CLR-MAP] D[CONST 20] LLOAD NORM $
	LOOP[.] C550 $			;WAIT FOR MAP CLEAR TO FINISH
	D[AR] ROT[22.] COND[OBUS<0] PUSHJ[MAPUP] C550$ ;MAP ON IF ENABLED
	D[AR] ROT[22.] COND[-OBUS<0] PUSHJ[MAPDN] C550$ ;MAP OFF IF NOT
	JUMP[MAIN] $
MAPCI:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[17] DEST[HOLD] NORM $		;A-MEM 7
	ALU[0] DEST[DEV-ADR] NORM $
	STRT-WRT MEMST $
MAPDO:	FIXM1 $ ;WAIT FOR MEMORY, HANDLE PAGE FAULTS, AND FIXUP AC REFERENCES
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[MEM] DEST-A-MEM DEST[5] NORM $ ;SAVE DATAO'S (E) IN A-MEM 5
	D[15] COND[OBUS<0] PUSHJ[MAPDO1] C550 $ ;SELECT AC BLOCKS?
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[15] ROT[2] COND[OBUS<0] PUSHJ[MAPDO2] C550 $ ;LOAD USER BASE ADDRESS?
	ALU[0] DEST[DEV-ADR] JUMP[MAIN] NORM $ ;DONE
MAPDI:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[16] DEST[HOLD] NORM $		;A-MEM 6
	ALU[0] DEST[DEV-ADR] NORM $
	STRT-WRT MEMST $
CLRPT:
.REPEAT 1 - NEWMAP [
	D[CONST 1] ROT[35. - 9.] DEST[STO-MAP] JUMP[MAIN] NORM $
		;Set mapping to zero, Invalid
];.REPEAT 1 - NEWMAP
.REPEAT NEWMAP [
	START-OUT $
		;Set mapping to zero, Invalid
	MAPF[2] D[CONST 1] ROT[35. - 9.] JUMP[MAIN] C800 $
];.REPEAT NEWMAP
];.REPEAT KL





;------------------------------------------------------------------------------
;
;	MAP FAULT DISPATCHES COME HERE (6100 + MAPF*4 )
;
;	MAP traps happen on next micro instruction after a MEMSTO or STRT-WRT.
;	They also happen after micro instruction containing a DEST[FIXMAC...],
;	as in FIXM1 for example.  The trap happens by forcing an unconditional
;	jump to an address determined by MAP-DISP register and the MAPF of
;	field of the failing micro instruction.  Otherwise, that micro
;	instruction is executed normally.
;	
;	This code should be the same for all kinds of maps.  However, it will
;	be necessary to define symbolically the trap code, i.e. the thing that
;	is usually being loaded left half of Q.  After doing that, and updating
;	necessary state of PC and flags, the code leave by jumping to MFT1B,
;	the map dependent page fault/page fill code, with fault code in Q and
;	failing address in the MA.
;
; ***	As you will notice, there are NO spare trap codes.  If you need one,
; ***	talk to me about a scheme for fixing this and improving page fault
; ***	recovery.  TVR-Apr80
;
;------------------------------------------------------------------------------
	.MAPORG[0]	;Fixed by hardware to xx100
	JUMP[.] $  	;ILLEGAL MAP FAULT -- MICROCODE BUG IF YOU GET HERE
.REPEAT XUCODE [
.XMAPORG[0]		;COPY FOR HIGH MEM
	JUMP[MAPTRAP-ORG] $
];.REPEAT XUCODE
	;**** Consider looking at STOP switch in the future.	TVR - Mar80
	;
	;To find out non-destructively how you lost, start at 2003 (on an F2)
	;you will be stopped at PC+1, assuming you lose trying to display
	;that instruction in the lights (i.e. (PC) not mapped in)
	;
	;You can get here by examining/depositing a location in the
	;hardware map (i.e. it may only be asking for a page-fill cycle).
.MAPORG[1]	;EXECUTE (&INDIRECT) FAULTS HERE
MFT1:	D[CONST 2] ROT[18.] DEST[Q] NORM $; CODE FOR EXECUTE
MFT1A:	D[CONST 1] DEST[DEV-ADR] NORM $
MFT1D:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD] MASK[3] DEST[AR IR-ADR] JUMP[MFT1B] MAPF[4] CYLEN[IOB-IN] $
.MAPORG[2]	;NORMAL READ FAULT
MFRD:	D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
MFOTH:	D[PC] ALU[D-1] DEST[PC] JUMP[MFT1A] NORM $
.REPEAT XUCODE [
.XMAPORG[2]	;NORMAL READ FAULT -HIGH MEM DUPLICATE INSTR.
	D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
];.REPEAT XUCODE
.MAPORG[3]	;RMW HERE, DECREMENTS PC
MFWRT:	D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
.REPEAT XUCODE [
.XMAPORG[3]	;RMW -HIGH MEM DUPLICATE INSTR.
	D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
];.REPEAT XUCODE
.MAPORG[4]		;WRITES (NORMAL) HERE (BBN: NO DECREMENT PC)
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
.REPEAT 1 - KL [
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST-A-MEM DEST[7] NORM $;SAVE STORE DATA
	D[IR] MASK[18.] DEST[MA] NORM JUMP[MFT1D] $; RESTORE MA
];.REPEAT 1 - KL
.REPEAT KL [
	D[IR] MASK[18.] DEST[MA] NORM JUMP[MFOTH] $; RESTORE MA
];.REPEAT KL
.REPEAT XUCODE * VID [
.XMAPORG[5]	; 5-- BLT-RD IN HIGH MEM (DPY-RD)
;;;	JUMP[DPYRD] NORM $
];XUCODE * VID
.MAPORG[5]		; 5-- BLT-RD
	D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $; RESTORE PC & DEST ADR
	D[CONST 10] ROT[18.] DEST[Q] SHORT $; CODE FOR RD
MBLT3:	D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; GET SRC ADR
.REPEAT XUCODE * VID [
.XMAPORG[6]	; 6-- BLT-WRT IN HIGH MEM (DPY-WRT)
;;;	JUMP[DPYWRT] NORM $
];XUCODE * VID
.MAPORG[6]	;6-- BLT-WRT
	D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC MA] SPEC[MA_PC] NORM $; RESTORE PC, GET DEST ADR
	ALU[Q-1] DEST[AR] NORM $;  ADJUST SRC ADR
	D[CONST 4] ROT[18.] DEST[Q] JUMP[MBLT3] NORM $; CODE FOR WRT
.MAPORG[7]	;7-- BLT-RDA
	ACSEL[AC] D[AR] DEST[AC] NORM $; NEW DEST ADR
	D[CONST 10] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $; CODE FOR RD
.MAPORG[10]	; 10-- BLT-WRTA
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
	D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
	D[AR] MASK[18.] ALU[D#Q] COND[OBUS=0] JUMP[MBLT2] C550 $
	ALU[Q-1] DEST[Q MA] JUMP[MBLT2] NORM $; CORRECT MA
.MAPORG[11]	;11-- BYTE-ILD
	PUSHJ[SETFPD] NORM $; SET HALF
	JUMP[6110] NORM $; NORMAL READ
;Page fault in the middle of a interruptable instruction.  Set HALF (BIS)
;flag as part of page fault processing so that instruction gets restarts in
;the proper way.
.REPEAT 1 - KL [;IF NOT KL, SETFPD SHOULD JUST BE SETHLF
SETFPD:
];.REPEAT 1 - KL
SETHLF:	D[CONST 2] ROT[36] DEST[Q] COND[USER] JUMP[SETHFU] NORM $;BIT 4--HALF
		;Get ready to set HALF (BIS) flag.
		;Watch for special case of User page fault from Exec. TVR-May80
QORCRY:	D[PC] ALU[DORQ] DEST[CRYOV] POPJ NORM $;SET HALF
.MAPORG[12]	;12 -- BYTE-IDP
	PUSHJ[SETFPD] NORM $; SET HALF
	JUMP[6114] NORM $;NORMAL RMW
;When a DEST[CRYOV] is done, the EXEC shift register is cleared (set) to
;whatever the user bit in the new CRYOV is.  This destroys the information
;about which space a page fault came from on XCTR (XCT mapped) instruction.
;We turn it on explicitly here.  Note that since a user cannot do a XCTR,
;we only have to worry about the case of being in EXEC mode and getting a
;user mode page fault.	TVR-May80
SETHFU:	D[PC] ALU[DORQ] DEST[CRYOV] NORM $
		;Set the half flag.
		;Don't return yet, we need to reset EXEC-SR
	SET-TEMP-USER POPJ $
		;Remember that the page fault was from a user page!!
.MAPORG[13]	;13 -- BYTE-IND
	PUSHJ[SETFPD] NORM $; SET HALF
	JUMP[6104] NORM $; NORMAL INDIRECT
.MAPORG[14]	;BLT-WRTB -- XCT MAPPED BLT STORES
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
	D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
	D[CONST 4] ROT[18.] DEST[Q] NORM $
	D[AR] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; RESTORE AC


.REPEAT 1 - KL [
.MAPORG[15]	;-- MAPFTR -- TRAP WHILE FETCHING JSYS TARGET
	D[CONST 50] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; PI CODE
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST-A-MEM DEST[7] JUMP[MFOTH] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
.MAPORG[15]	;-- KLIFETCH -- NEXT INSTRUCTION FETCH IN KL PAGING

	D[PC] COND[OBUS<0] C550 JUMP[SOEDOV] $
		;IF REAL OVERFLOW BIT IS SET,
		;CAUSE A TRAP 1 TO HAPPEN, FORGET THE PAGE FAIL.
		;BECAUSE WHAT HAPPENED WAS LAST INSTRUCTION CAUSED OVERFLOW,
		;BUT INSTRUCTION FETCH FOR NEXT INST PAGE FAILED BEFORE
		;DISPATCH AT MAIN2 COULD LET SOEDOV DO THE TRAPS.
	D[12] SPEC[A-MEM-APR] MASK[36. - 3.] DEST[AR] COND[-HALF] JUMP[MFT1] $
		;IF HALF FLAG OFF, DON'T NEED TO CLEAR ANYTHING
	D[AR] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] JUMP[KLIFT1] NORM $
		;STORE BITS BACK (JRSTT, TI1 AND TI2 CLEARED NOW)
	.USE[NORMAL]
KLIFT1:	D[AR] ROT[3] COND[OBUS<0] C550 JUMP[MFT1] $
		;IF FPD ON IN AMEM, LEAVE HALF FLAG SET.
	SPEC[CLR-HALF] JUMP[MFT1] SHORT $
		;ITS NOT, HALF WAS ONLY ON FOR OTHER FLAGS, CLEAR IT AND DO
		; WHAT IS NORMALLY DONE FOR INSTRUCTION FETCH FAULT OR INDIRECT.

];.REPEAT KL
.REPEAT 1 - KL [
.MAPORG[16]	;PPOP-- 16 -- POP & POPJ FETCH- RE-INCR PDL PNTR -- THEN LIKE READ FAULT
	D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC] JUMP[MFRD] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
.MAPORG[16]		;PPOP-- 16 -- ALL STACK OPERATIONS
	D[IR] ROT[9 - 2] COND[OBUS<0] JUMP[MFPP1] C550 $
	D[CONST 1,,1] ALU[AC-D] DEST[AC] JUMP[MFWRT] NORM $	;PUSH, PUSHJ WRT
MFPP1:	D[IR] ROT[9 - 1] COND[OBUS<0] JUMP[MFPP2] C550 $
	D[IR] MASK[18.] DEST[Q] JUMP[MFPP3] NORM $
];.REPEAT KL
.MAPORG[17]	;17-- WRITES WITH RELEVANT ADRS IN MA (BBN: NO DECR PC)
.REPEAT 1 - KL [
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] JUMP[MFNPC1] NORM $
	.USE[OTHER]
MFNPC1:	D[CONST 1] DEST[DEV-ADR] SHORT $
	D[MEM] DEST-A-MEM DEST[7] JUMP[MFT1D] NORM $;SAVE STORE DATA
];.REPEAT 1 - KL
.REPEAT KL [
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] JUMP[MFOTH] NORM $
	.USE[AREA53]
];.REPEAT KL
MFPP3:	D[MA] ALU[D#Q] COND[-OBUS=0] JUMP[MFPP2] C550 $
	D[CONST 1,,1] ALU[AC+D] DEST[AC] JUMP[MFWRT] NORM $	;POP WRT
MFPP2:	D[CONST 1,,1] ALU[AC+D] DEST[AC] JUMP[MFRD] NORM $	;POP, POPJ RD
BWRTA1:
.REPEAT 1 - KL [
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[MEM] DEST-A-MEM DEST[7] POPJ NORM $
];.REPEAT 1 - KL
.REPEAT KL [
	D[CONST 1,,1] ACSEL[AC] ALU[AC-D] DEST[AC] POPJ NORM $
];.REPEAT KL
MBLT2:	D[AR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $; COUNT HOW MANY WORDS MOVED
	D[AR] ROT[18.] ALU[Q+D] DEST[AR] SHORT $;FORM NEW SRC
	ACSEL[AC] D[MA] MASK[18.] DEST[AC] SHORT $;NEW DEST
	D[CONST 4] ROT[18.] DEST[Q] NORM $
	D[AR] ACSEL[AC] ROT[18.] SPEC[LEFT] ALU[DORAC] DEST[AC] JUMP[MFOTH] NORM $; OR IN NEW SRC



.REPEAT 1 - KL [
	.USE[AREA53]

MAPCWT:	ALU[Q] LLOAD NORM $
	LOOP[.] CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
	MAPF[10] D[AR] COND[OBUS<0] JUMP[MAPCW9] CYLEN[MAX,IOB-OUT,C550] $; J IF WHOLE MAP ON (INCLUDING EXEC 0-77777)- DONE
MAPCW1:	D[CONST 77]  MAPF[10] LLOAD NORM $
MAPCW2:	D[PC]  DEST[AR] SHORT $;SAVE FLAGS
	ALU[0] DEST[MA CRYOV] SHORT $;INIT MA, SET EXEC
	D[CONST 10] ROT[6]  DEST[Q] SHORT $

 .REPEAT NEWMAP [
	D[CONST 1] DEST[DEV-ADR] NORM $	; -- FOR WRITING MAP
	SPEC[IOB-OUT] SHORT $ 	;SET FIRST PART OF 
	  	; EXEC MAP TO POINT TO "NULL MAP" LOCS(UNMAPPED)
 	MAPF[2] D[MA] MASK[18.] C800 $	;MAP DATA COMES FROM OBUS.
	D[MA] ALU[D+Q] DEST[MA] LOOP[. - 2] NORM $;LOOP
   ]	; NEWMAP

 .REPEAT 1 - NEWMAP [
	D[MA] MASK[18.] DEST[STO-MAP] NORM $
	;SET FIRST PART OF EXEC MAP TO POINT TO "NULL MAP" LOCS(UNMAPPED)
	D[MA] ALU[D+Q] DEST[MA] LOOP[. - 1] NORM $;LOOP
  ]	; 1 - NEWMAP

	D[IR] MASK[3]  DEST[IOD] SPEC[IOB-OUT] SHORT $; RESTORE MAP
	D[AR]  DEST[CRYOV] JUMP[MAIN] MAPF[10] CYLEN[IOB-OUT] $; RESTORE FLAGS, DONE
];.REPEAT 1 - KL
;------------------------------------------------------------------------------
;	End map trap code which is common to all maps.
;------------------------------------------------------------------------------




;MAPCOA MAPCOE MAPCO1 MAPCOG MAPCO4 MPOFF1 MAPOFF MAPCO6 MAPCO7 MAPCW9 MAPDO MFUS MFA3 MFA7 MFA6 MFA4 MFT1B MFHIEX MFA1 MFA2 MFB3 MFTYP1 MFTYP0
.REPEAT 1 - KL [
;------------------------------------------------------------------------------
;	BBN MAP CONO, continued
;
;	This code will need to be rewritten for another kind of map.
;
;------------------------------------------------------------------------------
MAPCOA:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD]  MASK[3] DEST[IR-ADR] MAPF[4] POPJ CYLEN[IOB-IN] $;GET MAP, ECC & OV ENBL BITS
MAPCOE:	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE MAP STATE
	MAPF[10] D[CONST 1] DEST[Q] JUMP[MAPCWT] CYLEN[IOB-OUT] $
MAPCO1:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET ENABLE BITS IN IR
	D[12] DEST[AR] NORM $; GET SIGN BIT = ENBL EXEC 0-77777
	ALU[0] DEST[DEV-ADR] SHORT $
	D[CONST 5] DEST[Q] JUMP[MAPCWT] NORM $
MAPCOG:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[12] MASK[43] DEST[Q] NORM $
	D[IR] MASK[1] DEST[AR] SHORT $;GET LOW BIT OF CONO
	D[AR] ROT[43] ALU[DORQ] DEST-A-MEM DEST[2] NORM $;GET SIGN BIT = EXEC 0-77777 MAP ENBL
	SPEC[IOB-IN] SHORT $
	MAPF[4] D[IOD] MASK[3] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[CONST 4] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $
	D[CONST 4] ALU[DORQ] DEST[IR-ADR] MAPF[10] POPJ CYLEN[IOB-OUT] $;TURN ON MAP
MAPCO4:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
	MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $; DONE
];.REPEAT 1 - KL

MAPOFF:	D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM POPJ $
.REPEAT 1 - KL [

MAPCO6:	DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] NORM $
	JUMP[MAPCW1] NORM $
MAPCO7:	DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] CYLEN[LONG] $
	CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
	CYLEN[LONG] $
MAPCW9:	ALU[0] LLOAD NORM $; SET UP ONLY PAGE 0
	JUMP[MAPCW2] NORM $

;------------------------------------------------------------------------------
;DATAO CLEARS THE "ASSOCIATIVE" REGISTER MAPPING THE ADDRESS OF THE DATAO
; THIS REPLACES CONO 2.
;------------------------------------------------------------------------------
MAPDO:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET MAP BITS
 .REPEAT 1 - NEWMAP [ ALU[0] DEST[DEV-ADR] NORM $ ]
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
	MAPF[10] CYLEN[IOB-OUT] $
 .REPEAT NEWMAP [
	SPEC[IOB-OUT] SHORT $  ;REQUEST MAP WRITE CYCLE.
	MAPF[2] D[CONST 1] ROT[32] C800 $ ]

 .REPEAT 1 - NEWMAP [
	D[CONST 1] ROT[32] DEST[STO-MAP] NORM $ ]
	  ;CLR MAP ENTRY ASSOCIATED WITH MA
	D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] C800 $; RESTORE ENABLES
	MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $
];.REPEAT 1 - KL





.REPEAT KL [
;------------------------------------------------------------------------------
;	KL PAGER - CONT
;	AC BLOCK SWITCHING, USER BASE REGISTER, AND MAP INSTRUCTION
;							-PG
;------------------------------------------------------------------------------
MAPDO3:	D[17] ROT[9.] MASK[9. + 13.] DEST[Q] PUSHJ[MAPOF] $ ;EXEC BASE ADDRESS
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[CONST 37] ALU[DORQ] DEST[MA HI-ABS-MA] NORM $	;+37=AC BLOCK PTR
	D[16] ROT[9.] MASK[3] DEST[AR] NORM $		;GET "CURRENT AC BLOCK"
	D[AR] ROT[4] DEST[Q] PUSHJ[MAPON] $		;*16.
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[MEM] MASK[18.] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $ ;+AC BLOCK PTR->MA
	D[CONST 20] DEST[AR] $				;LOOP COUNT
	ALU[0] DEST[AC-SEL] POPJ NORM $			;START AT AC 0
MAPDO1:	PUSHJ[MAPDO3] $ ;SET UP MA AND AC FOR BLT'ING AC BLOCKS
MAPDO4:	ACSEL[REG] ALU[AC] DEST[MEMSTO] NORM $	;AC->@OLD "CURRENT AC BLOCK"
	MAPF[NORM-WRT] D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] NORM $ ;INC MA AND AC-CTR
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[MAPDO4] C600$ ;LOOP
	D[15] SPEC[LEFT] DEST[Q] NORM $ 		;GET CURRENT AC BLOCK
	D[16] MASK[18.] ALU[DORQ] DEST[Q] NORM $	;MASK AND REPLACE
	ALU[Q] DEST-A-MEM DEST[6] PUSHJ[MAPDO3] NORM $	;SET UP MA AND AC
MAPDO5:	D[MEM] ACSEL[REG] DEST[AC] NORM $	;@NEW "CURRENT AC BLOCK"->AC
	D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] NORM $	;INC MA AND AC-CTR
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[MAPDO5] C600$ ;LOOP
	POPJ NORM $
MAPDO2:	D[15] MASK[18.] DEST[Q] NORM $ ;LOAD USER BASE REGISTER
	D[16] SPEC[LEFT] ALU[DORQ] DEST[Q] NORM $
	ALU[Q] DEST-A-MEM DEST[6] NORM $
	DEST[CLR-MAP] D[CONST 20] LLOAD NORM $
	LOOP[.] C550 $			;WAIT FOR MAP TO CLEAR
	POPJ NORM $
MAP:	COND[MA-AC] JUMP[MAP2] $
	D[CONST 1] DEST[DEV-ADR] $
	SPEC[IOB-IN] NORM $
	MAPF[4] D[IOD] ROT[33.] COND[OBUS<0] JUMP[MAP1] C600 $
	ALU[0] DEST[DEV-ADR] $
MAP2:	D[MA] MASK[18.] DEST[AC] JUMP[MAIN] $		;MAP OFF
MAP1:	PUSHJ[MFPHYS] $					;PHYSICAL PAGE & BITS
	ALU[Q] DEST[AC] JUMP[MAIN] $			;DONE
;------------------------------------------------------------------------------
;	KL MAP - Handle map trap and page fill cycles.
;	This code will need to be rewritten for another kind of map. -PG
;------------------------------------------------------------------------------
MFPHYS:	D[MA] DEST[AR] PUSHJ[MAPOF] NORM $	;SAVE MA IN AR
	D[CONST 1] DEST[DEV-ADR] $
	D[AR] ROT[36. - 10.] MASK[8] DEST[Q] $	;PAGE/2
	COND[-USER] JUMP[MFPHEX] NORM $
	D[16] MASK[13.] DEST[MA] NORM $
		;GET EPT PAGE NUMBER
	D[MA] ROT[9.] ALU[DORQ] DEST[HI-ABS-MA MA] JUMP[MFPH1] NORM $
		;EPT ADDRESS + OFFSET
MFPHEX:	D[CONST 1] ROT[7] ALU[Q-D] COND[-OBUS<0] JUMP[MFPHE1] C600 $
	D[CONST 34] ROT[2] ALU[Q-D] COND[OBUS<0] JUMP[MFPHE2] C600 $
	SET-TEMP-USER $				;EXEC 340-377 (@ USER 400)
	D[CONST 34] ROT[2] ALU[Q-D] DEST[Q] $
	D[CONST 4] ROT[6] ALU[Q+D] DEST[Q] $
	D[16] MASK[13.] DEST[MA] NORM $
		;GET EPT PAGE NUMBER
	D[MA] ROT[9.] ALU[DORQ] DEST[HI-ABS-MA MA] NORM $
		;EPT ADDRESS + OFFSET
	SET-TEMP-EXEC JUMP[MFPH1] $		;DONE EXEC 340-377
MFPHE2:	D[CONST 6] ROT[6] ALU[Q+D] DEST[Q] $	;EXEC 000-337 (@ EXEC 600)
MFPHE1:	D[17] ROT[9] MASK[9 + 13.] ALU[DORQ] DEST[MA HI-ABS-MA] $
MFPH1:	D[AR] ROT[36. - 9] MASK[1] COND[-OBUS=0] JUMP[. + 2] C600 $
	D[MEM] ROT[18.] MASK[18.] DEST[HOLD] JUMP[. + 2] $	;EVEN
	D[MEM] MASK[18.] DEST[HOLD] $				;ODD
	D[MEM] ROT[9] DEST[Q] $
	D[AR] MASK[9] ALU[DORQ] DEST[HOLD] NORM $	;PHYS ADDR (BITS ROT 9)
	D[MEM] MASK[22.] DEST[Q] NORM $			;START FILLING Q
	D[MEM] ROT[9] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 2] ALU[DORQ] DEST[Q] $	;A
	D[MEM] ROT[1] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 6] ALU[DORQ] DEST[Q] $	;P
	D[MEM] ROT[1] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 3] ALU[DORQ] DEST[Q] $	;W
	D[MEM] ROT[1] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 4] ALU[DORQ] DEST[Q] $	;S
	D[MEM] ROT[1] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[Q] $	;C
	COND[-USER] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 0] ALU[DORQ] DEST[Q] $	;U
	D[CONST 1] ROT[35. - 8] ALU[DORQ] DEST[Q] $	;V ALWAYS
	ALU[0] DEST[HI-ABS-MA] PUSHJ[MAPON] $		;RESTORE STATE
	D[AR] DEST[MA] POPJ $				;RESTORE MA, RETURN




;------------------------------------------------------------------------------
; Enter here with fault code in Q and address in MA to handle page fault or
; page fill cycle.  MAP-EXEC-SR (i.e. USER condition) is still undisturbed.
;------------------------------------------------------------------------------
MFT1B:	D[CONST 1] DEST[DEV-ADR] $
	ALU[Q] DEST-A-MEM DEST[5] PUSHJ[MFPHYS] $	;GET PHYS ADDR IN Q
	D[CONST 1] DEST[DEV-ADR] NORM $
	SPEC[IOB-IN] NORM $
	MAPF[4] D[IOD] ROT[9] COND[OBUS<0] JUMP[MFI] CYLEN[IOB-IN] $ ;INVALID?
	ALU[Q] DEST[HOLD] $				;MAP FILL
	D[MEM] ROT[2] COND[OBUS<0] JUMP[. + 2] C600 $
	D[CONST 7] ROT[35. - 12.] ALU[DORQ] DEST[Q HOLD] $	;READ & XCT PREVENT
	D[MEM] ROT[3] COND[OBUS<0] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 12.] ALU[DORQ] DEST[HOLD] $;WRITE PREVENT
.REPEAT 1 - NEWMAP [
	D[MEM] MASK[36. - 9] DEST[STO-MAP] NORM $
];.REPEAT 1 - NEWMAP
.REPEAT NEWMAP [
	START-OUT  NORM $
	MAPF[2] D[MEM] MASK[36. - 9] C800 $
];.REPEAT NEWMAP
	ALU[0] DEST[DEV-ADR] COND[-HALF] JUMP[MAIN] C800 $	;DONE
		;IF HALF FLAG NOT ON
	D[12] ROT[2] MASK[2] SPEC[A-MEM-APR] DEST[AR] COND[OBUS=0] C550 JUMP[MAIN] $
		;IF ANY TRAP FLAGS ON IN PC, MUST REEXECUTE THE TRAP INSTRUCTION, NOT THE INSTRUCTION THAT CAUSED THE TRAP
		; AR WILL HAVE THE TRAP CODE
	D[PC] ALU[D+1] DEST[PC] JUMP[DOTRPX] NORM $
		;TRAP IS IN PROGRESS, MUST INCREMENT PC, AS WE DECREMENTED
		; IT ON THE WAY HERE ASSUMING INSTRUCTION AT PC+1
		; CAUSED FAULT. MUST INCREMENT PC HERE, BECAUSE DOTRPX
		; DECREMENTS PC, AND IF TRAP INSTRUCTION PAGE FAULTS,
		; WILL GET DECREMENTED AGAIN, AND PC WILL POINT TO THE COMPLETED INSTRUCTION THAT CAUSED THE TRAP
MFI:	D[15] ROT[15.] COND[-OBUS<0] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 5] ALU[DORQ] DEST[Q] SHORT $	;T
	ALU[Q] DEST[HOLD] NORM $
	D[MEM] ROT[9] MASK[9] DEST[HOLD] NORM $
	D[MEM] ROT[36. - 9] DEST[Q] NORM $
	D[AR] ALU[DORQ] DEST[AR] NORM $			;OR IN VIRTUAL ADDR
	D[CONST 5] ROT[6] DEST[Q] PUSHJ[MAPOF] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[16] MASK[13.] DEST[MA] NORM $
		;GET 13 BIT UPT PAGE NUMBER IN MA
	D[MA] ROT[9.] ALU[DORQ] DEST[HI-ABS-MA MA] NORM $
		;TURN INTO PHYS ADDRESS, PUT OFFSET INTO IT FROM Q
	D[AR] DEST[MEMSTO] NORM $				;PAGE FAIL WORD
	D[MA] ALU[D+1] DEST[MA] NORM $
	D[PC] DEST[AR] COND[HALF] PUSHJ[TPCFIX] NORM $
		;GET PC INTO AR, CALL TPCFIX TO SET PROPER PC IF HALF IS ON
	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] C550 JUMP[MFI1] $
		;JUMP IF FAKE PC BIT IN AMEM IS NOT SET
	D[CONST 1] ROT[35. - 0] DEST[Q] SHORT $
		;OVERFLOW SHOULD BE SEEN AS ON BY USER, SET IT IN STORED OLD PC
	D[AR] ALU[DORQ] DEST[MEMSTO] JUMP[MFI2] NORM $
MFI1:	D[AR] DEST[MEMSTO] NORM $				;OLD FLAGS & AR
MFI2:	D[MA] ALU[D+1] DEST[MA] NORM $
	NOP $						;WAIT FOR MEMORY
	D[MEM] DEST[CRYOV] NORM $				;NEW FLAGS
	D[MEM] DEST[PC] PUSHJ[MAPON] NORM $			;NEW PC
	ALU[0] DEST[HI-ABS-MA] JUMP[MAIN] NORM $		;DONE
];.REPEAT KL




.REPEAT 1 - KL [
;------------------------------------------------------------------------------
;
;	BBN MAP - Handle map trap and page fill cycles.
;
;	This code will need to be rewritten for another kind of map.
;
;------------------------------------------------------------------------------
MFUS:	D[12] MASK[40] DEST[Q] NORM $;GET LIMIT REG
	D[MA] ALU[D-Q] COND[-OBUS<0] JUMP[MTRPAL] C600 $;J IF MA PAST ADDRS LIMIT
	D[11] DEST[Q] JUMP[MFA1] NORM $;GET USER BASE REG.

MFA3:	D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFA4] C550 $ ;J IF MODIF. BIT ON
MFA7:	D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[CONST 1] ROT[27] ALU[DORQ] DEST[AR] SHORT $; TURN ON WRT-PREVENT, SAVE NEW MAP WORD
MFA6:	D[MEM] MASK[33] DEST[Q] JUMP[MFA5] NORM $; GET CST ENTRY, GO DO
MFA4:	D[IR] ROT[26] MASK[1] COND[OBUS=0] JUMP[MFA7] C550 $; J IF NO WRT-PERMIT
	D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] JUMP[MFA6] NORM $; CLEAR WRT-PREVENT
;------------------------------------------------------------------------------
; Enter here with fault code in Q and address in MA to handle page fault or
; page fill cycle.  MAP-EXEC-SR (i.e. USER condition) is still undisturbed.
;------------------------------------------------------------------------------
MFT1B:	D[MA] MASK[18.] ALU[DORQ] DEST[AR] COND[USER] JUMP[MFUS] NORM $;GET FAILED ADDRS, J IF USER
	D[MA] ROT[24] MASK[2] DEST[Q] NORM $; HIGH ORDER 2 BITS
	D[CONST 3] ALU[D-Q] COND[OBUS=0] JUMP[MFHIEX] C600 $; J IF PRIVATELY MAPPED PART
	D[CONST 30] ROT[6] DEST[Q] JUMP[MFA1] NORM $; PAGE TAB @ 3000
MFHIEX:	D[14] DEST[Q] NORM $
MFA1:	ALU[0] DEST[DEV-ADR] NORM $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $ ;CLEAR MAPPING
	D[IR] MASK[3] DEST-A-MEM DEST[APRENB] MAPF[10] CYLEN[IOB-OUT] $
		;SAVE AR, ECC INT
	D[MA] ROT[33] MASK[11] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE ENTRY
	D[CONST 16] ROT[14] DEST[IR-ADR] NORM $; PREPARE INITIAL PERMIT BITS
	D[CONST 1] DEST[DEV-ADR] NORM $
MFA2:	D[CONST 3] DEST[Q] CYLEN[FIXM] $; DON'T CLEAR IND PNTR. COUNT, WAIT FOR FETCH
	D[MEM] ROT[18.] ALU[DORQ] DEST[Q] CYLEN[FIXM+1] $;GET PERMIT BITS
	D[IR] ALU[D&Q] DEST[IR-ADR] SHORT $; AND THEM IN
	D[MEM] ROT[13] MASK[3] COND[-OBUS=0] JUMP[MFTR1] C550 $; CHECK FOR TRAP BITS
MFB3:	D[MEM] ROT[15] MASK[1] COND[OBUS=0] JUMP[MFTR2] C550 $; J IF NO ACCESS PERMIT
	D[MEM] ROT[2] MASK[2] DEST[Q] COND[OBUS=0] JUMP[MFTYP0] C550 $; GET TYPE CODE, J IF 0
	ALU[Q-1] DEST[Q] COND[OBUS=0] JUMP[MFTYP1] C550 $; J IF 1
	ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[MFTR3] C550 $; J IF NOT 2
	D[IR] ROT[43] MASK[1] COND[-OBUS=0] JUMP[MFTR41] C550 $; TYPE 2, J IF >2 INDR. PNTRS
	D[IR] ALU[D+1] DEST[IR-ADR] SHORT $; COUNT IND. PNTRS
	D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET PAGE TABLE #
	D[MEM] DEST-A-MEM DEST[6] NORM $; SAVE PNTR
	D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE PNTR
	D[16] MASK[11] DEST[Q] CYLEN[FIXM] $; GET PAGE #, WAIT FOR MEM
	D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR4] C550 $; PAGE OUT-OF-CORE?
	D[MEM] MASK[13] DEST[HOLD] NORM $
	D[MEM] ROT[11] ALU[DORQ] DEST[MA HI-ABS-MA] JUMP[MFA2] NORM $; LOOP
MFTYP1:	D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET SHARED PAGE #
	D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH SHARED PNTR
MFTYP0:	D[CONST 12] ROT[14] DEST[Q] CYLEN[FIXM] $; GET R-X MASK
	D[IR] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C600 $; J IF NEITHER R NOR X
	D[IR] ALU[DORQ] DEST[IR-ADR] NORM $; TURN ON R AND X
	D[IR] ROT[27] MASK[3] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX ENBL BITS, INVERTED
	D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR5] CYLEN [C550] $; J IF OUT-OF-CORE
	D[AR] ROT[21] MASK[3] ALU[D&Q] DEST[Q] COND[-OBUS=0] JUMP[MFTR6] C550 $; J IF ILLEGAL ACCESS TYPE (RWX)




;MFA5 JSMFR MFTR1 MFTR10 MFB5 MFB4 MFC1 MFTR2 MTRPAL MFTR3 MFTR4 MFTR5 MFTR6 MFTR7 MFTR9 MFTR41 MAPRST MAPRSS MAPRSL
	D[MEM] MASK[13] DEST[Q] SHORT $; GET ABS PAGE #
	D[CONST 40] ROT[6] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; GET CORE STATUS ENTRY
	D[IR] ROT[12] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX DISABLES
	D[CONST 24] ROT[25] ALU[D&Q] DEST[Q] SHORT $; GET ONLY R & X
	D[CONST 4] ROT[25] ALU[D+Q] DEST[Q] SHORT $; MOVE X BIT LEFT 1
	D[MA] ROT[11] MASK[24] ALU[DORQ] DEST[Q] SHORT $; OR IN PAGE ADDRS
	D[MEM] ROT[3] MASK[3] COND[OBUS=0] JUMP[MFTR7] C550 $; J IF CST AGE SAYS TRAP
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFA3] C550 $;J IF NO WRT RQ
	D[AR] DEST[IR-ADR] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] SHORT $; TURN OFF WRT PREVENT, SAVE NEW MAP WORD
	D[CONST 1] ROT[32] DEST[Q] SHORT $; GET MODIFICATION BIT
	D[MEM] MASK[32] ALU[DORQ] DEST[Q] SHORT $; OR INTO CST WORD
MFA5:	D[15] ALU[DORQ] DEST[HOLD] NORM $;OR IN AGE, ETC
	D[MA] DEST[Q] SHORT $; SAVE CST ADDRS

	D[IR] MASK[18.] DEST[MA HI-ABS-MA] NORM $; GET ORIGINAL MA

 .REPEAT NEWMAP [
	D[CONST 1] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	MAPF[2] D[AR] C800$; LOAD MAP
  NOP $ ;%%%%%%% FOR DEBUGGING $$$$$$$$
  ] ; NEWMAP

 .REPEAT 1 - NEWMAP [
	ALU[0] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] CYLEN[IOB-OUT] $
	D[AR] DEST[STO-MAP] NORM $; LOAD MAP
  ] ; 1-NEWMAP

	ALU[0] DEST[IOD] SPEC[IOB-OUT] C800 $ ;MAP OFF
	MAPF[10] CYLEN[IOB-OUT] COND[-USER] JUMP[. + 2] $

	D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
	ALU[Q] DEST[MA STRT-WRT] NORM $; STORE CST

.REPEAT 1 - WAITS [;Damnit. TENEX isn't the only operating system for a PDP-10!
   ;Now add 1 to abs. loc. 30 of main mem (for statistics keeping)
	D[CONST 30] DEST[MA] NORM $
	NORM $
	D[MEM] ALU[D+1] DEST[MEMSTO] NORM $
];.REPEAT 1 - WAITS

	D[CONST 1] DEST[DEV-ADR] NORM $
	D[16] DEST[AR] NORM $
	ALU[0] DEST[DEV-ADR] NORM $
	D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN MAP BACK ON, ETC.
	MAPF[10] CYLEN[MAX,IOB-OUT,C550]
			D[AR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JSMFR] $
		; DO SPECIAL JSYS STUFF IF APPROPRIATE
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MAIN]  C550 $; DONE IF NO WRT
	D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MAIN] C550 $; DONE IF READ
	D[AR] MASK[18.] DEST[MA] SHORT $;GET ORRIG. MA
	D[CONST 1] DEST[DEV-ADR] SHORT $
	D[17] DEST[MEMSTO] JUMP[MSMAIN1] NORM $; STORE THE STORE DATA, & PROCEDE
JSMFR:	D[AR] MASK[18.] DEST[MA] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[17] DEST[AR] JUMP[MUJSM1] NORM $; RESTORE STORE DATA

MFTR1:	D[MEM] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MFTR9] C550 $; J IF TRAP TO USER
	D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFTR10] C550 $;J IF WRT TRAP
	D[MEM] JUMP[MFTR2] NORM $; TREAT BOTH "TRAP-TO-MON" CODES AS IMMEDIATE
MFTR10:	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFB3] C550 $; WRT RQ? J IF NO
	D[CONST 44] ROT[36] DEST[Q] SHORT $; GET ERROR CODE BITS -- WRT TRAP
MFB5:
MFB4:	D[AR] ALU[DORQ] DEST[AR Q] COND[USER] JUMP[. + 2] NORM $; OR ERROR BITS IN, J IF USER MODE
	D[CONST 1] ROT[18.] ALU[DORQ] DEST[AR] NORM $; TURN ON EXEC BIT
	D[CONST 5] ROT[6] DEST[Q] SHORT $
	D[CONST 71] ALU[DORQ] DEST[Q] SHORT $; FORM 571
	D[14] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; ADD PSB (MON BASE TAB)
	D[AR] DEST[MEMSTO] CYLEN[FIXM] $; STORE ERROR BITS THERE
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFC1] C550 $; J IF NO WRT RQ
	D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MFC1] C550 $; J IF RD RQ
	D[MA] ALU[D+1] DEST[MA] SHORT $; GO TO 572
	D[17] DEST[MEMSTO] NORM $; SAVE STORE DATA
MFC1:	ALU[0] DEST[DEV-ADR] CYLEN[MEMSTO] $
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN OFF MAP
	MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $
	D[CONST 70] DEST[MA] SHORT $; FETCH TRAP INSTR
	ALU[0] DEST[DEV-ADR] CYLEN[FIXM] $
	D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] SHORT $; TURN ON MAP
	D[PC] DEST[Q AR] MAPF[10] CYLEN[IOB-OUT] $
	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $;CLR USER
	D[CONST 55] ROT[2] DEST[Q] JUMP[MUUO44] NORM $
MFTR2:	D[CONST 41] ROT[36] DEST[Q] JUMP[MFB5] NORM $; ASCCESS PERMISSION TRAP
MTRPAL:
MFTR3:	D[CONST 40] ROT[36] DEST[Q] SHORT $
	D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB5] NORM $; ILLEGAL PT ENTRY TYPE, ADDRESS LIMIT
MFTR4:	;ALL THESE ARE NOT-IN-CORE
MFTR5:	D[CONST 22] ROT[36] DEST[Q] JUMP[MFB5] NORM $; NOT-IN-CORE
MFTR6:	D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[. + 3] C550 $; J IF NO R OR X ERROR
	D[CONST 4] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN "R OR X ERROR" BIT
	D[CONST 2] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C550 $; J IF NO W ERROR
	D[CONST 2] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN W ERROR BIT
	D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
	D[CONST 40] ROT[36] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; GROUP 2
MFTR7:	D[CONST 10] ROT[36] DEST[Q] JUMP[MFB4] NORM $; AGE ERR -- GROUP 0
MFTR9:	D[CONST 42] ROT[36] DEST[Q] JUMP[MFB4] NORM $; USER TRAP
MFTR41:	D[CONST 20] ROT[36] DEST[Q] NORM $; GROUP 1
	D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; TOO MANY INDR. PNTRS
];.REPEAT 1 - KL




;------------------------------------------------------------------------------
;Reset map.  Clear entire map to zero.  This is because even though the map
;will stop stores from happening, fetches still happen irregardless of state
;of map and if map points at non-existent memory (on for example, an immediate
;mode instruction), the machine will get a spurious ECC interrupt.
;
;It is assumed that the device address is set to 1 when this thing is called.
;ALSO FOR KL MAP -PG
;------------------------------------------------------------------------------
MAPRST:	SET-TEMP-EXEC $
		;Begin at the beginning of EXEC space.
	D[CONST 1] ROT[9.] DEST[Q] SHORT $
		;Increment for MA
MAPRSS:	D[CONST 1] ROT[18.] ALU[D-Q] DEST[MA] NORM $
		;Start at the top and work down.
MAPRSL:
.REPEAT 1 - NEWMAP [
	D[CONST 1] ROT[35. - 9.] DEST[STO-MAP] NORM $
		;Set mapping to zero, Invalid
	D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 1] C550 $
		;Repeat for each page in this space.
];.REPEAT 1 - NEWMAP
.REPEAT NEWMAP [
	START-OUT SHORT $
	MAPF[2] D[CONST 1] ROT[35. - 9.] C800 $
		;Set mapping to zero, Invalid
	START-OUT D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 1] C800 $
		;Repeat for each page in this space
];.REPEAT NEWMAP
	SET-TEMP-USER COND[-USER] JUMP[MAPRSS] $
		;Repeat once more if currently doing EXEC space. This
		;time for USER space.  We can do this because EXEC-SR is
		;latched at the end of the cycle.
.REPEAT 1 - KL [
	ALU[0] DEST[DEV-ADR] NORM $
	D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[14] CYLEN[IOB-OUT] D[CONST [MAPTRAP-ORG / 2000]] DEST[MAP-DISP] $
	DEST[CLR-MI-ERR] POPJ $	;Done

];.REPEAT 1 - KL
.REPEAT KL [
	D[CONST [MAPTRAP-ORG / 2000]] DEST[MAP-DISP] NORM $
		;PAGE MICRO TRAPS HAPPEN AT 6000+OFFSET.
	ALU[0] DEST-A-MEM DEST[6] NORM $
	ALU[0] DEST-A-MEM DEST[7] NORM $
	ALU[0] DEST[DEV-ADR] POPJ NORM $	;DONE
];.REPEAT KL

;------------------------------------------------------------------------------
;MAP ON AND MAP OFF FOR THE KL PAGER. (THIS IS NOT THE SAME MAPOFF AS FOR BBN)
;NOTE THESE USE THE RIGHT HALF OF IR. -PG
;------------------------------------------------------------------------------
.REPEAT KL [
MAPON:	ALU[0] DEST[DEV-ADR]  $
	D[IR] DEST[IOD] SPEC[IOB-OUT]  $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
MAPOF:	D[CONST 1] DEST[DEV-ADR] $
	SPEC[IOB-IN] NORM $
	D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR]  $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
MAPUP:	D[CONST 1] DEST[DEV-ADR] $
	SPEC[IOB-IN] NORM $
	D[IOD] MASK[1] DEST[Q] MAPF[4] CYLEN[IOB-IN] $
	D[CONST 6] ALU[DORQ] DEST[IR-ADR] $
	  ;TURN ON MAP AND ARITH OVERFLOW (ON AND OFF TOGETHER ON KL PAGER)
	ALU[0] DEST[DEV-ADR]  $
	D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
MAPDN:	D[CONST 1] DEST[DEV-ADR] $
	SPEC[IOB-IN] NORM $
	D[IOD] MASK[1] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
	  ;TURN OFF BOTH PAGING AND ARITH TRAPS.
	ALU[0] DEST[DEV-ADR]  $
	D[IR] MASK[1] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
];.REPEAT KL




;JSYS1 JSYS2 UMOVX XCT1 XCTUMV XCT5 XCT4 XCT6 XCT3 XCT13 XCT18 XCT12 XCT11 XDISP XCT2 XCTAC XCTSTK
; XCTS1 XCTS2 XCT10 XCTBLG XCTBYT XBY1 XBY4 XBY15 XBY14 XBY13 XBY3
;------------------------------------------------------------------------------
;
;	BBN added instructions.  Sometimes used by other than TENEX
;
;	LEAVE FOR KL PAGER. -PG
;------------------------------------------------------------------------------
.REPEAT 1 - KL [
JSYS1:	FIXM1 $
	D[PC] DEST[AR] NORM $	;SAVE PC & FLAGS
	D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
	D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $
	D[AR] DEST[MEMSTO] MEMSTMA $
JSYS2:	C550 D[CONST 1] ROT[36] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] $; J IF EXEC MODE
	ALU[0] DEST[MAP-EXEC-SR]  NORM $; TEMP TURN OFF USER
	D[CONST 10] ROT[6] DEST[Q] SHORT $
	D[MA] ALU[DORQ] DEST[MA] SHORT $; FETCH POINTER WORD
	FIXM1  $
	D[MEM] MASK[18.] DEST[PC] NORM $; J TO RIGHT HALF
	D[PC] DEST[Q] SHORT $
	D[AR] ROT[5] C550 COND[OBUS<0] JUMP[. + 2] $
		;If we came from exec mode, then we...
	D[CONST 1] ROT[34] ALU[DORQ] DEST[Q] SHORT $
		; ...TURN ON FLAG BIT 7
	D[CONST 1] ROT[36] ALU[-D&Q] DEST[CRYOV] SHORT $; TURN OFF USER
	D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; LEFT HALF
	D[AR] DEST[MEMSTO] MEMSTMA $; STORE PC
];.REPEAT 1 - KL

.REPEAT 1 - KL [
  .DEFINE JCFM [JAD]
[	D[PC] ROT[10] MASK[1] COND[-OBUS=0] JUMP[JAD] C550 $;J IF CALL FM MON]
  .DEFINE JCNFM [JAD]
[	D[PC] ROT[10] MASK[1] COND[OBUS=0] JUMP[JAD] C550 $;J IF CALL NOT FM MON]
];.REPEAT 1 - KL

.REPEAT KL [
  .DEFINE JCFM [JAD]
[	D[PC] ROT[7] MASK[1] COND[OBUS=0] JUMP[JAD] C550 $;J IF CALL FM MON]
  .DEFINE JCNFM [JAD]
[	D[PC] ROT[7] MASK[1] COND[-OBUS=0] JUMP[JAD] C550 $;J IF CALL NOT FM MON]
];.REPEAT KL

UMOVX:	COND[USER] JUMP[MUUO] NORM $
	D[MEM] DEST[Q] NORM $
	D[CONST 1] ROT[41] ALU[D+Q] DEST[HOLD] NORM $
	D[CONST 5] DEST[Q] JUMP[XCTUMV] NORM $





;------------------------------------------------------------------------------
;
;	XCTR - Execute Relocated
;
;	If in Exec mode and the AC field of the XCT instruction is non-zero,
;	it means do some of the references from User mode if PC bit (?),
;	meaning JSYS from Moniter, is not set.
;
;	This code is not map dependent, although other maps (like ITS) may code
;	the bits in the AC field differently, requiring some rewriting.
;
;	Warning:  This code is complex and prone to bugs.  Many probably lurk
;		  in the cracks.  If you find one, please document it even if
;		  no solution seems to appear.
;
;	FOR NOW, THIS CODE WILL BE USED FOR THE KL PAGER. I'M NOT SURE
;	THIS WILL REALLY WORK. -PG
;
;	Note on the MAP-EXEC-SR
;
;	This is a four bit shift register whose contents get
;	shifted right on every MEMSTO. The COND[USER] actually
;	checks the rightmost bit of this register. When the register
;	is shifted, the value of the user mode bit gets shifted into
;	the left side of the register. The entire register gets
;	set to the state of the user mode bit on DEST[CRYOV] and
;	SPEC[MA_PC] (signal Fetch Next Inst). The rightmost bit
;	of this register is used by the map logic to determine
;	which address space's map to use.  EVS 14 Aug 80
;------------------------------------------------------------------------------
XCT1:	D[PC] ALU[D-1] DEST[PC] JPOP[. + 1] NORM $
	COND[USER] JUMP[XCT2] NORM $
	D[IR] ROT[15] MASK[4] DEST[Q] SHORT $; SAVE XCT AC FLD
XCTUMV:	D[MEM] DEST[AR IR-ALL MA] COND[-MEM-IDX-IND] JUMP[XCT3] NORM $
XCT5:	D[IR] ROT[18.] MASK[4] COND[OBUS=0] JUMP[XCT4] C550 MAPF[2] $; J IF NO IDX FLD
.REPEAT KL [
	D[CONST 10] ALU[D&Q] COND[OBUS=0] JUMP[XCTIX1] C550 $
				;IF E NOT IN PREVIOUS CONTEXT, JUMP
	D[CONST 1] DEST[DEV-ADR] NORM $
	ALU[Q] DEST-A-MEM DEST[5] NORM $	;SAVE Q
	D[16] ROT[9] MASK[3] DEST[Q] NORM $	;CURRENT AC BLOCK
	D[16] ROT[12.] MASK[3] ALU[D#Q] COND[OBUS=0] JUMP[XCTQF1] NORM $
			;PREVIOUS AC BLOCK
	PUSHJ[XCTACP] NORM $	;GET ADDRESS OF PREVIOUS AC 0 IN Q
	D[IR] ROT[18.] MASK[4] ALU[D+Q] DEST[MA] NORM $	;+X
	D[IR] MASK[18.] DEST[Q] NORM $			;WAIT
	D[MEM] ALU[D+Q] DEST[MA IR-ADR AR] NORM $ ;DO INDEX
	D[15] DEST[Q] NORM $				;RESTORE Q
	ALU[0] DEST[DEV-ADR] JUMP[XCT4] NORM $
XCTQF1:	D[15] DEST[Q] NORM $				;RESTORE Q
	ALU[0] DEST[DEV-ADR] NORM $
];.REPEAT KL
XCTIX1:	D[IR] MASK[18.] ALU[IX+D] DEST[MA IR-ADR AR] $	;DO INDEX
XCT4:	D[IR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XCT3] C550 MAPF[2] $; J IF NO INDR
	D[CONST 10] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF ADDR CALC USER
XCT6:
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-IND] CYLEN[FIXM] $
;;;	FIXM1 $
;;;		;It was overdecrementing PC  TVR-Mar80
	SET-TEMP-EXEC $
	D[MEM] DEST[AR IR-23 MA] COND[MEM-IDX-IND] JUMP[XCT5] NORM $
XCT3:	ALU[Q] DEST[IR-ADR] SHORT  MAPF[2] $; SAVE XCT AC FLD
	D[IR] ROT[7] MASK[7] DEST[Q] SHORT $; GET HO 7 BITS OF OPCODE
	D[CONST 54] ALU[D#Q] COND[OBUS=0] JUMP[XCTSTK] C550 $; J IF STACK GROUP
	D[CONST 27] ALU[D#Q] COND[OBUS=0] JUMP[XCTBYT] C550 $; J IF BYTE GROUP
	D[CONST 52] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLG] C550 $; J IF GROUP WITH BLT IN IT
XCT13:	D[IR] MASK[4] DEST[Q] SHORT $; GET XCT AC FLD
.REPEAT 1 - KL [
XCT18:	D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NEITHER RELEVANT BIT
	COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
	JCFM[XDISP] ;J IF CALL FM MON
	D[CONST 1] ALU[D&Q] COND[OBUS=0] JUMP[XCT11] C550 $;J IF BIT OFF
	D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XCT12] C550 $; J IF OTHER BIT OFF
	D[CONST 03] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
XCT12:	D[CONST 02] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET DEST TO USER
XCT11:	D[CONST 01] ROT[11] DEST[MAP-EXEC-SR] NORM $; SET SRC TO USER
];.REPEAT 1 - KL
.REPEAT KL [
XCT18:	D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NO RELEVANT BIT
	D[IR] COND[OBUS<0] C550 JUMP[XIOINST] $; MUST FILTER OUT CLRPT
XNOTPT:	COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
XISPT:	JCFM[XDISP] ;J IF CALL FM MON
	D[CONST 07] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
		;OTHER BIT IS IN CASE ITS A DMOV?M
];.REPEAT KL
XDISP:	D[MA] DEST[MA IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
XCT2:	D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $
.REPEAT KL [
;THIS RETURNS THE ADDRESS OF AC0 IN THE PREVIOUS AC BLOCK IN Q.
;THIS SAVES IR IN AR FOR MAPON/OFF. IT SETS DEVICE 1.
XCTACP:	D[IR] MASK[18.] DEST[AR] PUSHJ[MAPOF] NORM $	;SAVE IR FOR MAPON/OFF
	D[CONST 1] DEST[DEV-ADR] NORM$
	D[17] ROT[9.] MASK[9. + 13.] DEST[Q] NORM $	;EXEC BASE ADDRESS
	D[CONST 37] ALU[DORQ] DEST[MA HI-ABS-MA] NORM $	;+37=AC BLOCK PTR
	D[16] ROT[16.] MASK[7] DEST[Q] NORM $	;GET PREVIOUS AC BLOCK
	D[MASK 4] ALU[-D&Q] DEST[Q] NORM $		;*16.
	D[MEM] ALU[D+Q] DEST[Q] NORM $			;+AC BLOCK PTR 
	ALU[0] DEST[HI-ABS-MA] PUSHJ[MAPON] NORM $	;RESTORE STATE
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST[IR-ADR] POPJ NORM $			;AND RETURN
];.REPEAT KL
XCTAC:
.REPEAT KL [
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST-A-MEM DEST[1] NORM $			;SAVE AR
	D[MA] DEST-A-MEM DEST[4] NORM $			;SAVE MA
	ALU[Q] DEST-A-MEM DEST[5] NORM $		;SAVE Q
	D[16] ROT[9] MASK[3] DEST[Q] NORM $		;CURRENT AC BLOCK
	D[16] ROT[12.] MASK[3] ALU[D#Q] COND[OBUS=0] JUMP[XCTQF2] NORM $
			;PREVIOUS AC BLOCK
	PUSHJ[XCTACP] NORM $ 	;GET ADDRESS OF PREVIOUS AC 0 IN Q
	D[14] ALU[D+Q] DEST[Q] NORM $			;+AC
	ALU[Q] DEST-A-MEM DEST[4] NORM $
XCTQF2:	D[15] DEST[Q] NORM $				;RESTORE Q
	D[14] DEST[MA] NORM $				;RESTORE MA
	D[11] DEST[AR] NORM $				;RESTORE AR
	SET-TEMP-EXEC $;SINCE RETURNING ADDRESS IN EXEC SPACE, MAKE
			; SURE THATS WHERE THE MEMORY REFERENCE COMES FROM.
	ALU[0] DEST[DEV-ADR] POPJ NORM $
];.REPEAT KL
.REPEAT 1 - KL [
.REPEAT 1 - WAITS [
	ACSEL[AC] ALU[AC] DEST[HOLD]  SHORT $; SAVE AC
	ACSEL[AC] DEST[CLR-DEV-FROM-INTR AC] D[MA] SHORT $; GET AC ADDRS
	D[CONST 1] DEST[DEV-ADR] SHORT $
	ACSEL[AC] D[13] ALU[D+AC] DEST[AC] SHORT $; ADD IN AC BASE REG.
	ACSEL[AC] D[CONST 75] ROT[11] ALU[D+AC] DEST[AC] SHORT $
	ACSEL[AC] D[CONST 7] ROT[17] ALU[D+AC] DEST[AC] NORM $
	D[MEM] ACSEL[AC] DEST[O_AC MA] POPJ NORM $
];.REPEAT 1 - WAITS
.REPEAT WAITS [
	D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $; LEAVE IF CALL FM MON
	ACSEL[AC] D[MA] DEST[O_AC HOLD] $
		;Get address of AC, we need to mung it
		;Save AC, we can't use Q for some reason [???]
	ACSEL[AC] D[CONST 77] ROT[9. + 3.] ALU[D+AC] DEST[AC] NORM $
		;Add page number of window
		;Use 770xxx for window into user ACs
	D[MEM] ACSEL[AC] DEST[O_AC MA CLR-DEV-FROM-INTR] NORM $
		;Restore AC and set MA from AC to start read
.REPEAT 1 - NEWMAP [
	D[CONST 1] DEST[DEV-ADR] NORM $
		;Select appropriate A-MEM
	D[13] ROT[9.] MASK[36. - 13.] DEST[STO-MAP] COND[OBUS=0] JUMP[.] NORM $
		;Extract address and position for map
		;Not R,W,X excluded.  Not NO ENTRY AT ALL
		;Hang if attempt to reference user ACs with no shadow
		;memory defined at time of CONO PAG,
];.REPEAT 1 - NEWMAP
.REPEAT NEWMAP [
 	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
		;Select appropriate A-MEM
		;Set place in map to write it and start map write
	MAPF[2] ROT[9.] MASK[36. - 13.] COND[OBUS=0] JUMP[.] NORM $
		;Finish map write.
		;Not R,W,X excluded.  Not NOT ENTRY AT ALL
		;Hang if attempt to reference user ACs with no shadow
		;memory defined at time of CONO PAG,
];.REPEAT NEWMAP
	D[MA] DEST[MA] POPJ NORM $
];.REPEAT WAITS
];.REPEAT 1 - KL
XCTSTK:
;;;	COND[-MA-AC] JUMP[XCT13] NORM $; J IF EF ADR NOT AC (TREAT NORMALLY)
	D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LOW ORDER BITS OF OP CODE, J IF PUSHJ
	D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF POPJ
.repeat 0[
	D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XCTS1] C550 $; J IF POP
	D[CONST 4] DEST[Q] JUMP[XCTS2] NORM $
XCTS1:	D[CONST 1] DEST[Q] SHORT $
XCTS2:	D[IR] ALU[D&Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF AC REF NOT USER
	D[IR] ALU[D-Q] DEST[IR-ADR] PUSHJ[XCTAC] NORM $; FIX EF ADR.
	MAPF[2] JUMP[XCT13] NORM $
];.repeat 0
	D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XPOP1] C550 $; J IF POP
	JUMP[XPUSH1] NORM $
		;Someday, move code over here (when we have space)
XCT10:	PUSHJ[XCTAC] NORM $; FIX EF ADR
	MAPF[2] D[MA] DEST[IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
XCTBLG:	D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LO BITS OF OPCODE, J IF EXCH
	D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLT] C550 $; J IF BLT
	D[IR] MASK[4] DEST[Q] JUMP[XCT18] NORM $; GET XCT AC FLD, PROCEDE

	.USE[OTHER]

XCTBYT:	D[IR] ROT[42] MASK[1] SPEC[PC+1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF B.P. FETCH IS NOT EXEC
XBY1:	D[IR] ROT[11] MASK[1] COND[OBUS=0] JUMP[XBY3] C550 MAPF[2] $;J IF BP WILL BE INCR
	FIXM1 $
	D[MEM] DEST[AR Q] NORM $; GET BP
XBY4:	SET-TEMP-EXEC $
	D[AR] MASK[18.] DEST[MA] COND[-MEM-IDX-IND] JUMP[XBY13] NORM $; J IF BP HAS NO IDX OR INDR
XBY15:	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[XBY14] C550 MAPF[2] $; J IF NO IX FLD
	D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] NORM $
	D[AR] MASK[18.] ACSEL[REG] ALU[D+AC] DEST[AR] SHORT $
	D[AR] MASK[18.] ALU[DORQ] DEST[Q AR MA] SHORT $
XBY14:	D[AR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XBY13] C550 MAPF[2] $; J IF NO INDR
	D[IR] ROT[43] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF BP ADR CALC IS USER
	FIXM1 $
	SET-TEMP-EXEC $
	D[AR] ROT[14] MASK[14] DEST[AR] SHORT $
	D[AR] ROT[30] DEST[Q] SHORT $
	D[MEM] MASK[27] ALU[DORQ] DEST[Q AR MA] COND[MEM-IDX-IND] JUMP[XBY15] NORM $
XBY13:	D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] MAPF[2] $; MAKE MA OK
	D[IR] ROT[10] MASK[1] COND[OBUS=0] JUMP[LDB5] C550 MAPF[2] $; DISTINGUISH LOADS FROM DEPOSITS, J IF LOAD
	JUMP[DPB5] NORM $

XBY3:	FIXM2 $
.REPEAT 1 - KL [
	D[MEM] DEST[AR Q] COND[HALF] JUMP[XBY4] NORM $;GET BP, J IF NO INCR
];.REPEAT 1 - KL
.REPEAT KL [
	D[MEM] DEST[AR Q] COND[HALF] JUMP[XBYH] NORM $;GET BP, J IF MAYBE NO INCR
XBY3A:];.REPEAT KL
	D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $; GET S FLD, HANDLE OVERFLOW
	D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $; SUB S FROM P
	ACSEL[MA] D[MEM] DEST[AC] NORM $
	PUSHJ[SETFPD] NORM $; SET HALF
	JUMP[XBY4] NORM $; (IN CASE OF MAP FAULTS)
.REPEAT KL [
XBYH:	D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[XBY4] $
		;IF KL, AND AMEM FPD SET, THEN DON'T INCREMENT
	JUMP[XBY3A] NORM $;ELSE FORGET HALF WAS ON.
];.REPEAT KL
XFIXMA:	COND[MA-AC] JUMP[XCTAC] NORM $; J IF ADDRS IS AC
.REPEAT 1 - KL [
	D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $;LEAVE IF CALL FROM MONITOR
];.REPEAT 1 - KL
.REPEAT KL [
	D[PC] ROT[7] MASK[1] COND[OBUS=0] POPJ C550 MAPF[2] $; RETURN IF CALL IS FROM MONITOR
];.REPEAT KL
	SET-TEMP-USER $
	D[MA] DEST[MA] POPJ NORM $

XCTBLT:	D[MA] SPEC[PC+1] DEST[O_AC AR] NORM $; END ADR IN AC, AC IN AR
XBLTL:	D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET WORD
.REPEAT 1 - KL [
	D[IR] ROT[42] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; FIX IF USER ADDRS
];.REPEAT 1 - KL
.REPEAT KL [
	D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX IF SOURCE IS FROM USR SPACE
];.REPEAT KL
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
	D[MEM] DEST[Q] SHORT $; GET DATA WORD
	D[AR] MASK[18.] DEST[MA] SHORT $; GET DEST ADR
.REPEAT 1 - KL [
	D[IR] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX MA ADDRS
];.REPEAT 1 - KL
.REPEAT KL [
	D[IR] ROT[33. + 1.] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $ ;FIX SR IF DEST IS USER SPACE
];.REPEAT KL
	ALU[Q] DEST[MEMSTO] SHORT $
	D[AR] MASK[18.] ALU[D-AC] MAPF[BLT-WRTB] COND[-OBUS<0] JUMP[BLTA12] C600 $
	D[CONST 1,,1] DEST[Q MAP-EXEC-SR] COND[-MA-AC] JUMP[. + 2] NORM $
	D[MEM] ACSEL[MA] DEST[AC] SHORT $
	D[AR] ALU[D+Q] DEST[AR] JUMP[XBLTL] NORM $; TEST FOR INTERPT HERE ? *****
;Special case for PUSH.  Check for AC reference from stack pointer
XPUSH1:	D[IR] MASK[1] COND[OBUS=0] JUMP[XPUSH2] C550 $
		;If not mapping stack references, it's simple
	D[IR] ROT[36. - 2] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] SPEC[PC+1] C550$
		;Make sure we're referring to the right place here.
		;Also, we're now executing the instruction (PC+1)
	FIXM1 $	;Check page faults for effective address part.
	D[MEM] DEST[AR] NORM $
		;Copy away the thing that we want to push
	D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[XPDLO2] C550 $
		;Advance frame pointer and check for overflow
	PUSHJ[XFIXMA] NORM $
		;Decide whether to map destination.
.REPEAT 1 - KL [;BBN PAGER CAN USE NORMAL STORE, SINCE MACRO CODE NEEDS TO FINISH THE WRITE AFTER A PAGE FAIL.
	D[AR] DEST[MEMSTO] MEMST $
];.REPEAT 1 - KL
.REPEAT KL [
	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PMSMAIN] NORM $
		;KL PAGER NEEDS TO GO TO PLACE WITH SPECIAL MAPF FIELD
		; THAT WILL MAKE THE POINTER BACKUP
];.REPEAT KL
		;Finish instruction. We're done
XPDLO2:	PUSHJ[XFIXMA] NORM $
		;Fixup AC references
	JUMP[PDLO2] NORM $
		;Done.  Take stack overflow trap

;HERE IF ONLY THE 4 BIT IS ON IN XCT AC FIELD. ALMOST LIKE
; A REGULAR INSTRUCTION, EXCEPT CANNOT SET THE MAP-EXEC-SR TO 3,
; LIKE XCT18 DOES EVENTUALLY BECAUSE SOURCE COMES FROM EXEC MODE.
; XPUSH1 USED TO GO TO XCT13, BUT WHILE DEBUGGING KL MAP
; FOUND THIS PROBLEM OF XCT 4,[PUSH AC,FOO] FAULTING ON USER
; ADDRESS CORRESPONDING TO STACK. I ASSUME THIS DIDN'T WORK FOR
; BBN MAP EITHER, BUT I PUT THIS COMMENT HERE JUST IN CASE. EVS 7/30/80

XPUSH2:	D[IR] ROT[33.] COND[-OBUS<0] JUMP[XDISP] C550 $
		;IF 4 BIT ISN'T ON, THEN DO INSTRUCTION AS USUAL.
	COND[MA-AC] JUMP[XCT10] NORM $
		;IF PUSHING AN AC, MUST DO IT FROM ANOTHER AC BLOCK PERHAPS.
	JCFM[XDISP]	;IF MONITOR IS PREVIOUS ADDRESS SPACE,, LEAVE SR SET TO ZERO
	D[CONST 1] ROT[9.] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $
		;SOURCE COMES FROM USER, BUT STACK IS IN EXEC.

;Special case for POP.  Check for AC reference from stack pointer
XPOP1:	D[IR] ROT[11] DEST[Q] NORM SPEC[PC+1] $
		;Save bit meaning 'source from user' in format that can
		;be fed easily to EXEC-SR
		;Now we're executing the PUSH (implied by PC+1)
.REPEAT KL [
		;THIS STUFF SWAPS THE 1 AND 4 BIT
	D[CONST 1] ROT[11] ALU[-D&Q] DEST[Q] NORM $
	D[CONST 4] ROT[11] ALU[-D&Q] DEST[Q] NORM $
	D[IR] ROT[35.] COND[-OBUS<0] JUMP[. + 2] C550 $
	D[CONST 4] ROT[11] ALU[DORQ] DEST[Q] NORM $
	D[IR] ROT[33.] COND[-OBUS<0] JUMP[. + 2] C550 $
	D[CONST 1] ROT[11] ALU[DORQ] DEST[Q] NORM $
];.REPEAT KL
	D[MA] DEST[IR-ADR] NORM $
		;Restore normal effective address 
	ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC] NORM $
		;Update AC and MA for stack reference
	D[CONST 4] ROT[11] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $
		;Fixup stack addressing if user AC
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
		;Check for page faults
	D[MEM] DEST[AR] NORM $
		;Find somewhere safer for thing to push
	D[IR] MASK[22] DEST[MA] NORM $
		;GET ADDRESS INTO MA FOR XCTAC
	D[CONST 1] ROT[11] ALU[D&Q] COND[OBUS=0] JUMP[XPOP3] C550 $
		;JUMP IF NOT STORING INTO PREVIOUS CONTEXT ADDRESS SPACE
	COND[MA-AC] JUMP[XPOPAC] NORM $;JUMP IF POPPING TO AN AC
		;Fixup AC addressing if needed.  (We can't combine this and
		;previous instruction because MA is strobed at end of cycle.
		;We can't call XFIXMA because it uses SET-TEMP-USER which
		;would affect the next instruction fetch. Sigh...)
XPOP2:	JCFM[XPOP3] ;JUMP IF CALL FROM MONITOR, LEAVE EXEC-SR CLEARED
	D[CONST 2] ROT[9.] DEST[MAP-EXEC-SR] JUMP[XPOP3] NORM $;WILL GET SHIFTED ONCE BEFORE THE STORE, THEN STORE WILL HAPPEN TO USER SPACE
XPOPAC:	PUSHJ[XCTAC] NORM $ ;FIXUP MA TO POINT TO AREA WHERE PREVIOUS ACS ARE KEPT
XPOP3:	D[CONST 1,,1] ALU[D+AC] COND[CRY0] JUMP[PDLO5] C550 $
		;Try for overflow again.  Take it if you need it.
.REPEAT 1 - KL [
	D[AR] DEST[MEMSTO] MEMST $
];.REPEAT 1 - KL
.REPEAT KL [
	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PMSMAIN] NORM $
];.REPEAT KL
		;Write out thing we POP'ped

.REPEAT KL [
	.USE[OTHER]
;HERE IF HI ORDER BIT IN OPCODE IS ON. IF ITS CLRPT, MUST
; AVOID CHECKING FOR EFFECTIVE ADDRESS EQUAL TO AC, SO THAT
; WE CLEAR PAGE TABLE EVEN IF ADDRESS IS GIVEN IN ACS (TO BE
; COMPATIBLE WITH KL10)

XIOINST:
	D[IR] ROT[6. + 1.] MASK[6] DEST[Q] SHORT $ ;GET HI ORDER 6 BITS
	D[CONST 60] ALU[D#Q] COND[-OBUS=0] JUMP[XNOTPT] C550 $
		;FIRST 6 BITS 1-6 ARE 60, JUMP IF NOT THAT
	D[IR] ROT[12. + 1.] MASK[6] DEST[Q] SHORT $;GET NEXT 6 BITS, 7-12
	D[CONST 22] ALU[D#Q] COND[-OBUS=0] JUMP[XNOTPT] C550 $
		;SECOND 6 BITS, 7-12, ARE 22, JUMP IF NOT THAT
	JUMP[XISPT] SHORT $;IS CLRPT, SKIP OVER THE CHECK FOR AC ADDRESS.
];.REPEAT KL




;APRDSP PIDSP AREA53 APRCO APRCO2 APRCO3 APRIEN APRC1 APRC2 APRCHK APRCK1 APDINT APRCI APRCII APRDI APIOT
;------------------------------------------------------------------------------
;
;	APR and PI instructions
;
;------------------------------------------------------------------------------
	.ORG[5300]	 ;APR & PI IOT DISP TABLE
APRDSP:	ILGIOT $; BLKI APR
	NOP $
	ALU[0] DEST[DEV-ADR] NORM $; DATAI -- RD SW
	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] JUMP[APRDI] NORM $
	ILGIOT $ ;BLKO APR
	NOP $
	JUMP[MAIN] $; DATAO
	NOP $
.REPEAT 1 - KL [
	D[IR] MASK[13] DEST[Q] NORM $; GET CONO BITS
	D[CONST 33] ROT[5] ALU[-D&Q] DEST[Q] JUMP[APRCO] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
	JUMP [APRCO] NORM $
	NOP $
];.REPEAT KL
	PUSHJ[APRCI] NORM $; CONI -- GET BITS IN AR & Q
.REPEAT KL [
	D[AR] DEST[MEMSTO] MEMST $
		;IF KL, WHOLE WORD GETS RETURNED
];.REPEAT KL
.REPEAT 1 - KL [
	D[AR] MASK[18.] DEST[MEMSTO] MEMST $
];.REPEAT 1 - KL
	PUSHJ[APRCI] NORM $; CONSZ -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	PUSHJ[APRCI] NORM $; CONSO -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
PIDSP:	.REPEAT 3[ ILGIOT $
	NOP $
]
	;DATAO PI -- Set lights
	D[CONST 0] DEST[DEV-ADR] PUSHJ[SETLTS] NORM $	;Just like examine...?
	JUMP[MAIN] SHORT $
	JUMP[PICONO] NORM $; PI CONO
	NOP $
	PUSHJ[PICONISUB] NORM $; CONI -- GET BITS IN AR & Q
	D[AR] DEST[MEMSTO] MEMST $
	PUSHJ[PICONISUB] NORM $; CONSZ -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	PUSHJ[PICONISUB] NORM $; CONSO -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $


   .USE[NORMAL]

.REPEAT 1 - KL [
APRCO:	D[CONST 1] ROT[3] ALU[-D&Q] DEST[AR] SHORT $
	D[IR] ROT[43] MASK[21] ALU[NOTD] DEST[Q] SHORT $
		; GET CLR BITS
	D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
		; Remove PI assignment
	D[10 + APRSTS] SPEC[A-MEM-APR] ALU[D&Q] DEST[Q CLR-DEV-FROM-INTR] SHORT $
		; CLEAR INDICATED BITS
	D[AR] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS AR] NORM $
		; SET INDICATED BITS & CHAN
	D[IR] ROT[41] MASK[1] COND[OBUS=0] JUMP[APRCO2] C550 $
		; J IF NO CLR OVERFLOW BIT
	D[PC] MASK[43] DEST[CRYOV] SHORT $; CLR OV
		; Remove overflow bit from current PC flags
APRCO2:	D[IR] ROT[36] MASK[1] COND[OBUS=0] JUMP[APRCO3] C550 $
		; J IF NO CLR FLT OV
	D[MASK 43] ROT[41] DEST[Q] SHORT $
		; Remove bit from current PC flags
	D[PC] ALU[D&Q] DEST[CRYOV] SHORT $
		; CLR FLT OV
APRCO3:	D[IR] ROT[33] MASK[1] COND[-OBUS=0] PUSHJ[CLKCLR] C550 $
		; CLR CLOCK FLAG IF INDICATED
;	---

; TEMP **** APRCI:
APRIEN:	PUSHJ[APRCII] DEST[CLR-DEV-FROM-INTR] NORM $
		; GET APR CONI BITS
	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
		; Select and read MAP and ECC enablings
	D[IOD] MAPF[4] MASK[3] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
		; For some pecular reason, the thing we read from device 1 is
		; written in device 0???
	D[AR] MASK[3] COND[OBUS=0] JUMP[APRC1] C550 $
		; Jump if no PI channel.  We don't want to enable arithmetic
		; micro-interrupts in that case.
	D[AR] ROT[40] MASK[1] COND[OBUS=0] JUMP[APRC1] C550 $
		; J IF NO OV INT ENBL
		; *** Don't both enables need to be checked???
	D[CONST 2] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] JUMP[APRC2] NORM $; ENABLE OV INT
		; Turn on arithmetic interrupts
APRC1:	D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
		; Turn off arithmetic interrupts
APRC2:	MAPF[10] CYLEN[IOB-OUT] D[AR] DEST[Q] JUMP[APRCK1] $
		; Finish turning arithmetic interrupts off or on, and we're done

];.REPEAT 1 - KL
.REPEAT KL [
APRCO:	D[10 + APRSTS] A-MEM-APR DEST[Q CLR-DEV-FROM-INTR] SHORT $
	 ;GET CONI WORD
	D[CONST 7] ALU[-D&Q] DEST[Q] NORM $
		;CLEAR OUT OLD PI ASSIGNMENT
	D[IR] MASK[3] ALU[DORQ] DEST[Q] NORM $
	 ;PUT IN NEW PI ASSIGNMENT
	D[IR] ROT[36. - 4.] MASK[8.] DEST[AR] NORM$
	 ;GET BITS WE WILL SET/CLEAR/ENABLE/DISABLE
	D[IR] ROT[20.] -OBUS<0 C550 JUMP[APRCO1] $
	 ;JUMP IF NOT ENABLING SELECTED BITS
	D[AR] ROT[18. + 4.] ALU[DORQ] DEST[Q] NORM $
	 ;SET ENABLE BITS (IN LH OF CONI WORD)
APRCO1:	D[IR] ROT[21.] -OBUS<0 C550 JUMP[APRCO2] $
	 ;JUMP IF NOT DISABLING SELECTED BITS
	D[AR] ROT[18. + 4.] ALU[-D&Q] DEST[Q] NORM $
	 ;CLEAR INDICATED ENABLE FLAGS (DISABLE)
APRCO2:	D[IR] ROT[23.] -OBUS<0 C550 JUMP[APRCO3] $
	 ;JUMP IF NOT SETTING FLAGS THEMSELVES
	D[AR] ROT[4.] ALU[DORQ] DEST[Q] NORM $
	 ;SET BITS HE WANTS SET
APRCO3:	D[IR] ROT[22.] -OBUS<0 C550 JUMP[APRCO4] $
	 ;JUMP IF NOT CLEARING SELECTED FLAGS
	D[AR] ROT[4.] ALU[-D&Q] DEST[Q APRSTS] A-MEM-APR&DEST-A-MEM NORM $
	 ;CLEAR THEM AND STORE RESULT INTO AMEM IN CASE HAVE TO CALL CLKCLR
	D[AR] ROT[4. + 13. + 18.] OBUS<0 C550 PUSHJ[CLKCLR] $
	JUMP[APRCHK] SHORT $
APRCO4:	ALU[Q] A-MEM-APR&DEST-A-MEM DEST[APRSTS] JUMP[APRCHK] NORM $
	 ;STORE FINAL RESULT INTO AMEM[2]
	 ;AND GO TO APRCHK TO SEE IF NEED TO INTERRUPT NOW
];.REPEAT KL
;Check for clock interrupts (and other things)
APRCHK:	PUSHJ[APRCI] NORM $; GET CONI BITS IN AR & Q

APRCK1:
.REPEAT 1 - WAITS [
	D[AR] MASK[3] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF PI=0
.REPEAT 1 - KL [
	D[AR] ROT[20] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF PDLOV INT
	D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $; AND MASK WITH FLAG
	D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF OV INT
	D[CONST 10] ROT[6] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF NO CLOCK INT
];.REPEAT 1 - KL
.REPEAT KL [
	D[AR] ROT[32.] -OBUS<0 JUMP[UINT-DISMISS] C550 $	;DONE IF INTERRUPT REQUEST FLAG NOT SET
];.REPEAT KL
;	\ /
];.REPEAT 1 - WAITS
.REPEAT WAITS [
	D[AR] ROT[27.] COND[OBUS<0] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
		;If no APR interrupt is not requested, don't interrupt.
		;Otherwise, fall thru
];.REPEAT WAITS

;	\ /	(Falls thru from APRCK1)
APDINT:	D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; GET CHAN #, CAUSE INTERRUPT

.REPEAT 1 - KL [
APRCI:	;TEMP -- LATER WE FIX OV
APRCII:	PUSHJ[CLKRDFLG] NORM $
	 ;Get CLOCK FLAG in AR 35, rest of AR = 0
	.DEFINE APRGBT [R1 R2]
[	D[PC] ROT[R1] MASK[1] DEST[Q] SHORT $
	D[AR] ROT[R2] ALU[DORQ] DEST[AR] SHORT $
]
	APRGBT[1 6]
	APRGBT[4 41]
	APRGBT[7 33]
	D[AR] ROT[17] DEST[Q] SHORT $; SET FLAGS
.REPEAT 1 - WAITS [
	D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM POPJ $
];.REPEAT 1 - WAITS

.REPEAT WAITS [
;SAIL's KA-10 has a processor modification which sets bit 27 (400 bit) if the
;APR is NOT interrupting.  This feature is used in a CONSZ chain and would
;consume many instructions to simulate in a critical path in the system.
	D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM $
		;Construct full status
	D[AR] MASK[3] COND[OBUS=0] JUMP[APRCIN] NORM $
		;Set 400 bit if interrupts disabled 
		;(This may not be the same as SAIL)
	D[AR] ROT[20] MASK[1] COND[-OBUS=0] POPJ C550 $
		;If pushdown overflow, we will interrupt.
	D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $
		;Combine flag with enable to see which interrupts
	D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APRCIY] C550 $
		;Jump if overflow is causing an interrupt.
	D[CONST 10] ROT[6] ALU[D&Q] COND[-OBUS=0] JUMP[APRCIY] C550 $
		;Jump if clock is causing an interrupt.
APRCIN:	D[CONST 4] ROT[6] DEST[Q] SHORT $
		;Not interrupting, set 400 bit in APR status
APRCIY:	D[AR] ALU[DORQ] DEST[AR Q] POPJ NORM $
		;Turn on 400 bit if needed.
		;Note, that since we ANDed something with Q, ORing in Q is
		;a NO-OP if we didn't go thru APRCIN.
];.REPEAT WAITS
];.REPEAT 1 - KL
.REPEAT KL [;IF KL FORMAT APR CONI WORD

APRCII:
APRCI:	PUSHJ[CLKRDFLG] NORM 		$;GET CLK FLG IN AR35, REST IS 0
	D[10 + APRSTS] A-MEM-APR DEST[Q] NORM $	;GET APR CONI WORD IN Q
	D[AR] ROT[35. - 31.] ALU[DORQ] DEST[Q AR] NORM $
	 ;OR CLOCK FLAG (1B31) INTO APR CONI WORD
	D[AR] ROT[18.] MASK[18.] ALU[D&Q] OBUS=0 C550 POPJ $
	 ;IF NOT ENABLED FOR ANY FLAGS THAT ARE TRYING TO INTERRUPT, DON'T SET IRP REQUEST
	D[CONST 1] ROT[35. - 32.] ALU[DORQ] DEST[Q AR] POPJ NORM $
	 ;A FLAG CURRENTLY ENABLED IS SET, SET IRP REQUEST.
];.REPEAT KL

APRDI:	MAPF[2] D[IOD] DEST[MEMSTO] COND[-MA-AC] LBJUMP[MSMAIN] CYLEN[IOB-IN] $

	.PAIR
	UIOTRP[MUUO] $			;Trap if not IOT-USER Mode
APIOT:	IOTDIS[APRIOTDISP-ORGARG]





;PDLO1 PDLO2 PDLO5 PDLO3 PDLO4 PDLO6 PDLMEM PDLOE PDLO SOED STOPS SOVRS SECCS SOEDOV

.REPEAT 1 - KL [
PDLO1:	PUSHJ[PDLO] NORM $ ;SET PDLO BIT
	D[PC] DEST[AR MEMSTO] NORM $
	MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
PDLO2:	PUSHJ[PDLO] NORM $; SET FLAG
PDLO5:	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
PDLO3:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	D[MEM] DEST[AR] PUSHJ[PDLO] NORM $
	D[IR] MASK[18.] DEST[MA] JUMP[PDLO5] NORM $
PDLO4:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	PUSHJ[PDLO] NORM $
	D[MEM] MASK[18.] DEST[PC] JUMP[PDLOE] NORM $
;PDLOV from ADJSP
PDLO6:	PUSHJ[PDLO] NORM $
	JUMP[PDLOE] NORM $

	.PAIR
PDLMEM:	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] MAPF[MASTO] $
PDLOE:	MAPF[MASTO] D[10 + APRSTS] MASK[3] DEST[AR] SPEC[A-MEM-APR]
	JUMP[PIGEN] NORM $; CHAN # IN AR, TRY INTERRUPT

PDLO:	D[10 + APRSTS] SPEC[A-MEM-APR] DEST[Q] NORM $; APR CONI WORD
	D[CONST 1] ROT[20] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS]
			NORM POPJ $
		;SET PDLOV BIT
];.REPEAT 1 - KL
.REPEAT KL [
;PDLOV FROM PUSHJ GETS HERE
PDLO1:	D[PC] DEST[AR Q MEMSTO] COND[HALF] JUMP[PDLO1H] NORM $
		;STORE PC ON STACK, JUMP IF HALF FLAG ON
PDLO1A:	MAPF[PPOP] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
PDLO1H:	MAPF[PPOP] D[10 + APRSTS] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[PDLO1A] $
		;JUST SET PC IF FPD ON IN AMEM.
	D[CONST 1] ROT[35. - 4.] ALU[-D&Q] DEST[MEMSTO] JUMP[PDLO1A] NORM $
		;STORE PC WITH FPD OFF.


;PDLOV FROM POP GETS HERE
PDLO3:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	D[MEM] DEST[AR] NORM $
	D[IR] MASK[18.] DEST[MA] NORM $

;PDLOV ON PUSH
PDLO5:
PDLO2:	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PDLMEM] NORM $

;PDLOV FROM POPJ GETS HERE
PDLO4:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	D[MEM] MASK[18.] DEST[PC] JUMP[PDLOE] NORM $

;PDLOV from ADJSP

	.PAIR
PDLMEM:	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] MAPF[PPOP] $

PDLO6:	;PDLOV FROM ADJSP
PDLOE:	MAPF[PPOP] D[CONST 2] DEST[AR] JUMP[DOTRPX] NORM $
		;DO A TRAP 2 (PDL OVERFLOW)

];.REPEAT KL

	.USE[AREA53]

.REPEAT F3SW [

SOED:	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
	D[CONST 1] ROT[25] ALU[D&Q] COND[OBUS=0] JUMP[DOHALT] C600 $
	D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] C550 $; J IF NO OV
	D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
	D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN

	D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
.REPEAT 1 - XUCODE [
	D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
];.REPEAT 1 - XUCODE
.REPEAT XUCODE [
	D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
];.REPEAT XUCODE
  	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
	D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $

	ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
	D[MEM] DEST[Q] NORM $
	D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
	D[AR] ALU[D+1] DEST[ECCSVP] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	SPEC[IOB-IN] D[CONST 1] DEST[DEV-ADR] NORM $
	 ;NOW READ STATE OF MAP ON, OV ENBL, ETC.
	D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
	 ;PRESERVE IN IR.
	ALU[0] DEST[DEV-ADR] SHORT $
;;;  	D[IR] ROT[31.] COND[OBUS<0] PUSHJ[ECC-UNC] C550 $
	 ;IF ERROR WAS UNCORRECTABLE, GO SEE ABOUT INTERRUPTING.
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
	MAPF[2] D[MEM] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
	MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
	D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
	CYLEN[C500] $;WAIT
	D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
	NORM $; WAIT -- FOR LUCK
	D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
	 MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
	DEST[CLR-MI-ERR] JUMP[UINT-DISMISS] $  ;CLEAR THE ERROR FLIPFLOP

  ]  ;; END OF .REPEAT F3SW

;(ECC-UNC moved to bottom of page)

 .REPEAT F2SW [ 

STOPS:	D[CONST 1] DEST[DEV-ADR] JUMP[DOHALT] NORM $

SOVRS:	D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] DEST[CLR-DEV-FROM-INTR] C550 $
		; J IF NO OV
	D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
	D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
	JUMP[.] $ ; HOW COULD WE GET HERE?

SECCS:	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
	D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
.REPEAT 1 - XUCODE [
	D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
];.REPEAT 1 - XUCODE
.REPEAT XUCODE [
	D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
];.REPEAT XUCODE
  	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
 ;;;;;	D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $

	ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
	D[MEM] DEST[Q] NORM $
	D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
	D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
;NOTE:	This conflicts with the use of the lights by diagnostics.
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
	MAPF[2] ALU[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
	MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
	ALU[Q] DEST[A-MEM-ECC-DATA] DEST-A-MEM NORM $
	  ;Save info for reading via opcode 750.  
	D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
	CYLEN[C500] $;WAIT
	D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
	NORM $; WAIT -- FOR LUCK
	D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
	 MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
	DEST[CLR-MI-ERR] JUMP[UINT-DISMISS] NORM $

  ] ;; END OF .REPEAT F2SW

;$*$*$*$ No space left in AREA53  by now...
	.USE[OTHER]

SOEDOV:	ALU[0] DEST[DEV-ADR] NORM $
.REPEAT 1 - KL [
	D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
	MAPF[10] CYLEN[IOB-OUT] PUSHJ[APRCII] $; GET CONI BITS
	D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; DO INTR.
];.REPEAT 1 - KL
.REPEAT KL [
	D[PC] MASK[35.] DEST[CRYOV] NORM $
		;TURN OFF OVERFLOW BIT IN REAL PC WORD SO WE DONT TRAP AGAIN.
	D[12] SPEC[A-MEM-APR] DEST[Q] NORM $
		;GET AMEM LOC WITH FAKE OVERFLOW BIT IN IT
	D[CONST 1] ROT[35. - 4] ALU[DORQ] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
		;SET FAKE OVERFLOW IN AMEM.
	 D[CONST 1] DEST[AR] JUMP[DOTRPX] SHORT $
		;OVERFLOW, MUST DO TRAP INSTRUCTION
];.REPEAT KL



ECC-UNC:  ;SEE IF WE SHOULD GIVE INTERRUPT FOR HARD ECC ERR
	  ;RETURN TO CALLER IF NOT, BUT STILL SET PAR ERR FLAG.
.REPEAT 1 - KL [
	D[14] DEST[Q] NORM $
	 ;FIRST, SET PAR ERR FLAG IN PI CONI BITS.
	D[CONST 1] ROT[35. - 19.] ALU[DORQ] 
		DEST[AR 4] DEST-A-MEM NORM $
	D[AR] ROT[35. - 20.] C550 COND[-OBUS<0] POPJ $
	 ;IF PAR ERR INTRPT ENABLE OFF, DO NO MORE.
	D[10 + APRSTS] MASK[3] DEST[Q AR] C550 COND[OBUS=0] POPJ $
	 ;IF APR PI CHAN IS 0, DON'T GIVE INTRPT.
];.REPEAT 1 - KL
.REPEAT KL [;MUST CHECK APR CONI WORD ON KL STYLE MACHINE
	D[10 + APRSTS] DEST[Q] NORM $
	D[CONST 4] ROT[6] ALU[DORQ] DEST[AR Q 4] DEST-A-MEM PUSHJ[APRCI]NORM$
	 ;SET PARITY ERROR 1B27, AND GET CONI IN AR AND Q
	D[AR] MASK[3] C550 OBUS=0 POPJ $	;IF NO PI ASSIGNMENT, FINISHED.
	D[AR] ROT[32.] -OBUS<0 C550 POPJ $
	 ;IF IRP REQUEST NOT ON, JUST RETURN.
];.REPEAT KL
	DEST[CLR-MI-ERR] NORM JPOP[PIGEN] $ 
	 ;CLEAR ERR FF AND GIVE INTERRUPT ON APR CHANNEL.





;; 60 HZ CLOCK READING AND INTERRUPT ROUTINES

 .REPEAT OTP [
  .ORG[2134]		;INTRPT LOC. FOR DEV. 5
CLKINT:	NORM PUSHJ[CLRDEVINT] $ ;Enable addressing of other devices.
	D[CONST 1] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
		;Clear hdwr int. enable for 60HZ clk.
    ]  ;OTP


 .REPEAT NTP [ ;We branch here from CTYINT if intrpt. is really 60HZ CLK.

CLKINT:	START-OUT ALU[0] DEST[IOD] NORM $
	  ;Clear hardware int. enb. for 60HZ CLK.
	MAPF[6] C600 $
  ] ;NTP

.REPEAT TYMNET [
	DEST[CLR-DEV-FROM-INTR] PUSHJ[TYMCLK] C600 $
	  ;Start up TYMNET interface if needed.
];TYMNET
	DEST[CLR-DEV-FROM-INTR] JUMP[APRCHK] C600 $ 	
	  ;Cause PI on APR channel if enabled, and exit.

CLKRDFLG:  ;Put hardware 60HZ CLK FLAG into AR35.
	START-IN D[CONST 6] DEST[DEV-ADR] NORM $
	  ;Select device 6.
	MAPF[5] D[IOD] ROT[34. + 1] MASK[1] DEST[AR] CYLEN[IOB-IN] POPJ $
	  ;Get bit and return.





.REPEAT NTP [ ;Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
.REPEAT 1 - TAPE [
.INSERT CFKNYD.SLO
];.REPEAT 1 - TAPE
.REPEAT TAPE [ ;NEW (DMA TAPE CONTROLLER, PERTEC COMPATIBLE FMTR )
.INSERT TAPE.SLO
];.REPEAT TAPE
  ] ;NTP




.REPEAT KNYTAPE [ ;KENNEDY TAPE CONTROL UCODE
.INSERT CFKNYP.SLO
 ] ;ENDX OF KENNEDY TAPE CODE




.REPEAT TLXTAPE [ ;TELEX TAPE CONTROL UCODE
.INSERT CFTLX.SLO
] ;ENDX OF TELEX TAPE CODE




.REPEAT SLOWTAPE [ ;UCODE FOR BARE 800 BPI TAPE DRIVE
.INSERT CFBARE.SLO
   ] ;END OF SLOW TAPE CODE




.REPEAT 125TAPE [ ;UCODE FOR BARE 800 BPI, 125 IPS TAPE DRIVE
.INSERT CFB125.SLO
] ;END OF SLOW 125 IPS TAPE CODE




;TAPE DISPATCH

 .REPEAT 1 - XUCODE [ ;If we have extended ucode memory, these are different.

.OPCODE[725]	;TAPE IOTS

;725 - Obsolete version of read (no word count, E = core address.)
	D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPERD] $
	 NOP $
;726 - MTAPE
	D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPEMT] $	
	 NOP $
;727 - READ STATUS
	D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPERS] $	
	 NOP $
;730 - READ 1 RECORD, STORE UP TO (AC) WORDS STARTING E.
	D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPENR] $
	 NOP $
;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
	D[CONST 7] DEST[DEV-ADR] NORM COND[USER] JUMP[UTAPWR] $
	 NORM JUMP[TAPEWR] $
;732 - READ 1 record, store up to E words starting at (AC).
	D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPERX] $
	 NOP $
  ] ;1 - XUCODE


 .REPEAT XUCODE [ ;If we don't have extended ucode memory, these are different.

.OPCODE[725]	;TAPE IOTS

;725 - Obsolete version of read (no word count, E = core address.)
	GETADR[TAPERD] JUMP[TAPDSP] $
;726 - MTAPE
	GETADR[TAPEMT] JUMP[TAPDSP] $
;727 - READ STATUS
	GETADR[TAPERS] JUMP[TAPDSP] $
;730 - OBSOLETE ! --read 1 record, store up to (AC) words starting at E.
	GETADR[TAPENR] JUMP[TAPDSP] $
;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
	GETADR[TAPEWR] JUMP[TAPDSP] $
;732 - READ 1 record, store up to E words starting at (AC).
	GETADR[TAPERX] JUMP[TAPDSP] $

  ] ;XUCODE

.RELOC

TAPDSP:	D[CONST 7] DEST[DEV-ADR] COND[-USER] JUMP[GOHIGH] $
	 ;Load device code for tape, test for user mode.
	UIOTRP[MUUO] $
	 ;In user mode-- trap unless IOT USER

GOHIGH:	 ;Jump into high part of umemory, using 12-bit addr. in Q
	D[CONST (XUCODE * 10) + 2] ROT[9.] ALU[D+1] C600 SDISP $
	  ;This takes us to loc. 2001 and pre-sets the 10000 bit.
 .ORG[2001]
	D[CONST XUCODE] ROT[12.] ALU[DORQ] SDISP $
	  ;This finally takes us to loc. 10000+[Q] 

 .RELOC

  .REPEAT XUCODE [
.USE[HIGHMEM] $
     ]

 .PAIR
HIGHSMAIN:
	D[MEM] ACSEL[MA] DEST[AC] NORM JUMP[GOMAIN] $
	NORM JUMP[GOMAIN] $

GOMAIN:	GETADR[MAIN]  $	;Do extended mode jump to MAIN.

GOLOW:	 ;Jump to loc. in lower 4K indicated by contents of Q.

   .REPEAT XUCODE [
	ALU[0] C600 SDISP $
	 ;This goes to loc. 10000 and pre-clears the 10000 bit.
 .ORG[10000]
   ] ;XUCODE

	C600 ALU[Q] SDISP $
	 ;Now we actually go to low u-mem.

.USE[OTHER]







;------------------------------------------------------------------------------
;
;	FooVision
;
;------------------------------------------------------------------------------
.REPEAT VID [
.INSERT VID.SLO
];VID
	.OPCODE[766]
.REPEAT ((1 - VID) * (773 - 766 + 1)) [
	ILGIOT $			;OPS 766:773
	NOP $
];1-VID
.REPEAT VID [
	ILGIOT $			;OP 766 = illegal (reserved)
	NOP $
	GETADR[VIDDPA] JUMP[GOHIGH]$	;OP 767 = DPYADD
					;Note: GETADR expands to 2 words
	FIXM2$				;OP 770 = VIDIN
	D[CONST 36] DEST[DEV-ADR] JUMP[VIDIN]$
	FIXM1$				;OP 771 = VIDOUT
	D[CONST 36] DEST[DEV-ADR] JUMP[VIDOUT]$
	GETADR[VIDDPI] JUMP[GOHIGH]$	;OP 772 = DPYINI
					;Note: GETADR expands to 2 words
	GETADR[VIDDPO] JUMP[GOHIGH]$	;OP 773 = DPYOUT
					;Note: GETADR expands to 2 words
];VID
	.RELOC






;FLOATING POINT, KA10 STYLE.
;NONDISPATCH CODE.
.DEFINE CFPLOW[] [D[AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]
.DEFINE JINSEXP[] [D[AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]
.DEFINE CINSEXP[] [D[AR] ROT[27.] DEST[Q] PUSHJ[INSEX1] NORM ]
.DEFINE CFDS[] [D[MEM] ALU[D#AC] DEST[AR] PUSHJ[FDS1] NORM]

;***** DON'T USE A-MEM 0 FOR ANYTHING BESIDES DISPATCHES!!!	TVR-Sep80  *****
;***** This must be fixed!!!!					TVR-Sep80  *****
UFA1:	ALU[AC] DEST[0 AR] DEST-A-MEM PUSHJ[FADSUB] NORM $
	D[10] DEST[AR O_AC] SHORT $
	D[AR] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] $

	.PAIR	;: 6460		;.PAIR
DFN1:	ALU[NOTAC] DEST[AC] JUMP[. + 2] NORM $
	ALU[0-AC] DEST[AC] SHORT $
	D[MEM] DEST[Q] SHORT $
	D[MASK 9] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
	D[AR] MASK[27.] ALU[DORQ] DEST[MEMSTO] MEMSTMA $

FSCZAP:	ALU[0] DEST[MA AC] SPEC[MA_PC] JUMP[MAIN1] NORM $
FSC1:	D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
	D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AC] COND[-OBUS<0] JUMP[FSC2] C550 $
	D[MASK 9] ALU[D#Q] DEST[Q AR] SHORT $
	D[MASK 8] ROT[27.] ALU[DORAC] DEST[AC] SHORT $
FSC2:	D[MA] MASK[18.] ALU[D+Q] DEST[IR-ADR] SHORT $
	ALU[0] DEST[Q] PUSHJ[NRMLIZ] NORM $
	CINSEXP $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

FAOS1:
FAOS5:
	ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
FAOS2:	ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	CFPLOW $
FAOS3:	ALU[AC] DEST[AR] NORM $
	D[CONST 11] DEST[DEV-ADR] SHORT $
	ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FADSUB] NORM $
	D[10] DEST[MEMSTO O_AC] MEMST $
FAOS4:	ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	ALU[AC] DEST[MEMSTO] MEMST $

FMP1:
FMP5:
	ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
FMP2:	ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	CFPLOW $
FMP3:	ALU[AC] DEST[AR] NORM $
	D[CONST 11] DEST[DEV-ADR] SHORT $
	ALU[AC] DEST-A-MEM PUSHJ[FM] DEST[0] NORM $
	D[10] DEST[MEMSTO O_AC] MEMST $
FMP4:	ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	ALU[AC] DEST[MEMSTO] MEMST $

;Macro to test for divide by zero
.DEFINE DIVTST[] [D[MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]

;;;FD5:	D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $	;Not needed.  TVR-Apr80

;FDV,FDVR
FD1:	DIVTST $	;Check for divide by zero
	CFDS $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

;------------------------------------------------------------------------------
;LONG MODE FLOATING DIVIDE.
;------------------------------------------------------------------------------
FD2:	DIVTST $
 ;AR.0,IR.35:=XOR(DIVIDEND SIGN,DIVISOR SIGN).
	D[MEM] ALU[D#AC] DEST[AR] SHORT $
	D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
 ;Flush sign & exponent from Dividend Low
	D[MASK 27.] ALU[D&AC] ACSEL[AC+1] DEST[AR] SHORT $
	D[AR] ROT[9] DEST[AC] ACSEL[AC+1] SHORT $
 ;Positive form of Dividend to AC, AR; original form to AMEM[1]
	ALU[AC] DEST[AR 1] DEST-A-MEM COND[-OBUS<0] JUMP[FD2A] CYLEN[C450] $
	ALU[0-AC] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[. + 2] C550 $
	ALU[NOTAC] DEST[AC AR] JUMP[. + 2] SHORT $
	ALU[0-AC] DEST[AC AR] NORM $
FD2A:	D[CONST 1] ROT[27.] ALU[AC+D] DEST[AR] NORM $
	 ;Add 1 to exp. of dividend, since we will do only a 27-bit divide.
	ALU[AC] ACSEL[AC+1] DEST[6] DEST-A-MEM NORM $
	 ;Put low-order mantissa in AMEM[6] for FD.
	D[CONST 27.] LLOAD NORM $ 
	 ;Do only a 27-bit divide, so remainder will come out right.
	PUSHJ[FD] NORM $	
	 ;Perform the divide (returns: AC=quotient, AMEM[6]=remainder)
 ;AC+1 gets 0 if remainder = 0.
	D[16] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[FD2D] C550 $
 ;Calculate exponent of remainder.
	D[11]  DEST[Q] C550 -OBUS<0 JUMP[. + 3] $
	 ;Check sign of dividend, jump if positive.
	 ALU[0-Q] DEST[1] DEST-A-MEM NORM $
	  ;Negate the dividend (so the exponent will be in pos. form)
	 ACSEL[AC+1] ALU[0-AC] DEST[AC] NORM $
	  ;Negate the remainder.
	D[11] ROT[9.] MASK[8] DEST[Q] NORM $
	 ;Recover exp. of dividend.
 ;A-MEM[7] has (dividend HOW)-(divisor).
	D[17] COND[-OBUS<0] JUMP[. + 2] C550 $
	 D[CONST 1] ALU[Q-D] DEST[Q] SHORT $
	D[CONST 26.] ALU[Q-D] DEST[Q] COND[OBUS18] JUMP[FD2C] C600 $
	 ;Jump if exponent underflow.
.DEFINE SWAPAC[] [ ;Interchange (AC) and (AC+1)
	ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
	D[AR] DEST[AR O_AC] SHORT $
	D[AR] ACSEL[AC+1] DEST[AC] SHORT $
  ]

 ;SWAP QUOTIENT (AC) AND REMAINDER (AC+1)
	SWAPAC
 ;INSERT EXPONENT INTO REMAINDER.
	ALU[Q] DEST[AR] PUSHJ[INSEXP] NORM $
	SWAPAC
FD2D:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

FD2C:	ALU[0] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

FD3:	DIVTST $
	ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FDS] NORM $
	D[10] DEST[MEMSTO O_AC] MEMST $
FD4:	DIVTST $
	CFDS $
	ALU[AC] DEST[MEMSTO] MEMST $

;HERE ON DIVISOR=0.  SET NO DIVIDE, OVF,FLOV,RETURN.
FPNDIV:	D[PC] DEST[Q] SHORT $
	D[CONST 1] ROT[23.] ALU[DORQ] DEST[Q] PUSHJ[SETFOV] NORM $
	DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

;------------------------------------------------------------------------------
;NORMALIZE DOUBLE PRECISION NUMBER IN AC,Q WHOSE EXPONENT
; IS IN IR-ADR.  LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.
; IF NUMBER IS 0, LEAVE 0 IN AR,AC, AND Q.
;------------------------------------------------------------------------------
.DEFINE CNORM[] [D[AR] DEST[AC] PUSHJ[NRMLIZ] NORM]

;A. Return immediately if 0.
NRMLIZ:	ALU[QORAC] DEST[AR] COND[OBUS=0] POPJ C550 $
;B. Check for mantissa overflow, move exponent to AR.
	ALU[AC] DEST[AR] PUSHJ[NORMOV] NORM $
		;Check mantissa and shift right if necessary
	D[IR] MASK[18.] COND[-OBUS=0] POPJ C550 $
		;If we adjusted right, then we definitely don't have to
		;shift left.  We're done here.
;C. Left shift until normalized.
	ALU[AC] COND[OBUS<0] JUMP[NEGNOR] CYLEN[C450] $
		;Separate into two cases, positive and negative
POSNOR:	D[CONST 1] ROT[26.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
		;If high order bit of mantissa is one, we're done
	D[AR] ALU[D-1] DEST[AR] SHORT $
		;Decrement the exponent
	ALU[SH-AC] MASK[2] DEST[D6] JUMP[POSNOR] NORM $
		;Shift left and try again.
NEGNOR:	D[CONST 1] ROT[26.] ALU[D&AC] COND[OBUS=0] JUMP[NN1] C550 $
		;If high order bit of mantissa is zero, we're done
	D[AR] ALU[D-1] DEST[AR] SHORT $
		;Decrement the exponent
	ALU[SH-AC] MASK[2] DEST[D6] JUMP[NEGNOR] NORM $
		;Shift left and try again.
NN1:	D[MASK 27.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
		;Check for case of exactly -(2^n).  If it isn't, we're done
	D[CONST 1] ROT[26.] ALU[DORAC] DEST[AC] SHORT $
		;We went one too far, backup by simply OR'ing in the relevant
		;bit in the same manner as shifting would. 
		;(*** What about Q??  TVR-Jul80)
	D[AR] ALU[D+1] DEST[AR] POPJ NORM $
		;Increment exponent to account for simulated left shift.

;------------------------------------------------------------------------------
;CHECK FOR MANTISSA OVERFLOW INTO EXPONENT FIELD.  CALL WITH
; AR&AC,Q: # TO NORMALIZE, IR-ADR: ITS EXPONENT.
; LEAVE EXPONENT IN AR.  SET IR-ADR=0 IF NO OVERFLOW.  SET IR-ADR<>0
; IF OVERFLOW, AND NORMALIZE.
;
;M.O. <=> [AR0<>AR8] OR [(AR8=1) AND (AR9-35=0)]
;------------------------------------------------------------------------------
NORMOV:	D[AR] ROT[8] ALU[D#AC] COND[OBUS<0] JUMP[NOVYES] C550 $
		;Check to make sure AR<0>=AR<8>.  If they don't, the mantissa
		;clearly overlaps the exponent field.
	D[MASK 27.] ALU[D&AC] COND[-OBUS=0] JUMP[NOVNO] C550 $
		;Check for AR<9:35> for zero.  If not zero, we're OK
	D[CONST 1] ROT[27.] ALU[D&AC] COND[OBUS=0] JUMP[NOVNO] C550 $
		;Check AR<8>.  If zero, we're OK
;	\ /
;Mantissa has overflowed, adjust it.  Right by one should be enough.
NOVYES:	ALU[SH-AC] MASK[1] DEST[D4] SHORT $
		;Shift mantissa right (i think?)
	D[IR] MASK[18.] ALU[D+1] DEST[AR IR-ADR] POPJ NORM $
		;Increment mantissa and flag that we changed it by setting
		;IR<18:35> to be non-zero.

;Mantissa has not overflowed.
NOVNO:	D[IR] MASK[18.] DEST[AR] SHORT $
		;Save exponent in AR
	ALU[0] DEST[IR-ADR] POPJ NORM $
		;Zero IR<18:35> to signify success

;------------------------------------------------------------------------------
;INSERT EXPONENT IN AR INTO WORD IN AC.
;SET FLOV,FLUN,OVF FLAGS AS REQUIRED.
;PRESERVES AR, CLOBBERS Q.
;------------------------------------------------------------------------------
INSEXP:	D[AR] ROT[27.] DEST[Q] NORM $
		;Move exponent into position
INSEX1:	D[MASK 8.] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
		;Flush stuff in mantissa area
	ALU[Q#AC] DEST[AC] SHORT $
		;Fill in exponent (complementing it if (AC) is negative !)
	D[AR] COND[OBUS18] JUMP[EXPUF] C550 $
		;Check for underflow (i.e. below range of exponent offset)
	D[AR] MASK[10.] ROT[28.] COND[OBUS=0] POPJ C550 $
		;Check for overflow (i.e. above range of exponent offset)
	D[PC] DEST[Q] SHORT $
		;Setup to set floating overflow
SETFOV:	D[CONST 11] ROT[32.] ALU[DORQ] DEST[CRYOV] POPJ NORM $
		;Turn on overflow and floating overflow
EXPUF:	D[PC] DEST[Q] SHORT $
		;Setup to set no divide and floating overflow
	D[CONST 1] ROT[24.] ALU[DORQ] DEST[Q] JUMP[SETFOV] NORM$
		;Turn on no divide, then do overflows

;------------------------------------------------------------------------------
;FLOATING ADD AC&AR TO MEM.  RESULT, NORMALIZED AND ROUNDED
; IF REQUIRED IN AC,Q.
;------------------------------------------------------------------------------
.DEFINE BLEXPS[DES1 TIME DES2] [
	D[MASK 8] ROT[27.] ALU[DORAC] DEST[DES2] COND[OBUS<0] JUMP[. + 2] C550 $
	D[MASK 8] ROT[27.] ALU[-D&AC] DEST[DES2] SHORT $
	D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
	D[MASK 8] ROT[27.] ALU[-D&Q] DEST[DES1] JUMP[. + 2] NORM $
	D[MASK 8] ROT[27.] ALU[DORQ] DEST[DES1] CYLEN[TIME] $
];BLEXPS
	;A. + FORM EXPONENT OF AC,MEM RTO AR,Q RESP.
FADSUB:	D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
FADSU1:	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS1] C550 $
	D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
FS1:	D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS2] C550 $
	D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
	;B. COMPUTE DIFFERENCE, SWAP OPRANDS IF AC HAS LARGER EXP.
	;   LEAVE + DIFFERENCE IN Q, DIFF -1 IN LOOP CTR.
	;   LEAVE LARGER EXPONENT IN IR-ADR.
FS2:	ALU[Q] DEST[IR-ADR] SHORT $
	D[AR] ALU[Q-D] DEST[Q] COND[-OBUS<0] JUMP[FS3] C600 $
	D[AR] DEST[IR-ADR] SHORT $
	D[MEM] DEST[HOLD O_AC] NORM $
	ALU[0-Q] DEST[Q] NORM $
FS3:	ALU[Q-1] DEST[AR] LLOAD NORM $
	;C. BLANK EXPONENTS.
	BLEXPS[HOLD NORM AC]
	;D. IF DELTA EXPONENTS >62., AC GOES TO OBLIVION.
	D[AR] ALU[D+1] DEST[Q] COND[OBUS=0] JUMP[FS5] C600 $
	D[CONST 63.] ALU[Q-D] COND[OBUS<0] JUMP[FS4] C600 $
	ALU[0] DEST[AC] SHORT $
	ALU[0] DEST[Q] JUMP[FS5] NORM $
FS4:	ALU[0] DEST[Q] SHORT $
	ALU[SH-AC] DEST[D4] MASK[1] LOOP [.] NORM $
	;E. ADD.
FS5:	D[MEM] ALU[D+AC] DEST[AR] SHORT $
	;F. NORMALIZE RESULT.
	D[IR] DEST[AC] SHORT $	;CHECK FOR UFA
	D[CONST 1] ROT[40] ALU[D&AC] COND[OBUS=0] JUMP[UFANOR] C550 $

;------------------------------------------------------------------------------
;ENTER HERE WITH RESULT IN AR,Q, EXP IN IR-ADR.
;------------------------------------------------------------------------------
FPNAR:	CNORM $				;NOPE, NORMALIZE
;(Calls NRMLIZ which changes register usage from above and adjusts various
;things.  "LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.")
;G. ROUND IF NECESSARY, INSERT EXPONENT INTO HIGH ORDER WORD OF RESULT.
	ALU[Q] COND[-OBUS<0] DEST[HOLD] JUMP[NORND] CYLEN[C450] $
		;Save Q in HOLD (i.e. MEM)
		;If Q<0> is zero, don't round
	D[IR] DEST[Q] NORM $
		;Get Q so we check bit meaning rounding (??? Can't this be
		;done with D[IR] ROT[7] COND[OBUS<0]... ???)
	D[CONST 1] ROT[35] ALU[D&Q] COND[OBUS=0] JUMP[NORND] C550 $
		;Check opcode to see if rounding is requested.
		;If not, we're done
	D[MEM] DEST[Q] SHORT $
		;Restore Q
	D[MASK 43] ALU[D&Q] COND[-OBUS=0] JUMP[YESRND] C550 $
		;Round if Q<1:35> is non-zero (? what does this signify???)
	ALU[AC] COND[OBUS<0] JUMP[INSEXP] CYLEN[C450] $
		;If mantissa is negative, we don't round (???)
;	\ /
YESRND:	D[AR] DEST[IR-ADR] SHORT $
		;Setup IR for NRMLIZ
	ALU[AC+1] DEST[AC] PUSHJ[NRMLIZ] NORM $
		;Increment high order word and normalize once more (???)
	JINSEXP $
		;Now stick in exponent
;	---
NORND:	D[MEM] DEST[Q] JUMP[INSEXP] NORM $
		;Restore Q and insert exponent(?)

;UFA NORMALIZATION -- ONLY ON MANTISSA OVERFLOW.
UFANOR:	D[AR] ALU[DORQ] DEST[AC] COND[OBUS=0] POPJ C600 $
	D[AR] DEST[AC] PUSHJ[NORMOV] NORM $
	JINSEXP $
;	---

;------------------------------------------------------------------------------
;SETUP LOW ORDER FP RESULT, STORE BOTH IN AC,AC+1
;ENTER WITH LOW WORD IN MEM, HIGH WORD IN AC, HIGH
;WORD'S EXPONENT IN AR&AC+1.
;------------------------------------------------------------------------------
FPLOW:	D[CONST 27.] ACSEL[AC+1] ALU[AC-D] DEST[AC AR] SHORT $
	D[CONST 1] ROT[7] ACSEL[AC+1] ALU[D&AC] COND[-OBUS=0] JUMP[ZLOW] C550 $
	D[MEM] ROT[27.] MASK[27.] DEST[Q] COND[OBUS=0] JUMP[ZLOW] C550 $
	D[AR] ROT[27.] ACSEL[AC+1] DEST[AC] SHORT $
	D[MASK 8] ROT[27.] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
	ACSEL[AC+1] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
ZLOW:	ACSEL[AC+1] ALU[0] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

;------------------------------------------------------------------------------
;
;	FLOATING MULTIPLY.  AC&AR BY MEM.
;
;*** This code produces non-zero results if MEM=-1.0 and AC=0  !!!    TVR-Jun80
;------------------------------------------------------------------------------
;A. SUM OF + FORM EXPONENTS -128.+1 TO IR-ADR.  +1 BECAUSE 28
; STEPS ARE USED TO PROVIDE ONE GUARD DIGIT.
FM:	D[AR] MASK[9] ROT[9] DEST[Q AR] NORM$
		;Extract the exponent from AC (which was copied into AR)
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM1] C550 $
		;Check sign bit of number.  Nothing special if positive
	D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
		;Sign is negative, we want the one-complement of the exponent
		;field to get the actual exponent.
FM1:	D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
		;Extract the exponent from MEM
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM2] C550 $
		;Check sign bit of number.  Nothing special if positive
	D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
		;Sign is negative, we want the one-complement of the exponent
		;field to get the actual exponent.
FM2:	D[AR] ALU[D+Q] CARRY DEST[Q] SHORT $
		;Add the two exponents
		;+1. FOR GUARD DIGIT.
	D[CONST 1] ROT[7] ALU[Q-D] DEST[IR-ADR] SHORT $
		;Account for exponent bias.  Put exponent in a safe place.
;B. BLANK EXPONENTS.
	BLEXPS[Q SHORT AR]
		;Extend the sign to blank out the exponent field.  We will
		;now have perfectly good integers here, of 27 bit magnitude
		;(assuming that the numbers were normalized to begin with).
	ALU[0] DEST[AC] PUSHJ[TESMUL] NORM $ ;28. STEPS.
;;;	ALU[Q] DEST[AR] SHORT $	;FLUSH SIGN IN LO WD.
	D[MASK 7] ALU[-D&Q] DEST[Q AR] SHORT $	;FLUSH SIGN IN LO WD.
		;Flush remenants of multiplier in low order part of
		;word.  MASK field determined empirically (35-28???)
	D[AR] ALU[D+Q] DEST[Q] SHORT $
		;Make low order word unsigned.
	ALU[AC] DEST[AR] JUMP[FPNAR] NORM $

;28. STEP INTEGER MULTIPLY FOR USE BY FM.
TESMUL:	D[CONST 27.] LLOAD NORM $	;LOOP 28 TIMES
	JUMP[DOMUL1] NORM $	;TEST.

;------------------------------------------------------------------------------
;SHORT STYLE FLOATING DIVIDE AC BY MEM.
; XOR OF DIVISOR&DIVIDEND SIGNS IN AR BIT 0.
;------------------------------------------------------------------------------
FDS:	D[MEM] ALU[D#AC] DEST[AR] SHORT $
FDS1:	D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
	ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[. + 2] C550 $
	ALU[0-AC] DEST[AC AR] SHORT $
	ALU[0] DEST[6] DEST-A-MEM NORM $
	D[CONST 28.] LLOAD NORM $ 
		;Do only a 28-bit divide.

;------------------------------------------------------------------------------
;	Floating Divide
;
; DIVIDEND HIGH ORDER WORD IN AR, LOW IN A-MEM[6]. DIVISOR IN MEM.
; BOTH IN POSITIVE FORM.  IR.35=XOR(DIVIDEND SIGN,DIVISOR SIGN).
;------------------------------------------------------------------------------
FD:
;A. PUT DIVISOR IN + FORM, GET DIVISOR EXPONENT.
;.1 Shuffle IR.35 into A-MEM[4].
	D[IR] MASK[18.] DEST[4] DEST-A-MEM NORM $
		;Save IR-ADR in A-MEM
	D[MEM] DEST[Q] COND[-OBUS<0] JUMP[. + 2] C550 $
		;Check for negative divisor
	D[MEM] ALU[0-D] DEST[Q HOLD] NORM $
		;Negate divisor
	D[MEM] ROT[9] MASK[8] DEST[IR-ADR] NORM $
		;Extract exponent from divisor, store in IR<18:35>
	D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] NORM $
		;Extract mantissa from divisor
;B. Fetch and blank HOW Dividend exponent.
	D[AR] ROT[9] MASK[8] DEST[Q] NORM $
		;Extract dividend exponent.
	D[AR] MASK[27.] DEST[AC] SHORT $
		;Extract mantissa from dividend
;C. Compute resultant exponent.
	D[IR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $
		;Subtract divisor exponent from dividend exponent
	D[CONST 1] ROT[7] ALU[D+Q] DEST[IR-ADR] NORM $
		;Include exponent offset
;D. Move LOW Dividend to Q.
	D[16] DEST[Q] SHORT $
;E. If divisor<=dividend,  shift dividend right, increment the
	; resultant exponent.  save diff. in A-MEM[7] for long mode.
	D[MEM] ALU[AC-D] DEST[7] DEST-A-MEM COND[-OBUS<0] JUMP[FDAD] C600 $
;F. Save exp in A-MEM[5]
FDSHFT:	D[IR] DEST[5] DEST-A-MEM NORM $
	PUSHJ[DODIV4] NORM $	
	 ;Do the divide. Result DOES NOT have signs adjusted.
;G. Save remainder in A-MEM[6], put quotient in AC, AR; put 0 in Q.
	ALU[AC] DEST[6] DEST-A-MEM NORM $
	ALU[Q] DEST[AC AR] SHORT $
	ALU[0] DEST[Q] SHORT $
;H. Prepare to round 28. bit result.
	ALU[SH-AC] MASK[1] DEST[D4] SHORT $
	 ;Shift AC,Q rt 1 bit
	D[15] ALU[D-1] DEST[IR-ADR] NORM PUSHJ[FPNAR] $	
	 ;Move exp for FPNAR, normalize and insert exponent into quotient.
	D[14] MASK[1] C550 OBUS=0 POPJ $
	 ;Done if positive result.
	ALU[0-AC] DEST[AC] NORM POPJ $
	 ;Negate quotient.
;------------------------------------------------------------------------------
;HERE WHEN DIVIDEND IS >= DIVISOR.  SHIFT DIVIDEND RIGHT
; AND INCREMENT RESULTANT AC.  THIS WILL ALLOW DIVIDE TO
; SUCCEED IF BOTH DIVISOR & DIVIDEND WERE NORMALIZED
; AND DIVISOR <> 0.
;------------------------------------------------------------------------------
FDAD:	ALU[SH-AC] MASK[2] DEST[D4] SHORT $
	D[IR] MASK[18.] ALU[D+1] DEST[IR-ADR] JUMP[FDSHFT] NORM $





;ADJSP1 ADJSP2 DMOVE2 DMOVN2 DMOVM2 DMVNM2 DMVNM3 DMVNM4 DMVNM5 KAFIXP KAFIXN FIXR1 KIFIX1 FIXRN KIFIXN FIXER FIXER1 FIXER2 FIXER3
;
;Strays from KI instructions
;

.REPEAT XUCODE [
 .USE[AREA50]  ;Squeeze this stuff into the space vacated by MBOOT.
    ]

;(ADJSP continued)
;Left result is negative.  Check right side.
ADJSP1:	D[IR] MASK[22] ALU[D+AC] DEST[AR] NORM $
		;Add right half
	D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
		;Isolate left half
	D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] NORM $
		;Merge halves and store
	D[IR] COND[-OBUS18] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
		;If E was positive, it wasn't an overflow (just a bad idea)
		;Start fetching next instruction
	D[AR] COND[OBUS<0] JUMP[MAIN] C550 $
		;If original was negative, we're OK.  Start doing next
		;instruction if no sign changed in left half
	JUMP[PDLO6] NORM $
		;ADJSP got a PDLOV
;ADJSP left result positive
ADJSP2:	D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
		;Isolate left half
	D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] $
		;Merge halves and store
	D[IR] COND[OBUS18] SPEC[MA_PC] DEST[MA] C550 $
		;If E was negative, it wasn't an overflow (just a bad idea)
		;Start fetching next instruction
	D[AR] COND[-OBUS<0] JUMP[MAIN1] C550 $
		;If original was positive, we're OK.  Start doing next
		;instruction if no sign changed in left half
	JUMP[PDLO6] NORM $
		;ADJSP got a PDLOV

;(DMOVE continued)
DMOVE2:	D[MA] ALU[D+1] DEST[MA] NORM $	;Fetch second word
	FIXM1 $			;Complete fetch
	ACSEL[AC+1] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
		;Put it in the second AC and start next instruction

;(DMOVN continued)
DMOVN2:	D[MA] ALU[D+1] DEST[MA] NORM $	;Fetch second word
	FIXM1 $	;Complete fetch
	ACSEL[AC+1] D[MEM] ALU[0-D] DEST[AC MA] SPEC[MA_PC] CYLEN[FIXM+1] $
		;Negate low order word and put it in the second AC
		;Start next instruction fetch (Note that DEST[MA] is
		;really associated with SPEC[MA_PC])
		;*** Is FIXM+1 really the right thing???
	ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&AC] DEST[AC]
			COND[-OBUS=0] JUMP[MAIN1] NORM $
		;Clear stupid bit 0.
		;If the low order part is non-zero, we're done
	ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] JUMP[MAIN1] C550 $
		;Increment high order word and we're finally done.

;(DMOVEM continued)
	.PAIR
DMOVM2:	CYLEN[MEMSTO] ACSEL[AC] D[MEM] DEST[AC] NORM $
		;Write it also in the AC
	CYLEN[MEMSTO] D[MA] ALU[D+1] DEST[MA] $
		;Setup to write second word
	ACSEL[AC+1] ALU[AC] DEST[MEMSTO] MEMST $
		;Write secord word.

;(DMOVNM continued)
DMVNM2:	ACSEL[AC+1] ALU[0-AC] DEST[Q] SHORT $
		;Negate low order word.
	ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&Q] DEST[Q]
			COND[-OBUS=0] JUMP[DMVNM4] NORM $
		;Clear stupid bit 0.
		;If the low order part is non-zero, no change needed to
		;high order word.
	D[AR] ALU[AC+1] DEST[AR STRT-WRT] SPEC[CRYOV]
		COND[-MA-AC] JUMP[DMVNM5] NORM $
		;Increment high order word and start first store
DMVNM3:	ACSEL[MA] D[MEM] DEST[AC] JUMP[DMVNM5] $
		;Store is to an AC, write into 2901.
DMVNM4:	DEST[STRT-WRT] COND[MA-AC] JUMP[DMVNM3] $
		;Start first store.  Jump if to an AC
DMVNM5:	D[MA] ALU[D+1] DEST[MA] NORM $
		;Finish write.  Note that due to FIXM2, we don't have to
		;worry about map faults.
		;Prepare for secord write
	ALU[Q] DEST[MEMSTO] MEMST $
		;Do final write (low order word into (E+1))

;KAFIX (Opcode 247) continued
;Positive number to fix
KAFIXP:	D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
		;Extract exponent adjustment factor and do fixing
	ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Put result into AC and we're done
;Negative number to fix
KAFIXN:	D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
		;Extract exponent adjustment factor and do fixing
;;;	ACSEL[AC] D[MASK R] ALU[D/#Q] DEST[AC MA]	;*** Assembler loses!
	ACSEL[AC] D[2] MASK[R] ALU[D/#Q] DEST[AC MA]	;Sigh...
			SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Put sign extended result into AC and we're done

;(FIXR continued)
FIXR1:	D[MEM] COND[OBUS<0] JUMP[FIXRN] C550 $
		;Round different directions
	D[CONST 20] ROT[30.] ALU[D+Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
		;Positive. Finish making constant 0.5 and add it
	D[CONST 33] DEST[Q] SHORT $
		;Start making magic constant
	ALU[AC] DEST[AR HOLD] JUMP[FIXR2] NORM $
		;Setup for FIXER.  Rest is same as KIFIX
;	---
FIXRN:	D[CONST 60] ROT[30.] ALU[D-Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
		;Negative. Finish making constant -0.5 and add it
	D[CONST 33] DEST[Q] SHORT $
		;Start making magic constant
	D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
		;Finish making magic constant
	ALU[0-AC] DEST[AR HOLD] PUSHJ[FIXER] NORM $
		;Setup for FIXER
	ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Negate it back again and start next instruction
;	---
;(KIFIX continued)
KIFIX1:	D[MEM] DEST[AR] COND[OBUS<0] JUMP[KIFIXN] C550 $
		;Load up things for FIXER, check for positive mantissa
FIXR2:	D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] PUSHJ[FIXER] NORM $
		;Finish making magic constant and do fix.
	ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Put result into AC and we're done
;	---
;	---
KIFIXN:	D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
		;Finish making magic constant
	D[MEM] ALU[0-D] DEST[HOLD AR] PUSHJ[FIXER] NORM $
		;ABS to both MEM and AR.  Fix the number
	ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Negate it back again and start next instruction


;Fix a number (without sign extension) in MEM, AR=ABS(MEM), Q=magic number
;(233 for normal fix)
FIXER:	D[AR] ROT[9] MASK[9] ALU[D-Q] DEST[ROTR Q]
			COND[OBUS<0] JUMP[FIXER2] C550 $
		;Calculate number of positions to move
		;Jump if we'll be shifting right (n<2^26)
	D[CONST 27.] ALU[D+Q] DEST[MASKR] NORM $
		;Construct appropriate mask
	D[MEM] MASK[27.] DEST[HOLD] NORM $
		;Flush exponent, our mask won't reach.
	D[CONST 9.] ALU[Q-D] COND[OBUS<0] JUMP[FIXER1] C550 $
		;Check for overflow
;;; Set overflow here.  What kind?  (We can live without it for KAFIX, since it
;;; never did check, but when KIFIX is done, this will have to be corrected.)
	D[CONST 1] ROT[35.] ALU[Q] PUSHJ[QORCRY] NORM $
		;Set overflow flag.
	D[CONST 44] DEST[MASKR] NORM $
		;For those losers who want to see some of the number...
;Now that we know how much to shift things, do it and return.
FIXER1:	D[MEM] ROT[R] MASK[R] DEST[Q] NORM POPJ $
		;Gee, that was fast.
;Negative, shift count, the easy case.
FIXER2:	D[CONST 27.] ALU[D+Q] DEST[MASKR] COND[OBUS<0] JUMP[FIXER3] $
		;Construct appropriate mask.  If !x!<1, return zero
	D[CONST 36.] ALU[D+Q] DEST[ROTR] JUMP[FIXER1] NORM $
		;Hardware doesn't believe in negative shift counts
;Number is fractional, i.e. shift would go off the end.  Return zero
FIXER3:	ALU[0] DEST[Q MASKR] SHORT POPJ $
		;Just return zero.  Set mask just in case

.REPEAT XUCODE [
  .USE[OTHER]
   ]
;FLTR, continued
FLTR1:	D[CONST 33] DEST[Q] SHORT $
	D[CONST 2] ROT[6] ALU[DORQ] DEST[IR-ADR] NORM $
		;Make magic constant for exponent
	ALU[0] DEST[Q] PUSHJ[FPNAR] $
		;Clear low order word
		;Normalize and round (happens to have same bit on as FxxR)
		;Result goes to AC
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
		;Start next instruction fetch




.REPEAT KL [;ONLY ON KL FOR NOW, NOT ENOUGH SPACE IN 1-KL ASSEMBLY

;ADJBP INSTRUCTION

;AMEM USAGE:

ADJ.AC = 1		;SAVE ORIGINAL AC CONTENTS IN CASE NO DIVIDE
ADJ.ARG = 4		;THIS WILL REMEMBER - NUMBER OF BYTES PAST LAST
			; WORD OF RESULTANT BYTE
BYTE.PTR = 5		;PLACE TO KEEP BYTE POINTER, MEM GETS USED A LOT
BYTE.SIZ = 6		;NOT REALLY NECESSARY, COULD GET SIZE FROM
			; BYTE.PTR, BUT MAKES FOR LESS TYPING
RTRAIL = 7		;TO REMEMBER NUMBER OF WASTED BITS ON
			; RIGHT HAND SIDE OF WORD
	.USE[OTHER]

ADJBP:	FIXM1 $
	D[MEM] ROT[11. + 1] MASK[6] DEST[BYTE.SIZ] SPEC[DEST-A-MEM]
	  COND[OBUS=0] C550 JUMP[ADJSIZ0] $
		;IF SIZE IS ZERO, JUST GO AND STORE POINTER.
		;ALSO SAVE SIZE IN AMEM AND Q FOR LATER.
	D[MEM] DEST[BYTE.PTR] SPEC[DEST-A-MEM] NORM $
		;STORE POINTER INTO AMEM 1 BECAUSE NEED MEM FOR DIVISOR
	ALU[AC] DEST[ADJ.AC] SPEC[DEST-A-MEM] NORM $
		;SAVE ORIGINAL ARG IN CASE WE GET NO DIVIDE.
	D[10 + BYTE.SIZ] DEST[HOLD] NORM $
		;GOING TO DIVIDE BY SIZE, PUT IN MEM.
	D[10 + BYTE.PTR] ROT[35.] MASK[35.] DEST[Q] NORM $
		;PUT P INTO 1-6 OF Q FOR DIVIDE. SH6DIV CLEARS LO ORDER BITS
	ACSEL[AC] ALU[AC] DEST[ADJ.ARG] SPEC[DEST-A-MEM] NORM $
		;MUST CLEAR OUT AC, SO STORE ARG IN AMEM 2
	ALU[0] ACSEL[AC] DEST[AC] PUSHJ[SH6DIV] SHORT $
		;CLEAR OUT HI ORDER DIVIDEND, DIVIDE. REMAINDER
		; COMES BACK IN AC, QUOTIENT IN Q
		;QUOTIENT IS NUMBER OF BYTES IN PART OF WORD TO RIGHT
		;OF CURRENT BYTE, REMAINDER IS NUMBER OF WASTED TRAILING
		;BITS.
	ACSEL[AC] ALU[AC] DEST[RTRAIL] SPEC[DEST-A-MEM] NORM $
		;SAVE NUMBER OF TRAILING BITS IN AMEM FOR LATER.
	D[10 + ADJ.ARG] ALU[Q-D] DEST[Q] NORM $
		;GET NEGATIVE OF NUMBER OF BYTES PAST LAST BYTE OF WORD
		; THAT RESULTANT BYTE SHOULD BE.
	ALU[Q] DEST[ADJ.ARG] SPEC[DEST-A-MEM] NORM $
		;STORE IN AMEM FOR MUCH LATER.
	D[CONST 44] ROT[29.] DEST[Q] SHORT $
		;MUST DIVIDE INTO 36, GET 36 INTO BITS 1-6 FOR SH6DIV.
	D[10 + BYTE.SIZ] DEST[HOLD] NORM $
		;GET 36/S
	ALU[0] ACSEL[AC] DEST[AC] PUSHJ[SH6DIV] SHORT $
		;DO QUICKY DIVIDE. RESULTS:
		;Q/BYTES PER WORD IF THESE BYTES ARE LEFT OR RIGHT ALIGNED.
		;AC/TOTAL NUMBER OF WASTED BITS.

	D[10 + RTRAIL] ALU[D#AC] COND[OBUS=0] C550 JUMP[ALIGND] $
		;JUMP IF ALL WASTED BYTES ARE RIGHT HAND ONES (LEFT ALIGNED.)
	D[10 + RTRAIL] COND[OBUS=0] C550 JUMP[ALIGND] $
		;JUMP IF BYTES ARE RIGHT ALINGED.

;THERE ARE WASTED BITS ON BOTH SIDES OF WORD FOR THESE BYTES.
; MAY HAVE TO DECREMENT BYTES PER WORD BY 1 IF WASTED A WHOLE BYTE WORTH.

	ALU[Q] DEST[AR] NORM $
		;SAVE CURRENT BYTES PER WORD
	D[10 + BYTE.PTR] ROT[6] MASK[6] DEST[Q] NORM $
		;Q/P
	D[CONST 44] ALU[D-Q] DEST[HOLD] SHORT $
		;HOLD/36-P
	D[MEM] ROT[29.] DEST[Q] NORM $
		;Q/36-P POSITIONED IN BITS 1-6 OF Q
	D[10 + BYTE.SIZ] DEST[HOLD] PUSHJ[SH6DIV] NORM $
		;GET INTO HOLD SO CAN DIVIDE BY S.
		;Q/DONT NEED (NUMBER OF BYTES IN LH PART OF WORD INCLUDING CURRENT)
		;AC/NUMBER OF LEADING WASTED BITS
	D[10 + RTRAIL] ALU[D+AC] DEST[AC] NORM $
		;AC/TOTAL NUMBER OF WASTED BITS
	D[10 + BYTE.SIZ] ALU[AC-D] COND[OBUS<0] C550 JUMP[ALIGN0] $
		;IF TOTAL WASTED < SIZE, THEN DON'T HAVE TO ADJUST
	D[AR] ALU[D-1] DEST[HOLD] JUMP[ALIGN1] $
		;ELSE NUMBER OF BYTES PER WORD IS LESS. GET INTO HOLD AND AR

ALIGN0:	D[AR] DEST[HOLD] JUMP[ALIGN1] NORM $
		;GET BYTES PER WORD INTO MEM AND JOIN COMMON CODE.

;HERE IF LEFT OR RIGHT ALIGNED, WITH BYTES PER WORD INTO Q.

ALIGND:	ALU[Q] DEST[HOLD] NORM $
		;MUST DIVIDE BY BYTES/WORD. GET BPW INTO AR AND HOLD

;NOW BYTES PER WORD IN AR AND MEM.

ALIGN1:	D[10 + ADJ.ARG] DEST[Q] PUSHJ[DIVSUB] NORM $
		;DIVIDE THIS BY BYTES/WORD
		;Q/-NUMBER OF WORDS TO ADJUST BY
		;AC/-BYTES TO ADJUST BY.
	D[MEM] COND[OBUS=0] C550 JUMP[ADJNDV] $
		;JUMP IF THIS WAS NO DIVIDE CASE
		; (WE ALLOWED DIVIDE TO GO SO THAT IT WOULD SET PC FLAGS)
	ALU[AC] COND[-OBUS<0] C550 JUMP[REMNOTNEG] $
		;JUMP IF REMAINDER NOT NEGATIVE
	D[MEM] ALU[D+AC] DEST[AC] NORM $
		;NEG REMAINDER MEANS NEXT WORD.
	ALU[Q-1] DEST[Q] SHORT $

; AC/BYTES TO ADJUST BY
; Q/-WORDS TO ADJUST FORWARD BY
REMNOTNEG:
	D[10 + BYTE.PTR] ALU[D-Q] DEST[Q] NORM $
		;ADJUST Y PART OF POINTER
	ALU[Q] DEST[BYTE.PTR] SPEC[DEST-A-MEM] NORM $
		;STORE IT BACK
	ALU[AC] DEST[Q] SHORT $
		;GET BYTES TO ADJUST BY IN Q FOR MULTIPLY
	ALU[0] DEST[AC] SHORT $
		;CLEAR OUT WHERE RESULT WILL BE ACCUMULATED
	D[10 + BYTE.SIZ] ROT[6] DEST[AR] NORM $
		;BYTE SIZE INTO AR 6 BITS UP SO RESULT WINDS UP IN Q
	D[CONST 6] LLOAD NORM $
		;DO 6 BIT MULTIPLY
ADJMUL:	D[AR] ALU[MULAC+D] DEST[D4] MASK[3] LOOP[ADJMUL] NORM $
		;HERE IS WHERE THE MULTIPLY IS DONE.
		;GET C(Q) * C(AR) INTO AC = #BYTES TO BACKUP * BYTESIZE
		;WHICH IS ALMOST WHAT P SHOULD BE
	D[10 + RTRAIL] ALU[D+AC] DEST[AR] NORM $
		;NOW WE HAVE P
	D[10 + BYTE.PTR] MASK[30.] DEST[Q] NORM $
		;GET POINTER WITHOUT P FIELD
	D[AR] ROT[35. - 5.] ALU[DORQ] DEST[AC] JUMP[MAIN] NORM $
		;STORE IT BACK INTO AC WITH P FIELD AND RETURN.

;HERE IF BYTE SIZE OF POINTER IS ZERO, JUST STORE INTO AC AND RETURN.

ADJSIZ0:
	D[MEM] DEST[AC] JUMP[MAIN] NORM $
		;STORE POINTER INTO AC AND RETURN.

;HERE IF BYTES/WORD ARE 0. THIS HAPPENS FOR BYTE SIZES LARGER THAN 36, OR
; BYTE SIZES WITH AN ALIGNMENT SUCH THAT A BYTE OF THAT SIZE WOULD
; NEVER FIT INTO A WORD (I.E. 36 BIT BYTE WITH ANYTHING OTHER THAN 0 ALIGNMENT)

ADJNDV:	D[10 + ADJ.AC] DEST[AC] JUMP[MAIN] NORM $
		;RESTORE ORIGINAL CONTENTS OF AC WHICH IS LONG LOST
		; AND RETURN, NO DIVIDE AND OVERFLOW ARE SET.

;PUSHJ HERE TO DO QUICKY 6 BIT DIVIDES
; ASSUMES NOT DIVIDING BY ZERO.
; ENTER WITH Q/DIVIDENT IN HI ORDER 7 BITS
; MEM/DIVISOR

SH6DIV:	D[MASK 29.] ALU[-D&Q] DEST[Q] SHORT $
		;CLEAR OUT ALL BUT HI ORDER 6 BITS AND THE SIGN BIT
	D[CONST 7] LLOAD $
		;LOOP FOR 6 BITS OF DATA PLUS SIGN BIT
	ALU[0] DEST[AC] JUMP[DODIV4] SHORT $
		;CLEAR OUT AC (HI ORDER DIVIDEND)
		;CALL THE DIVIDE ROUTINE. RETURNS WITH Q/QUOTIENT AND
		; AC/REMAINDER AND THEN RETURNS TO CALLER.

;HERE FOR FULL 36 BIT DIVIDE, MAYBE BY ZERO.
;EXPECTS DIVIDEND IN Q, DIVISOR IN MEM.
;RETURNS QUOTIENT IN Q, REMAINDER IN AC.
;SMASHES AR, IR.

DIVSUB:	ALU[Q] DEST[AR] COND[-OBUS<0] C550 LBJUMP[DIVSB1] $

	.PAIR
DIVSB1:	ALU[-1] DEST[AC] JUMP[. + 2] $
		;DIVIDEND IS NEGATIVE, PUT -1 IN AC
	ALU[0] DEST[AC] SHORT $
		;ITS POSITIVE, PUT 0 IN AC
	D[MEM] ALU[D#AC] DEST[AR] SHORT $
		;XOR OF SIGN BITS IN 1B0 OF AR
	D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
		;XOR OF SIGN BITS GOES INTO 1B35 OF IR
	ALU[Q] DEST[AR] JUMP[DODIV] NORM $
		;COPY OF AC GOES INTO AR IN CASE OF NO DIVIDE.
		;RETURNS QUOTIENT IN Q,
		; REMAINDER IN AC.
];.REPEAT KL





.REPEAT TYMNET [.DEFINE FOOLIST[] [ LIST ] ]
FOOLIST
;.USE[TNDISP] GETS BACK TO 64 WORD AREA WE CAN DISPATCH INTO

  .REPEAT OTP [
TNODIFS = 2	;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
TNIRIFS = 4	;INPUT READY INTERRUPT FF SUBSEL = REQ A.
TYM.LD = 1	;MAPF value for loading output register.
TYM.RD = 0	;MAPF value for reading input register.
  ] ;OTP

  .REPEAT NTP [
TNODIFS = 17	;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
TNIRIFS = 16	;INPUT READY INTERRUPT FF SUBSEL = REQ A.
TYM.LD = 15	;MAPF value for loading output register.
TYM.RD = 5	;MAPF value for reading input register.
  ] ;NTP

.REPEAT TYMNET [

;TYMNET INTERFACE.

;A-MEM USAGE.
; 0: STANDARD. 1: STATE OF OUTPUT FFS (SEE CFTNET)
; 2: OUTPUT COROUTINE ADR (LO 6 BITS)
; 3: INPUT COROUTINE ADR (LO 6 BITS)
; 4: CURRENT -10 WORD BEING OUTPUT (FOR STATE 1 ONLY)
; 5: CURRENT -10 WORD BEING ASSEMBLED ON INPUT (STATE 1)
; 6: IOWD FOR PACKET CURRENTLY BEING READ
; 7: B0-2, STATE OF MAP BEFORE INT; B3-35, INP REG AT INT START

;MAIN MEMORY LOCATIONS:
; 2000/	KEY:	0		;FLAGS
; 2001/ BIOREQ: 0		;USED BY MICROCODE TO INDICATE PENDING BLOCK OUTPUT REQUEST
; 2002/ BIOIOW: 0		;USED BY MICROCODE TO KEEP IOWD FOR CURRENT BLOCK OUTPUT IN PROGRESS
; 2200/	IRING: BLOCK 200	;INPUT (TO HOST) RING
; 2400/ ORING: BLOCK 400	;OUTPUT (FROM HOST) RING
; 2005/ HIRP:  0	;HOST IRING PTR (TAKER)
; 2006/ BIRP:  0	;BASE IRING PTR (PUTTER)
; 2011/ HORP:  0	;HOST ORING PTR (PUTTER)
; 2012/ BORP:  0	;BASE ORING PTR (TAKER)

;DR11C FLAG NAMES.  (FIELD VALUES).
;THE ACTUAL DEFINITIONS ARE IN CFDEF.SLO
;TNODIBN=2	;OUTPUT DONE ROTATE AMOUNT (INPUT) = REQ B.
;TNIRIBN=3	;INPUT READY ROTATE AMOUNT (INPUT) = REQ A.
;TNODOBN=6	;OUTPUT DONE ROTATE AMOUNT (OUTPUT) = CSR1.
;TNODOBNPO=7
;TNIROBN=7	;INPUT READY ROTATE AMOUNT (OUTPUT) = CSR0.
;TNIROBNPO=10
 

.DEFINE TNOCEC[] [ ;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
	D[14] ROT[34] MASK[20] DEST[Q] NORM $
	D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
	ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
	D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
]
.DEFINE GBORP[] [
	D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GHORP[] [
	D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GBIRP[] [
	D[CONST 6] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GHIRP[] [
	D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GBBORQ[] [
	D[CONST 1] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GBBOIO[] [
	D[CONST 2] DEST[Q] PUSHJ[TNRCW] NORM $
]


;HERE TO SERVICE INPUT READY OR OUTPUT DONE INTERRUPT BY
; TYMNET INTERFACE.
	;SAVE MAP STATE IN A-MEM[7].0-2 & TURN MAP OFF.
TNI:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
	D[IR] MASK[3] DEST[AR] MAPF[10] CYLEN[IOB-OUT] $	;MAPOFF NEEDS MAPF, CYLEN.
	D[AR] ROT[41] DEST[Q] NORM $
	D[CONST 6] DEST[DEV-ADR] SPEC[IOB-IN] NORM $ ;BACK TO 6 FOR TN

	;SAVE INPUT REG IN A-MEM[7].
	MAPF[TYM.RD] D[IOD] MASK[41] DEST[AR] CYLEN[IOB-IN] $
	D[AR] ALU[DORQ] DEST[Q 7] DEST-A-MEM NORM $
	D[CONST 1] ROT[TNODIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI1] C550 $
	D[CONST [TNDISP / 100]] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	D[12] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNODIFS] C550 $	;OUTPUT DONE.
	D[12] ALU[DORQ] SDISP C550 $	;OUTPUT DONE.
TNI0:	D[17] DEST[Q] NORM $	;RESTORE INP REG
TNI1:	D[CONST 1] ROT[TNIRIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI2] C550 $
	D[17] ROT[34] MASK[20] DEST[Q] PUSHJ[BITREV] NORM $
	D[CONST [TNDISP / 100]] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	D[13] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNIRIFS] C550 $	;INPUT READY.
	D[13] ALU[DORQ] SDISP C550 $	;INPUT READY.
TNI2:	D[17] ROT[3] MASK[3] DEST[IOD] NORM $
	ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT]  NORM $
	MAPF[10] CYLEN[IOB-OUT] JUMP[UINT-DISMISS] $

;VARIOUS SUBROUTINES.
;Q LOADED WITH 16. BIT WORD TO SEND, SHIFTED LEFT BY 8.
TNSEND:	ALU[Q] DEST[AR] NORM $
	D[AR] ROT[34] DEST[Q] PUSHJ[BITREV] NORM $
	D[AR] ROT[8] DEST[Q] SHORT $
	D[MASK 16.] ROT[8] ALU[D&Q] DEST[AR] NORM $
	D[MASK 8] DEST[Q] PUSHJ[DEV6ST1] NORM $
	;CLEAR THEN SET INPUT READY FLAG TO DR11C.
	D[MASK 43] ROT[TNIROBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
	D[CONST 1] ROT[TNIROBN] DEST[AR] NORM JUMP[DEV6ST2] $
;NO OUTPUT TO DO.  DO NOT CHANGE TNIROBN, SET A-MEM FLAG FOR
; CLOCK ROUTINE.
TNORE:	GBBORQ	;NO MORE OUTPUT FOR NOW. SEE IF BLOCK OUTPUT REQ WAITING.
	D[MEM] DEST[AR] COND[-OBUS=0] C550 JUMP[TNBOST] $
		;IF SO, GO TAKE CARE OF IT.
	ALU[-1] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
;READ WORD FROM BASE-HOST COMMUNICATION AREA, LOCATION 20XX;
; Q HAS XX.
TNRCW:	D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] NORM $
	FIXM0 POPJ $

;HERE WHEN INPUT RING FULL.  SET CLOCK FLAG AND RETURN WITHOUT
; SETTING TNODOBN.
TNIRF:	ALU[-1] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
;CLEAR THEN SET TNODOBN.
TNCASODOF:
	D[MASK 43] ROT[TNODOBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
	D[CONST 1] ROT[TNODOBN] DEST[AR] NORM JUMP[DEV6ST2] $

.REPEAT SLOWTAPE [

;REVERSE RIGHTMOST 16. BITS IN Q.  LEAVES RESULT IN Q&AR.
; CLOBBERS IR, MEM.
BITREV:	ALU[Q] DEST[AR] SHORT $
	D[CONST 17] LLOAD NORM $
	D[AR] ROT[23] DEST[AR] SHORT $
	ALU[0] DEST[Q HOLD] NORM $
	D[CONST 1] DEST[IR-ALL] NORM $
BRLP:	D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[BRLP1] C550 $
	D[IR] ALU[QORD] DEST[Q] SHORT $
BRLP1:	D[IR] ROT[1] DEST[IR-ALL] LOOP[BRLP] NORM $
	ALU[Q] DEST[AR] POPJ NORM $

 ] ;SLOWTAPE

.REPEAT 1 - SLOWTAPE [

BITREV:	D[MASK 20] ALU[D&Q] DEST[Q AR] NORM POPJ $

 ]

;.USE [OTHER] GETS BACK TO NON-DISPATCH CODE AREA
	.USE[TNDISP]	;$*$*$* Dispatch mechanism is a real loser here.  We
			;	won't be able to flush this one until
			;	references are made relative.  Essentially,
			;	[xx & 77] gets replaced by [. - TNOC0] and
			;	TNOC0 is kept in a A-MEM for speed.  Then,
			;	instead of D[CONST 71] ROT[6] ALU[DORQ], one
			;	uses D[10 + x] ALU[D+Q] to do the dispatch.

;********** OUTPUT DONE CO-ROUTINE.
;A-MEM[4] = ROTATED -10 WORD WITH -11 WORD JUST SENT IN 12-27.
;STATE 0: FETCH NEXT -10 WORD OR QUIT IF RING EMPTY.
TNOC0:	GBORP
	D[MEM] DEST[AR] JUMP[TNOC0A] NORM $
	.USE[OTHER]
TNOC0A:	GHORP
	D[AR] DEST[Q] NORM $
	D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNORE] C600 $
	D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
	FIXM0 $
	D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
	D[CONST[TNDISP & 77]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
;CLOCK RESTARTS COROUTINE HERE.
	.USE[TNDISP]
TNOC2:	TNOCEC
;STATE 1: SEND LOW ORDER HALF OF -10 WORD.
	D[14] ROT[20] DEST[Q] NORM $
	ALU[Q] DEST[4] PUSHJ[TNSEND] DEST-A-MEM NORM $
	D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
	TNOCEC
	GBORP
	D[MEM] ALU[D+1] DEST[Q] NORM $
	D[MASK 8] ALU[D&Q] DEST[AR MEMSTO] JUMP[TNOC0A] CYLEN[MEMSTO] $

;********** INPUT READY CO-ROUTINE.
; A-MEM[5] HAS CURRENT INPUT WORD BEING ASSEMBLED.
;STATE 0: AWAITING START OF NEXT MESSAGE.

TNIC0:	D[CONST 2] ROT[9] DEST[MA] JUMP[TNIC0X] NORM $ ;ADDRESS OF KEY IN MAIN MEM.
	.USE[OTHER]
TNIC0X:	ALU[0] DEST[MEMSTO] NORM $ ;CLEAR KEY AT START OF EVERY MESSAGE
	D[AR] DEST[Q 5] DEST-A-MEM NORM $
	D[CONST 1] ROT[17] ALU[D&Q] COND[OBUS=0] JUMP[TNIC0A] C550 $
;DATA PACKET MESSAGE.
	D[AR] ROT[34] MASK[7] DEST[Q] SHORT $
	D[CONST 5] ALU[D+Q] DEST[AR] SHORT $
	D[AR] ROT[42] MASK[18.] DEST[6] DEST-A-MEM NORM $
	D[15] DEST[AR] SHORT $
;READ MSG.  A-MEM[6]:=# -10 WORDS IN MESSAGE.
; AR:=FIRST -11 WORD IN MESSAGE.
TNICRM:
	GBIRP
	D[16] ROT[18.] ALU[0-D] DEST[Q] NORM $
	D[MEM] MASK[18.] ALU[QORD] DEST[6] DEST-A-MEM JUMP[TNIC1] NORM $
;STATE 1: HO 16 BITS OF WORD ARRIVES.
	.USE[TNDISP]
TNIC1:	D[AR] ROT[24] DEST[5] DEST-A-MEM JUMP[TNIC1A] NORM $
	.USE[OTHER]
TNIC1A:	GHIRP
	D[16] ALU[D+1] DEST[Q] NORM $
	D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
	D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNIRF] C600 $
	PUSHJ[TNCASODOF] NORM $
	D[CONST[TNDISP & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
;STATE 2: LO 16 BITS OF WORD ARRIVES.
; ALSO STARTED HERE BY CLOCK ROUTINE.
	.USE[TNDISP]
TNIC2:	D[16] MASK[7] DEST[Q] JUMP[TNIC2A] NORM $
	.USE[OTHER]
TNIC2A:	D[CONST 22] ROT[6] ALU[D+Q] DEST[MA] NORM $
	D[15] DEST[Q] NORM $
	D[AR] ROT[4] ALU[DORQ] DEST[MEMSTO] NORM $
	PUSHJ[TNCASODOF] NORM $
	D[16] ALU[D+1] DEST[Q] CYLEN[MEMSTO] $
	D[CONST 1] ROT[18.] ALU[D+Q] DEST[6] DEST-A-MEM COND[-OBUS<0] JUMP[TNICDN] C600 $
	D[CONST[77 & TNIC1]] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
TNICDN:	D[CONST 6] DEST[Q] SHORT $
	D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] SHORT $
	D[16] MASK[7] DEST[MEMSTO] NORM $
TNBIDN:	D[CONST[TNIC0 & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] CYLEN[MEMSTO] $
;1 WD OR 2 WD OR ESCAPE MESSAGE.
TNIC0A:	D[CONST 1] ROT[16] ALU[D&Q] COND[-OBUS=0] JUMP[TNIC0B] C550 $
;ONE WORD PACKET.
	D[CONST 1] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
TNIC0B:	D[CONST 1] ROT[16] ALU[D#Q] DEST[Q AR] SHORT $
	D[MASK 6] ROT[8] ALU[D&Q] DEST[Q] SHORT $
	D[MASK 6] ROT[8] ALU[D#Q] COND[OBUS=0] JUMP[TNIESC] C550 $
;2 WORD PACKET.
	D[CONST 2] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
;ESCAPE SEQUENCE.

;HERE IF FIRST BYTE WAS 177, ESCAPE SEQUENCE. REST OF THE 8 BITS IS THE
; COUNT, IN Q, AR  AND AMEM[5].

TNIESC:	D[AR] MASK[8.] DEST[5] DEST-A-MEM PUSHJ[TNCASODOF] NORM $
		;STORE HI ORDER COUNT IN LO ORDER BITS OF AMEM[5].
		; AND TELL THE -11 WE HAVE TAKEN THE INPUT WORD.
	D[CONST[TNDISP & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
		;AND COME BACK WHEN COUNT BYTE COMES IN.

;HERE WHEN NEXT 16 BITS COMES IN. HI ORDER IS COUNT, LO ORDER IS HI ORDER ADDRESS
	.USE[TNDISP]
	D[15] ROT[8.] DEST[Q] JUMP[TNBIS0A] NORM $
		;PUT HI ORDER COUNT FROM LO ORDER 8 BITS OF AMEM[5] INTO HI ORDER BITS IN Q
	.USE[OTHER]
TNBIS0A:
	D[AR] ROT[36. - 8.] MASK[8.] ALU[DORQ] DEST[6] DEST-A-MEM NORM $
		;OR IN THE LOW ORDER COUNT BITS, STORE COMPLETED COUNT INTO AMEM[6].
	D[AR] MASK[2] DEST[5] DEST-A-MEM PUSHJ[TNCASODOF] NORM $
		;IGNORE HI ORDER 4 BITS, JUST GETTING AN 18 BIT ADDRESS
		; TELL THE -11 WE HAVE THE INPUT WORD.
	D[CONST [TNDISP & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $

;HERE WHEN GET MIDDLE AND LO ORDER ADDRESS BITS
	.USE[TNDISP]

	D[15] ROT[35. - 19.] DEST[Q] JUMP[TNBIS0C] NORM $	;GET HI ORDER 2 BITS
	.USE[OTHER]
TNBIS0C:
	D[AR] ALU[DORQ] DEST[5] DEST-A-MEM PUSHJ[TNCASODOF] NORM $
		;TELL 11 WE HAVE THE WORD, AND ADDRESS GOES INTO AMEM[5] FOR NOW.

;NOW HAVE 16 BITS OF + OR - COUNT IN AMEM[6], 18 BIT ADDRESS
; IN AMEM[5] AND AR. SEE IF ITS INPUT OR OUTPUT. IF OUTPUT, STORE
; AN IOWD IN THE OUTPUT REQUEST CELL. IF INPUT, START WORKING ON
; IT.

	D[16] ROT[20.] COND[-OBUS<0] C550 JUMP[TNBORQ] $
		;IF COUNT IS POSITIVE, ITS A BLOCK OUTPUT REQUST, SO JUMP.
	D[16] ROT[17.] SPEC[LEFT] DEST[Q] NORM $
		;GET COUNT/2 INTO LH Q
	D[15] MASK[18.] ALU[DORQ] DEST[Q] NORM $
		;PUT ADDRESS INTO RH OF Q
	D[CONST 7] ROT[36. - 3.] ALU[DORQ] DEST[6] DEST-A-MEM NORM $
		;WAS 16 BIT -VE COUNT SHIFTED RIGHT 1 PLACE, NEED 3 ONES TO MAKE IT REAL NEG NUMBER.
	D[CONST [TNDISP & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
		;NEXT STATE - GET 16 HI ORDER BITS

;HERE FOR HI ORDER BITS FOR BLOCK I/O
;IF BLOCK INPUT REQUEST, GUARANTEED TO RECEIVE A WHOLE NUMBER
; OF PDP10 WORDS, SO IOWD WE USE IS -# 10 WORDS LEFT,,ADDRESS
;IF BLOCK OUTPUT, COUNT IS NUMBER OF 16 BIT PDP11 WORDS,
; SO MUST KEEP -#11 WORDS,,ADDRESS.
	.USE[TNDISP]
TNBIS1:	D[AR] DEST[5] DEST-A-MEM PUSHJ[TNCASODOF] NORM $
		;SAVE THE HI ORDER DATA IN AMEM[5], TELL 11 WE HAVE THE WORD AND ARE READY FOR NEXT ONE.
	D[CONST [. & 77 + 1]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $

;HERE FOR LOW ORDER WORD.
TNBIS2:	D[16] MASK[18.] DEST[MA] JUMP[TNBIS2A] NORM $
		;SETUP MA FOR STORE INTO BLOCK I/O BUFFER
	.USE[OTHER]
TNBIS2A:
	D[15] ROT[20.] DEST[Q] NORM $
		;GET HI ORDER DATA FROM LAST STATE LEFT JUSTIFIED IN Q
	D[AR] ROT[4.] ALU[DORQ] DEST[MEMSTO] PUSHJ[TNCASODOF] NORM $
		;PUT THE WORD INTO THE INPUT BUFFER
		; AND TELL THE -11 WE CAN TAKE ANOTHER WORD
	D[16] DEST[Q] NORM $
		;GET -10 WORD COUNT,,ADDR IN Q
	D[CONST 1,,1] ALU[D+Q] DEST[6] DEST-A-MEM COND[-OBUS<0] C550 JUMP[TNBIDN] $
		;ADD TO IOWD, JUMP IF DONE.
	D[CONST [TNBIS1 & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
		;RESET TO GET ANOTHER HI ORDER WORD.

;HERE IF COUNT IS POSITIVE, IS A BLOCK OUTPUT REQUEST.
; COUNT IS IN AMEM[6].

TNBORQ:	GBBORQ		;SETUP ADDRESS OF  BLOCK OUTPUT REQUEST WORD IN MA
	D[16] ROT[18.] SPEC[LEFT] ALU[0-D] DEST[Q] NORM $
		;GET -11 WORD COUNT,,0 IN Q
	D[15] ALU[DORQ] DEST[MEMSTO] JUMP[TNBIDN] NORM $
		;WRITE BLOCK I/O REQUEST WORD INTO CURRENT BLOCK OUTPUT IOWD LOCATION
		; AND RETURN TO INITIAL INPUT STATE.

;PUSHJ HERE FROM CLOCK ROUTINE TO START UP BLOCK OUTPUT.
; -WORD COUNT,,ADDRESS IS IN AR.

TNBOS0:	GBBORQ		;GET BASE BLOCK OUTPUT REQUEST ADDRESS INTO MA
	ALU[0] DEST[MEMSTO] NORM $
	GBBOIO		;GET BASE BLOCK OUTPUT IOWD ADDRESS INTO MA
	D[AR] DEST[MEMSTO] NORM $ ;STORE IOWD INTO MEMORY.
	D[MASK 16.] ROT[8.] DEST[Q] PUSHJ[TNSEND] SHORT $
		;SEND ESCAPE WORD TO THE 11
	D[CONST [TNDISP & 77]] DEST[2] DEST-A-MEM POPJ NORM $
		;NEXT STATE WILL SEND A 1

	.USE[TNDISP]
	D[CONST 1] ROT[8.] DEST[Q] PUSHJ[TNSEND] SHORT $
		;SEND A 1
	D[CONST [. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
	.USE[OTHER]
		

;HERE FROM OUTPUT DONE AT MICRO INTERRUPT LEVEL WHEN SEE A BLOCK OUTPUT
; REQUEST IS PENDING, ITS IOWD IN AR.

TNBOST:	PUSHJ[TNBOS0] SHORT $ ;SEND AN ESCAPE, SET OUTPUT STATE
	JUMP[TNI0] SHORT $	;AND GO BACK TO INTERRUPT ROUTINE.

;HERE TO SEND FIRST DATA WORD, POINTER IS IN MEMORY
	.USE[TNDISP]

TNBOS1:	GBBOIO		;FETCH IOWD
	D[MEM] MASK[18.] DEST[MA] JUMP[TNBOS1A] NORM $ ;FETCH THE WORD
	.USE[OTHER]
TNBOS1A:
	FIXM0 $	;WAIT FOR IT
	D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
		;SEND IT, STORE INTO AMEM[4] FOR NEXT STATE
	D[CONST [TNDISP & 77]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
	.USE [TNDISP]
	GBBOIO
		;GET IOWD AGAIN
	D[MEM] DEST[Q] JUMP[TNBOS2] NORM $
		;GET IT INTO Q FOR ARITHMETIC
	.USE[OTHER]
TNBOS2:	D[CONST 1] ROT[18.] ALU[D+Q] DEST[MEMSTO] COND[-OBUS<0] C550 JUMP[TNORE] $
		;ADD 1,,0 TO IOWD, STORE BACK IN MEMORY, SEE IF IT HAS
		; EXPIRED YET. IF NOT, CONTINUE ON.

;SEND LOW ORDER WORD
	D[14] ROT[16.] DEST[Q] PUSHJ[TNSEND] NORM $
		;SHIFT LOW ORDER BYTE INTO PLACE, SEND IT
	D[CONST [TNDISP & 77]] DEST[2] DEST-A-MEM JUMP[TNI0] $
	.USE[TNDISP]
	GBBOIO	;GET IOWD
	D[MEM] DEST[Q] JUMP[TNBOS2A] SHORT $
	.USE[OTHER]
TNBOS2A:
	D[CONST 1,,1] ALU[D+Q] DEST[MEMSTO] COND[-OBUS<0] C550 JUMP[TNORE] $
		;ADVANCE ADDRESS AND COUNT, JUMP IF DONE.
	JUMP[TNBOS1] NORM $	;NOT DONE, GO SEND NEXT ONE.
;CLOCK ROUTINE, CALLED EVERY TICK OF 60HZ CLOCK.
TYMCLK:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPOFF] SPEC[IOB-IN] NORM $
	MAPF[10] CYLEN[IOB-OUT] D[CONST 6] DEST[DEV-ADR] $
	D[IR] DEST[7] DEST-A-MEM NORM $
	D[13] COND[OBUS<0] PUSHJ[TNSI] C550 $
	D[12] COND[OBUS<0] PUSHJ[TNSO] C550 $
	D[17] MASK[3] DEST[IOD] NORM $
	ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] $
	D[CONST 6] DEST[DEV-ADR] POPJ NORM $

TNSI:	GHIRP
	D[16] ALU[D+1] DEST[Q] NORM $
	D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
	D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
	D[CONST[TNIC2 & 77]] DEST[3] DEST-A-MEM JUMP[TNCASODOF] NORM $
TNSO:	GBBORQ		;GET BLOCK OUTPUT REQUEST WORD INTO MEM
	D[MEM] DEST[AR] COND[-OBUS=0] C550 JUMP[TNBOS0] $
		;IF ITS NON-ZERO, START A BLOCK OUTPUT REQUEST.
		; AND RETURN TO TYMCLK CALLER
	GBORP
	D[MEM] DEST[AR] NORM $
	GHORP
	D[AR] DEST[Q] NORM $
	D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
	D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
	FIXM0 $
	D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
	D[CONST[TNOC2 & 77]] DEST[2] POPJ DEST-A-MEM NORM $

;RESET TYMNET INTERFACE.  OUTPUT COROUTINE GOES INTO NULL STATE.
; INPUT COROUTINE GOES INTO STATE 0, INTRPTS GET ENABLED.
TYMRS1:	D[CONST 3] ROT[2] DEST[AR] CYLEN[IOB-OUT] SPEC[IOB-OUT] $
	 ;GET CONST TO ENB. INTRPTS; IOB-OUT CLEARS FLAGS.
TYMRS2:	MAPF[TNODIFS] START-OUT C600 $
	MAPF[TNIRIFS] D[MASK 2] ALU[NOTD] ROT[2] DEST[Q] PUSHJ[DEV6ST1] C600 $
	ALU[-1] DEST[2] DEST-A-MEM NORM $
	D[CONST[TNIC0 & 77]] DEST[3] POPJ DEST-A-MEM NORM $

TYMAREA = .	;SAVE LOCATION (DON'T USE :, ITS STICKY)

	.OPCODE[744]	  ;RESET TYMNET

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNRESET] $

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNOUT] $

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNIN] $

	NOP $	;AS NEAR AS I CAN TELL, THIS ONE (747) ISN'T USED. - PG
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[F5DIAG] $

	.USE[TYMAREA]	;RETURN TO MAIN CODE

TYMNRESET:  SPEC[IOB-OUT] D[MA] ROT[2] DEST[AR] NORM PUSHJ[TYMRS2] $
		;RESET CO-ROUTINES, ENB. INTRPTS FROM EFF. ADDR. 34,35
	JUMP[MAIN] $

TYMNOUT: SPEC[IOB-OUT] NORM $  ;CLEAR "RDY FOR DATA" FROM PDP11
	MAPF[TNODIFS] D[MA] ROT[8.] DEST[Q] NORM PUSHJ[TNSEND] $
	  ;SEND EFF. ADDR. 20-35 TO PDP11.
	JUMP[MAIN] $

TYMNIN:	D[CONST 25.] LLOAD NORM $
	NORM LOOP[.] $  ;GIVE DMA DEVICES SOME MEMORY TIME.
	SPEC[IOB-IN] NORM $
	MAPF[TYM.RD] D[IOD] ROT[34] DEST[AR] C800 $
	   ;ALIGN INPUT WORD WITH 16 DATA BITS AT RIGHT END.
	D[AR] ROT[4] C550 COND[-OBUS<0] JUMP[. + 2] $
	   ;DON'T CLEAR "INPUT RDY" FLAG UNLESS IT'S ON.
	SPEC[IOB-OUT] SHORT $  ;IT'S ON.
	MAPF[TNIRIFS] D[AR] DEST[MEMSTO] MEMST $


F5DIAG: FIXM1 $
	D[IR] ALU[NOTD] DEST[AR] NORM $
		;AR=-IR
	D[AR] ROT[13.] MASK[2] DEST[AR] NORM $
		;AR=-AC MASK 2
	D[AR] ROT[6] DEST[Q] NORM $
		;Q=INVERTED 2 LSB'S OF AC SHIFTED INTO STROBES
	D[MEM] ROT[8.] ALU[DORQ] DEST[HOLD] NORM $
		;DATA SHIFTED WITH STROBES INSERTED
	D[MEM] DEST[AR] NORM $
		;DATA=(E) (LSH 8) (STB ACTIVE LOW)
	D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
		;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
	D[MASK 2] ROT[6] DEST[Q] NORM $
		;MASK TO FORCE STB'S HIGH
	D[MEM] ALU[DORQ] DEST[AR] NORM $
		;DATA=(E) (LSH 8) (STB'S FORCED INACTIVE HIGH)
	D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
		;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
	ALU[0] DEST[DEV-ADR] JUMP[MAIN] $


];TYMNET

list  ;matches the XLIST at top of page.


;$*$*$* Grrr...
	.ORG[2141]	;DISP HERE ON TYMNET INTERFACE INTERRUPT.
			; PREPARE TO CALL MAPOFF BY RE-LOADING DEV-ADR.
	D[CONST 1] DEST[DEV-ADR] NORM JUMP[TNI] $	

	.RELOC

.REPEAT 1 - TYMNET [
TNI:	DEST[CLR-DEV-FROM-INTR] JUMP[UINT-DISMISS] $		;"It can't happen here"
];1 - TYMNET


;What is 'device 6'?  Document!  TVR-Apr80 - This is TYMNET (Clear and Store)
DEV6CL:	  ;CLEAR SOME DEV 6 BITS (SEE COMMENT BELOW).
	ALU[0] DEST[AR] NORM JUMP[DEV6ST] $

DEV6ST:	   ;SET SOME OF THE BITS IN DEVICE 6'S OUTPUT REGISTER, A COPY
	   ;OF WHICH IS MAINTAINED IN A-MEM(1).
	   ;ENTER WITH MASK FOR UNCHANGED BITS IN IN Q, DATA IN AR.
	   ; $$$$ ON RETURN, Q HAS NEW VALUE OF AMEM(1) $$$$$
	D[CONST 6] DEST[DEV-ADR] NORM $
DEV6ST1:	;ENTER HERE IF YOU'VE ALREADY SET DEVADR:=6
	D[11] ALU[D&Q] DEST[Q] NORM $ ;GET AMEM(1), MASK IT.
DEV6ST2:	 D[AR] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ 
		;OR IN NEW DATA
	MAPF[TYM.LD] ALU[Q] DEST[1] DEST-A-MEM CYLEN[IOB-OUT] POPJ $





;INTERVAL TIMER CODE.

;a-mem useage:
;	0	dispatch addr for interrupts
;	1	pi chn (33: 35) and intrpt waiting flag (32)
;		(BITS 0,19 ARE ON FOR USE BY TAPE CODE)
;	2	CONSTANT W/ ONLY BIT 19 ON (USED BY TAPE CODE)
;	3	INTERVAL TIMER REGISTER.

  .REPEAT OTP [
	TIM.CLR.ROT = 35. - 6
	TIM.DO = 1
	TIM.DI = 1
	TIM.ENB = 1
	TIM.DEV = 7
	TIM.LOC = 2150
    ] ;OTP

  .REPEAT NTP [
	TIM.CLR.ROT = 0
	TIM.DO = 11
	TIM.DI = 1
	TIM.ENB = 10
	TIM.DEV = 5
	TIM.LOC = 2134
    ] ;NTP


	.ORG[TIM.LOC]		;$*$*$ INTRPTS FROM DEVICE COME HERE.
   .REPEAT 1 - TIMER [
	DEST[CLR-DEV-FROM-INTR] JUMP[UINT-DISMISS] $ ;FLUSH DEV INTERRUPTS 
     ]

   .REPEAT TIMER [
	NORM JUMP[TIMINT] $
     ]

	.RELOC

TIMINT:   ;ALL DEV 5 INTS COME FROM INTERVAL TIMER...
	START-OUT D[CONST 1] ROT[TIM.CLR.ROT] DEST[IOD] NORM $
	   ;Clear the TIMER OVERFLOW FLAG.
	MAPF[TIM.ENB] D[13] DEST[Q] C800 $
	   ;Get TIMER REGISTER.
	D[CONST 1] ROT[12.] ALU[D+Q] DEST[Q 3] DEST-A-MEM
	          C550 COND[-CRY0] JUMP[UINT-DISMISS] $
	   ;Increment the count by 2^12, exit if no overflow.
	D[11] MASK[3] DEST[AR] C550 COND[OBUS=0] JUMP[UINT-DISMISS] $
	   ;Timer overflowed. ignore if no PI CHANNEL assigned.
	D[11] DEST[Q] NORM $
	   ;Get full contents of A-MEM[1].
	D[CONST 10] ALU[DORQ] DEST[1] DEST-A-MEM NORM JUMP[PIGEN] $
	   ;Set the "interrupting" status bit and generate a PI.

   .OPCODE[760]	;TIMER PSEUDO-IOT DISPATCH TABLE ENTRIES.

; TCONO -- 760
	D[CONST TIM.DEV] DEST[DEV-ADR] SHORT $
	D[11] DEST[Q] NORM JUMP[TCNO1]$
; TCONI -- 761
	D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
	D[AR] DEST[MEMSTO] MEMST $ ;store them and return.
; TCONSO -- 762
	D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
	D[MASK 22] ALU[D&Q] C550 COND[-OBUS=0] LBJUMP[DSKP1] $ ;Skip if on.
; TCONSZ -- 763
	D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
	D[MASK 22] ALU[D&Q] C550 COND[OBUS=0] LBJUMP[DSKP1] $ ;Skip if off.
; TDATAO -- 764  LOAD THE 36-BIT TIMER
	D[CONST TIM.DEV] DEST[DEV-ADR] NORM $
	FIXM1 JUMP[TDATO] $
; TDATAI  --  765    READ TIMER REGISTER
	START-IN D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TDTI] $ ;get bits.
	D[AR] DEST[MEMSTO] MEMST $ ;Store them and return.

   .RELOC

TCNO1:	D[MASK 32.] ROT[4] ALU[D&Q] DEST[Q] COND[USER] PUSHJ[UIOCHK] NORM $
		;CHECK FOR NOT USER AND USER IOT
	D[IR] MASK[3] ALU[DORQ] DEST[1] DEST-A-MEM JUMP[MAIN] $
	   ;Put new PI CHAN. in bits 33-35 of A-MEM[1].

TCNI1:	D[11] MASK[4] DEST[Q AR] COND[USER] PUSHJ[UIOCHK] NORM $ ;get intrpt flag and pi chn
	D[IR] ALU[D&Q] DEST[Q] NORM POPJ $ ;this is for conso, z

TDATO:	D[MEM] MASK[12.] DEST[Q] COND[USER] PUSHJ[UIOCHK] NORM $
	   ;Get low 12 bits of new timer value...
	START-OUT D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
	   ;Place in hardware counter (the "TP TIMER").
	MAPF[TIM.DO] D[MASK 24.] ROT[12.] DEST[Q] C800 $
	D[MEM] ALU[D&Q] DEST[3] DEST-A-MEM NORM JUMP[MAIN] $
	   ;Put other 24 bits into A-MEM[3] (the "TIMER REGISTER").

TDTI:	MAPF[TIM.DI] START-IN D[IOD] ROT[12.] MASK[12.] DEST[AR] C600
	   COND[USER] PUSHJ[UIOCHK] $
	   ;Read hardware timer.
	MAPF[TIM.DI] D[IOD] ROT[12.] MASK[12.] DEST[Q] C600 $
	   ;Read it again.
	START-IN D[AR] ALU[D#Q] C550 COND[-OBUS=0] JUMP[TDTI] $
	   ;If it changed, try again (to ensure that we don't get a garbaged
	   ; value because of reading it while it is changing).
	D[13] ALU[DORQ] DEST[AR] NORM POPJ $
	   ;Combine high-order bits from A-MEM[3] with
	   ; low-order bits from hardware counter.

;ROUTINE TO CHECK FOR USER IOT BIT.
;CALL WITH COND[USER] PUSHJ[UIOCHK]

UIOCHK:	D[PC] ROT[6] COND[OBUS<0] C550 POPJ $
		;IF USER IOT IS SET, ITS OK.
	JPOP[MUUO] SHORT $
		;ELSE TRAP.





;	IMP,VID,PAN,GRN,DLS,LPT,VC etc.
;------------------------------------------------------------------------------
;
;	Packet Switching Network Interface (IMP)
;
;------------------------------------------------------------------------------
.REPEAT IMP [

;Insert main code body here
.INSERT IMP.SLO

];IMP

;------------------------------------------------------------------------------
;
;	Panofsky-Samson Interface
;
;------------------------------------------------------------------------------
.REPEAT STANSW [

.INSERT PAN.SLO
.INSERT TMPGRN.SLO	;Temporary Grinnell Interface

];.REPEAT STANSW

;------------------------------------------------------------------------------
;
;	Data Line Scanner (TTY scanner)
;
;------------------------------------------------------------------------------
.REPEAT DLS [

.DEFINE ASRC[ X ] [D[10 + X]]
.DEFINE ADEST[ X ] [DEST[X] DEST-A-MEM]

.REPEAT DLS2 [
.INSERT DLS.SLO

.REPEAT DLSDEB [
.INSERT DLSDEB.SLO
];DLSDEB
] ;DLS2
.REPEAT 1 - DLS2 [
.INSERT ODLS.SLO
.REPEAT DLSDEB [
.INSERT ODLSDE.SLO
] ;DLSDEB
] ;1 - DLS2

];DLS			9 JAN 80  BO

;------------------------------------------------------------------------------
;
;	Line Printer Interface (LPT)
;
;------------------------------------------------------------------------------
.REPEAT LPT [

.INSERT LPTX.SLO	

];LPT

;------------------------------------------------------------------------------
;
;	Versatec Interface (VC)
;
;------------------------------------------------------------------------------
.REPEAT VC [

.INSERT VC.SLO
] ;VC





; dsk stuff

;a-mem useage:
;	0	dispatch addr for interrupts
;	1	pi chn (33: 35) and intrpt waiting flag (32)
;	2	copy of last cmd sent to controller (by opcode 721)

	.OPCODE[740]	;disk pseudo-iot dispatch table entries.

 ; dcono -- 740
	d[const 10] dest[dev-adr] cond[user] pushj[uiochk] norm $
	d[ir] mask[3] dest[1] DEST-A-MEM norm jump[dcno1]$
; dconi -- 741
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[ar] dest[memsto] memst $ ;store them and return.
; dconso -- 742
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[mask 22] alu[d&q] c550 cond[-obus=0] lbjump[dskp1] $
; dconsz -- 743
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[mask 22] alu[d&q] c550 cond[obus=0] lbjump[dskp1] $

	.RELOC

dcno1:	d[ir] mask[3]  c500 cond[obus=0] jump[main] $
	 ; if assigned pi channel is not 0, then
	 ;  enable interrupt on "not active", by
	 ;  re-loading last cmd with 10 bit on.
	D[CONST 20] DEST[Q] NORM $
	D[IR] ALU[D&Q] C550 OBUS=0 JUMP[DCNO2] $
	D[CONST 40] DEST[Q] NORM JUMP[DCNO3] $
DCNO2:	d[const 10] dest[q] short $
DCNO3:	d[12] alu[dorq] dest[iod] spec[iob-out] norm $
	mapf[4] cylen[iob-out] jump[main] $

dcni1:	d[11] dest[q ar] cond[user] pushj[uiochk] norm $ 
		;get intrpt flag and pi chn
	d[ir] alu[d&q] dest[q] norm popj $ ;this is for conso, z

	.ORG[2156]	;$*$*$ 

	;interrupts from disk (dev 10) come here.
	d[const 50] alu[notd] dest[q] norm jump[dskint] $

	.RELOC
	.PAIR
;$*$*$ This exists elsewhere by another name.	TVR-Apr80
dskp1:	jump[main] norm $	;conso and consz lbjump to here.
	doskip $

dskint:	d[12] alu[d&q] dest[iod] spec[iob-out] norm $
	  ;clear interrupt enable bit (amem[2] has last cmd)
	mapf[4] d[11] dest[q ar] c550 cond[obus=0] jump[ddis] $
	d[const 10] alu[dorq] dest[1] DEST-A-MEM norm
		jump[pigen] $ ;set flag and request intrpt.
ddis:	dest[clr-dev-from-intr] norm jump[uint-dismiss] $

DSKWT1:	D[CONST 10] DEST[DEV-ADR AR] NORM JUMP[DSKWT4] $
DSKWT3:	D[MEM] ROT[31.] C550 COND[OBUS<0] JUMP[DSKWDN] $
	D[CONST 1] ROT[6] LLOAD NORM $
	C550 LOOP[.] $
DSKWT4:	START-IN NORM $
	MAPF[0] D[IOD] DEST[HOLD] C800  JUMP[DSKWT3] $
DSKWDN:	D[AR] ALU[D-1] DEST[AR] C550 COND[-OBUS=0] JUMP[DSKWT4] $
	JUMP[MAIN] $





;
;ECC logging area
;
.REPEAT 1 - XUCODE [
: 7760
];.REPEAT 1 - XUCODE
.REPEAT XUCODE [
: 17760
];.REPEAT XUCODE

 .REPEAT 20 [NOP $
]




;; this should be after everything else
: 0
	JUMP[MSTART] $		;Auto-load micro code tapes someday.

  !nD