COMMENT \	FOONLY F2-F3 MICRO-CODE


Recent history:

21 Mar 80 TVR	Added DMOVE, DMOVEM and ADJSP instructions.  Changed opcode of
		XMOVE to 107, as it conflicted with ADJSP.  Experimental boot
		switches in preparation for auto-loading tapes.
22 Mar 80 TVR	Fixed some typos with above.  
26 Mar 80 TVR	Added WAITS switch to modify pager to make references to user
		ACs go to user shadow memory (instead of special place pointed
		to by AC Base Register in BBN Pager).  Since the addresses
		supplied to the random instructions must be larger than 17
		to prevent references to ACs in 2901, a page was stolen from
		the EXEC address space, currently 770xxx, and that page table
		entry in the hardware is copied from entry 0 of the user page
		table in core.
		Also, for Stanford only, defined ILGIOT to reference the PAN
		interface, so that CONSZ will skip when no device is present
		and new devices can be added to that bus without microcode
		changes.
		Fixed dispatch for UUO0 to look at opcode field only.  Made
		indirect dispatch test for the stop switch, so that stop will
		stop indirection loops
		Fixed DATAO PI, to page fault properly.
27 Mar 80 TVR	Pager mods and tape hack for CCRMA were both buggy.  Fixed.
		Fixed bug in pager: PC was being over-decremented on page
		fill cycle when indirection failed in XCTR'ed instruction.
29 Mar 80 TVR	Flushed a spurious DEST-A-MEM which prevented WAITS from
		working at XCTAC+1.
02 Apr 80 TVR	Added code to trap IOT references if not Exec or IOT-User
		mode.  New macro, UIOTRP, jumps if in IOT-USER mode.
		ILGIOT still is a no-op for non-Stanford microcode for
		the moment.
		For Stanford only, the PAN interface has its micro-interrupts
		re-enabled on PI-CHECK-RQS.
		Bummed an instruction out of IOTDIS. Indirect bit is guaranteed
		zero so one can double by shifting instead of doing an add.
03 Apr 80 TVR	Fixed ADJSP.  XCT n,[PUSH x,y] failed if x was a user AC
		reference.  Added code to emulate PUSH/POP.
04 Apr 80 TVR	XCT 1,[POP x,AC] didn't have a chance of working.  It gets
		emulated as well.  Added code for KAFIX.
11 Apr 80 TVR	Changed PAN interrupt enables in PI-CHECK-RQS.  Added reset
		code and IOT dispatch for temp. Grinnell code (under STANSW).
		Looked at DIV code to try to fix divide-by-zero.  Gave up in
		disgust.  I won't touch that code with a 10 ft battle axe!
		Fixed another stupid typo in ADJSP.
22 Apr 80 TVR	Fixed two bugs in DPB (and one in LDB).  DPB sets half flag
		if it gets a page fault on the pointer reference.  The monitor
		doesn't care much, but some user programs look at the fault
		PC and flags to decide what kind of Pager and CPU they are
		running under.  The other bug was that in LDB and DPB; they
		do not handle bytes which 'wrap-around', i.e. 36-P<S.  If this
		is the case, i think the right thing is S:=P.
		Fixed bug in DMOVEM references to ACs.  One more time on ADJSP.
		Added code (MAPRST) the clear entire map (not just valid bits)
		on 'power-up' to prevent immediate mode references from going
		to non-ex memory and/or causing spurious ECC traps.
		Wrote some code for DMOVN, DMOVNM, and KIFIX.
		Re-arranged a few things to make things fix (%$%@*#& orgs).
26 Apr 80 TVR	Merged with DWP's version, which did not contain indications
		of alterations.  Unfortunately, i did not have the most recent
		CCRMA version available, so another merge will be necessary.
		Many comments added.
30 Apr 80 TVR	Attempted merge with CCRMA version.  That tape was not complete
		so only some of the code will be merged.  Enough to proceed
		with cleanup.
		Replaced most :<expression> with macro calls in order to use
		microcode memory in a more reasonable fashion.
		More comments added.
07 May 80 TVR	The assembler is a loser!  It redefines macros alright, some of
		the time.  At any rate, the macros were rewritten and all
		(shudder) of the macro calls changed.
10 May 80 TVR	Merged in the rest of the CCRMA changes.
11 May 80 TVR	Grumble, curse, moan!!!  No, the assembler isn't THAT bad.
		The REAL loser not the assembler, but the person who wrote oet
		the old version (which had a different name) onto
		SCI:<POOLE>SLOEXP.SAV and which contains various and sundry
		bugs, one of which appears to be macro re-definition and
		another being an unusable storage map.  So, everything was
		delayed a week while i tried to get around bugs which had
		already been fixed.
		Fortunately, this time it could be converted back to the
		original form with the aid of a TECO macro.
		Adjusted memory usage and it now assembles except for
		re-usage of 5300 and 5301.
12 May 80 TVR	Adjusted some of memory usage to make the silly thing assemble
		WAITS version in preparation for making larger adjustments.
		PAN interrupts are come out in the status word as low true. PAN
		interrupt code has been corrected for that.
		Fixed a rather obscure bug in SETHLF.  Because SETHLF stores
		into CRYOV, the EXEC mode shift register (what COND[USER] is
		based on) gets forced to be the current space.  Thus,
		page faults from User pages in Exec mode on certain
		instructions (like IDPB) were being processed as being Exec
		mode page faults.
13 May 80 TVR	Added .QUAD macro and put it in places jumped to by SLOOP
		which were previously controlled by :<absolute number>.
		Adjusted memory usage to make the one area using .QUAD fit.
		Fixed misfeature in experimental boot.
		LDB/DPB for bytes that wrap around just isn't right at all!
		BYTE-OVERF is condition BEFORE incrementing, not after.  So,
		i will have to rethink this one to come up with something
		that handles that case properly without slowing byte
		instructions down significantly.

Changes at CCRMA follow:

15 May 80 TVR	Fixed bug in DMOVNM.  Changed mechanism for PAN interrupts.
		The PAN microinterrupt enable is turned off when the interrupt
		for that channel is recieved and turned on by PI-CHECK-RQS
		by setting all of the microinterrupt enables for the PAN to
		the complement of PI IN PROGRESS and PI REQUEST.  This means
		that the PAN can only request interrupts whenever something
		else isn't using those channels.  This implies that any PAN
		devices must be on the end of CONSZ chains, or else they will
		steal interrupts from other, interrupt counting devices.
24 May 80 TVR	Grinnell interrupt bug fixes.  Starting putting names on
		opcodes and stuff to make it easier to use with E.
26 May 80 TVR	Fixed problem in JRST1+1 falling thru to nothingness.  A few
		more editorial changes.
07 Jul 80 TVR	Changed CONO APR, code to turn on AR INT ENB and also made
		symbols some references to APR A-MEM relating to APR.
		Fixed bugs in F2 version of overflow interrupt.
		*** Did not look at F3 code for same. ***
		More comments added.
08 Jul 80 TVR	Made attempt to fix [I]DIV by zero and no divide.
		As part of that, commented the setup part of DODIV, and added
		code to try to restore AC after finding no divide case.  I'm
		not sure the DIV case will work properly, but we'll see...
		Fixed bug in FDVR of negative number which set the flags wrong.
		It had the wrong MASK when complementing a negative dividend
		exponent.
		Many comments added to divide and KA floating point as a result
		of chasing these.  Some have (???) being i'm not sure that either
		the code and/or the comments are right.
15 Jul 80 TVR	Installed LPT device.  Microcode for LPT is still being tested.
		Fixed bug in PAN enabling, so that PI channels that are not
		turned on do not have their micro interrupts enabled.
22 Jul 80 TVR	Fixed bug in [I]DIV which clobbered PC on divide by zero.
		Sets overflow on KIFIX now.  Also, sets overflow on KAFIX, which
		should not cause any problems.
25 Jul 80 TVR	Added FIXR and FLTR.
23 Aug 80 TVR	Fixed bugs in LDB/DPB having to do with bytes which overflow
		word boundaries.
		Ran out of micro-code space and re-adjusted .USEs to recover
		some wasted space.
		More work on LPT device.
20 Sep 80 TVR	Added a new switch, MUM2.  At the moment, this only causes
		ECC logging information to go to 1776x instead of 0776x.
		Under WAITS switch, changed APR CONI, and clock interrupt
		decision, to implement special feature of SAIL's KA, which
		turns on bit 27 in APR CONI when it is NOT interrupting.
25 Sep 80 TVR	Began merge of CCRMA version with DWP version.  MUM2 became
		XUCODE.
		Tape code got moved to separate files in order to make SRCCOM
		feasible.
		New symbol TYMORG defines where absolute part of TYMNET code
		is assembled. It only need be changed in the future.

Changes at Foonly follow:


15 Aug 80 BO	Added Versatec to unused half of CTY IOT dispatch,
		device code 124.
		Removed the 16 NOP's at the very end of memory.  VC code
		is broken up to fit available space.
		Used absolute locations 5340-5437 (5340 defined as
		VCORG1) and 7733-7777 (VCORG2) defined in VC.SLO
		
25 Sep 80 TVR	Following changes were not documented but evident from source
		comparison:

		MASK[18] was added to dispatch code at 2002. Presumably, this
			done to make the interrupt bug trap work properly.
		CONSZ to DLS when no code is assembled now always s so
			that TENEX can tell if the DLS exists.
		New device, VID, added.  This is Gossett's new display.
		uDevice numbers for the DLS, VC are now variables.
		Code for DMA tape controller was added.
		Two new switches were added, OTP and NTP, which stand for
			Old Tape and New Tape controllers.  NTP is for
			the DMA tape controller and all others are OTP.
		Changes to CTY code and TYMNet code to account for differences
			in MAPF fields for new tape controller.
		Some adjustment of .ORG and .USE were done to make things fit.
		FDVL was fixed.  This involved making changes to A-MEM usage
			in floating divide code.
		SLOEXP was modified to truncate jump addresses to 12 bits without
			complaint.
		New switch, XUCODE, was added.  If XUCODE=1, then some I/O devices
			are assembled into the upper 4K of microcode memory.
		A new macro, .GETADR(X), constructs a 12 bit number in Q.
		Tape code is optionally moved into upper 4K of microcode memory
			if XUCODE=1.  Dispatches for tape code were moved.
		
Versions merged.  This version is designated 1.02 by fiat of TVR.

25 Sep 80 TVR	Completed merge.
		*** VC needs a new device code.  It had used the slot assigned
		historically to the LPT.
		Some other minor formatting/comment changes were made to make
		the source merge program work properly.
		There were strong differences between the two in the floating
		divide code.  Hopefully, all of the A-MEM changes made it
		across.  I have checked them by hand.

26 Sep 80 TVR	Assigned device 520 to VC (Versatec interface), and modified
		VC.SLO to accomdate that.
22 Oct 80 EVS	Merged in TYMSHARE changes - KL map, etc. Following
		is the history for those changes:
4 JUNE 80 PG	ADDED STUFF FOR KL PAGER EMULATION. AS YET UNTESTED. 
		ASSEMBLY SWITCH "KL".
28 JULY 80 EVS	ADDED KL TRAP MECHANISM, KL STYLE APR AND PI CONI CONO
		FORMATS. FIXED BUGS IN KL PAGER CODE THAT DIDN'T MASK
		OFF UPT ADDRESS PROPERLY (GOT AC BLOCK FIELDS ORED INTO
		LOW ORDER BITS).
		HAD TO MAKE JSR AS INTERRUPT INSTRUCTION STORE PC IN ABSOLUTE SPACE RATHER THAN
		VIRTUAL BECAUSE CANNOT RESTART AN INTERRUPT CYCLE
		IN CASE WE GET PAGE REFILL ON STORING PC.
28 JULY 80 EVS	Fixed bug in KL version of PUSHJ - do not set PC
		in same microinstruction as MAPF[PPOP] - else
		after page refill won't reexecute instruction.
30 July 80 EVS	Fixed various bugs in XCT mapped. Changed XCTAC
		to SET-TEMP-EXEC because address of previous ACs
		is in exec space.
		Stopped IR from getting smashed in MUJSR because
		state of map is saved in it by MAPOF
		Took out MASK[4] from instruction at XCT10+1
		so that instruction could fetch and/or store previous
		ac data. I hope this doesn't break the TENEX map.
		Fixed place that checked IR for which XCT ac bits
		after they had been xferred to Q to check Q instead,
		at XCT5+1.
		Fixed some places that forgot to check call from monitor
		condition in 4000 bit in KL's PC.
		Fixed code that continues PUSH and POP when they
		are under XCT mapped to have the right MAPF
		code, so that stack PTR doesn't get incremented
		or decremented on page refills and page fails if
		it isn't supposed to.
14 Aug 80 EVS	Fixed problem with LUUO - if page refill or page fail
		occurs for the store into 40, PC has been decremented,
		and prog gets restarted at LUUO place-1.
		Fixed XCT mapped of DMOVEM, not enough bits set into
		the MAP-EXEC-SR to cover two stores.
		Fixed bug in page refill which happened when W bit was
		on but A bit was off - still allowed access to the
		page.
26 Aug 80 EVS	Fixed code for KL map under NEWMAP switch.
		Watched Poole install new microcode for
		the DMA tape control, under switch NTP.
		Took out extra JUMP[MAIN] at location 2150.
3 Sep 80  EVS	Put in new block I/O code in TYMNET base emulation code.
		Put code into DCONO to allow enabling for attention
		instead of idle - DCONO 20+PI.
03 SEP 80 EVS	CHANGED INTERRUPT DISPATCH CODE TO BE AT 7500 INSTEAD
		OF 7400 BECAUSE OF CODE AT "OTHER" EXPANDING. CHANGED
		MPOFF1 TO BE OUTSIDE OF 1 - KL CONDITIONAL BECAUSE
		TYMNET CODE NEEDS IT.
5 SEP 80 EVS	DO NOT CLEAR HI-ABS-MA WHEN TRYING TO DO MEM OPERATIONS
		TO UPT+501 AND 502 ON A PAGE FAULT TRAP.
29 Sep 80 EVS	Various fixes to new block I/O network interface microcode.
		Put in CLR-DEV-FROM-INTR before calling TYMCLK.
		For KL map, put in init of MAP-DISP register.
23 Oct 80 EVS	Fixed bug in block I/O which caused output word
		to be sent to the -11 before it was ready to
		accept it, after the last xfer of a block output.

03 Feb 81 EVS	Merged changes received from Poole on 30 Jan 81 into
		this source file. Changes to floating point
		and fixed point arithmetic instructions show up
		in file compare but have no entries in change
		history. (Fixed point change looks like it took
		a bunch of ACSEL[AC]s out). Instruction to clear disk interrupt
		enable bit was moved. Illegal device interrupt check
		code under F3SW REPEAT 0ed out.
4 Nov 80 PG	Added new display service for FooVision (VID.SLO). This
		stuff makes use of high memory, since it is quite large. Note
		that the ,INSERT must be right after the tape code, since
		(due to kludgery) .USE[OTHER] doesn't work properly for getting
		you back to low memory (see TYMFOO). For your information:
		.USE[HIGHMEM]	gets you to high memory
		.USE[OTHER]	gets you back to low memory
		GETADR[FOO] JUMP[GOHIGH] $	jumps to high memory 10000+FOO
						(Note that this expands
						to 2 microcode words.)
		JUMP[GOMAIN] $			jumps to MAIN in low memory

21 Nov 80 - PG	Added new output instruction to TYMNET for F5 diagnostics.
		Takes the data in the effective address, using the right
		16. bits of the right half as data to go out;
		AC=1 => STB DATA, and AC=2 => STB CTRL.
18 Feb 81 EVS	Put time field specifications into MFI routine.
		Changed MAPUP and MAPDN to enable and disable arithmetic
		overflow traps. Changed JRSTF to not allow user mode to set
		user IOT bit in PC. Took out special memory test opcodes 106
		and 107, made them trap as MUUOs. Also made 100-103 into
		MUUOs. Discovered that combination of time used by microcode
		and macrocode doesn't allow reads or writes to/from consecutive
		sectors on disk without incurring full revolution latency.
18 Feb 81 EVS	Put code in to make overflow work the way it does on KI and KL.
		Use bit 4 in APR AMEM[2] to OR into PC whenever it is stored
		by an instruction or trap. On micro-interrupt for overflow,
		turn off hardware overflow flag so trap won't happen again,
		and turn on overflow flag in AMEM. JRSTF never sets hardware
		overflow, only AMEM overflow flag. All this necessary because
		microtrap happens as long as its enabled and PC overflow
		flag is set, but on KL and KI trap only happens when
		trap flags are set, not because overflow is on.
23 Feb 81 EVS	Fixed routine DOTRPX so that it properly clears out the FPD
		bit in AMEM if HALF was on at time of trap cycle (was clearing
		bit 10., not bit 3 in AMEM). Symptom was that first part done
		mysteriously appeared on in PC after an arithmetic trap.
23 Feb 81 EVS	Forgot about JFCL when putting in stuff for overflow
		bit faking. Make JFCL jump on AMEM flag and clear when
		doing overflow.
23 Feb 81 EVS	New Feature: Make examine and deposit switches turn off map
		before examining and depositing EXCEPT when address switch
		for bit 13. is on, in which case duplicate the old behavior,
		which is to examine whatever address space the machine happens
		to be in at the time (which is God knows what if the machine
		is running).
03 Mar 81 EVS	Bug: If micro-interrupt or page fail during effective address
		calculation happens at dispatch of a trap instruction,
		PC is wrong because DOTRPX decremented it anticipating
		the dispatch to increment it on successful opcode dispatch
		of the trap instruction. If micro-routine winds up back
		at MAIN instead of generating a macro PI, PC has been permanently
		decremented, and because of another bug (described below)
		the trap is lost as well, except in the case of page refill
		on an indirect word of the trap instruction (the refill
		code is smart enough to regenerate the trap, but PC is still
		wrong.)
		Fix: All exits from places that have interrupted the execution
		of a trap instruction must increment PC before restarting
		the trap instruction or before storing PC for macro level.
		This includes page fail, page refill, microinterrupts
		that cause macro interrupts, and microinterrupts that
		just dismiss back to main instruction loop.

		Bug: Microinterrupts that don't generate Macro-interrupts
		(that is, jump back to MAIN) which occur from the dispatch
		for the trap instruction will cause the trap not to get
		re-executed, since the trap flags will be cleared at
		MAIN1.
		Fix: All micro-interrupt routines that jump back to
		MAIN without generating macro interrupt now jump to
		a new place called UINTR-DISMISS, which re-generates
		the aborted trap.
03 Mar 81 EVS	Bug: If successfully execute a trap instruction and
		the next instruction fetch page fails, MAIN1 hasn't
		cleared the trap flags yet, so the trap instruction
		will re-execute the trap.
		Fix: Use MAPF code 15 (used for JSYS in non Kl version)
		to indicate instruction fetch, do what MAIN1 does
		in the event of page fail and HALF set to clear
		the trap flags.

(End history)
\




;Implementation of Traps in F3 microcode.
;
;Since the F3 has no hardware PC flags corresponding to the
;trap bits found on KI and KL model processors (or at least, it is
;missing one) and has no hardware support for the arithmetic
;and PDL trap mechanism found on these models, this must be implemented
;in the microcode. What has been done is that the HALF bit in the PC
;has been used to indicate one of several bits that may or may not
;be set in AMEM[2] which represent the trap bits and the first part done
;bit which HALF used to be. Also, HALF covers a bit indicating that
;a JRSTF with trap flags set has been done, so that the microcode
;can perform the trap before executing the instruction at the new
;PC (else TI will get lost by being cleared at MAIN1.)
;
;
;TRAP:	Set TI1 and TI2 (overwrite previous values)
;	FPD _ FPD .and. HALF		;Clear AMEM FPD bit since turning on HALF if HALF was clear
;	HALF _ 1
;	PC _ PC - 1
;	Turn Map off
;	Fetch trap instruction from UPT or EPT
;	Turn Map on
;	GOTO MAIN2 to dispatch.
;
;MAIN:	If HALF [If debreak, debreak _ 0, GOTO TRAP1]
;		;To make sure that JRSTF that sets trap flags traps
;MAIN1:	(Page fail trap for next instruction may happen here, before check on HALF)

;	If HALF [Clear TIx, HALF _ FPD]
;MAIN2:	Dispatch (PC _ PC + 1 if successful)
;	(Microinterrupts, page fail for indirect words can happen here.)
;
;Page fail microtrap prologue code
;	If from instruction fetch at MAIN1 [
;		If hardware overflow flag set [
;			Set AMEM overflow flag
;			Clear Hardware overflow flag
;			Set TI1
;			GOTO TRAP
;		Else
;			If HALF [Clear TIx, HALF _ FPD]
;			Continue with rest of page fail microcode
;
;Page Refill and microinterrupts which don't cause macro-interrupts
;
;	IF HALF [
;		IF TIx [
;			Increment PC (decremented it assuming fault was from
;			  from inst at PC-1, but was from trap inst.
;			This restores PC to value it was when starting the trap.
;			GOTO TRAP (causes trap instruction to get restarted)
;		ELSE
;			GOTO MAIN (causes instruction at PC to get reincremented)
;		]
;
;Page Fail
;(ind loop or XCT chain in trap instruction)
;	Decrement PC if normal read or write,
;	  not if for XCT fetch, indirect word fetch
;	If HALF [
;		IF TIx [
;		 Increment PC (Page fail during trap cycle has PC pointing
;		  to one before next instruction to get executed because
;		  either PC is decremented by TRAP if page fail is during
;		  indirect fetch or by beginning of page fail routine
;		  if failure is after dispatch on trap instruction and during
;		  that instruction
;		 Store PC with TPx _ TIx
;		 Clear TIx
;		 HALF _ FPD .and. HALF
;			]
;		]
;
;
;Macro-PI
;
;	Clear USER
;	Turn Map off
;	Fetch PI instruction (EPT + 40 + 2N)
;	Turn Map on
;	If Inst # JSx [
;		PC _ PC - 1	;Dispatch increments it
;		GOTO MAIN2
;	Else;Inst = JSx
;		If HALF [
;		   If TIx and Debreak not set [
;			PC _ PC + 1	;Because PC is decremented either
;					; because TRAP decremented it and dispatch
;					; hasn't completed yet or the trap instruction
;					; is interruptable and decremented PC
;					; before dispatching to interrupt so that
;					; the instruction could be re-executed.
;					;Watch out for debreak, if its set
;					; don't increment PC since came from
;					;JRSTF thru PI dismiss, and PC not decremented
;		   ]
;		]
;		Interpret JSx: Store TPx _ TIx, FPD
;		Debreak _ 0	;Because PI code goes to MAIN2
;				;HALF gets cleared by subroutine instructions.
;		Jump into middle of the JSx instruction
;		;PUSHJ not legal as PI instruction
;
;JSx instructions, PUSHJ (all PC storing instructions):
;	If HALF [
;		Store FPD .and. HALF into PC
;		];else store zero (=HALF)
;
;PDL OV: Goes directly to TRAP - doesn't go thru MAIN2, so have
;	to overwrite existing values of TIx.
;
;Arithmetic Overflow:
; (implemented on F3 as a microinterrupt which traps on instruction dispatch
;  as long as PC overflow flag is on)
;	Goes directly to TRAP. PC points to next instruction.
;MUUO:
;	If HALF [
;		If TIx [
;			Fetch new PC from TRAP new PC
;			Store FPD instead of HALF in PC.
;	]
;	Setting new PC clears HALF. TIx will get cleared or set next time someone sets HALF flag
;
;JRSTF: If TPx [ then TIx _ TPx, FPD _ FPD from new PC, set HALF, set Debreak
;	 proceed with rest of JRST code.
;	Else
;		HALF _ FPD from new PC
;		FPD _ FPD from new PC
;	]
;
;Instructions that do CLR-HALF do not have to clear FPD in AMEM - therefore
;these bits in AMEM do not mean anything unless HALF is on.
;
;Anyone who sets HALF must set FPD to old value of HALF .AND. FPD.
;This means clearing FPD if HALF was off. This is so instructions
;that do CLR-HALF don't have to clear FPD.
;
;MUUO whose new PC sets HALF (silly thing to do) will not work correctly,
;since MUUO code doesn't set FPD. However, in normal case of FPD off
;in new PC, whoever turns HALF on must set FPD properly.
;
;Instructions that set HALF now will set HALF and FPD in AMEM via
; subroutine SETFPD:
;	IF HALF [
;		Set FPD in AMEM
;	ELSE (not HALF)
;		Clear TIx, Debreak, set FPD
;		Set HALF
;	]
;
;Instructions that check HALF:
;	If HALF [
;		If FPD [ Do second part
;		]
;	]
;
;TIx - Trap in progress flags stored in AMEM[2]
;TPx - Trap bits stored in PC word
;FPD - First Part Done flag stored in AMEM[2]
;
;FPD and TIx only valid if HALF is on.



COMMENT \

The following definitions are intended to make locations fixed by
microcode after location 4000 all appear in one place, making it easier to see
what is where.  THIS IDEA WILL NOT WORK UNLESS ALL AREAS FIXED BY
FIRMWARE ARE DEFINED HERE AND NOWHERE ELSE!
/EVS 1-22-81

\

RESTART-ORG = 4000		;So that starting at 4000 restarts microcode
NORMAL = 4001			;Start of large general purpose microcode area
BOOTSTRAP-ORG = 5000		;Macro code bootstrap from tape
CTYIOTDISP-ORG = 5100		;So code can use SDISP for CTY and LPT dispatches
  CTYIOTDISP-ORGARG = 51	;TO FEED TO IOTDISP MACRO
LPTIOTDISP-ORG = 5120		;Not used because contiguous with CTY, but define anyway
AREA51 = LPTIOTDISP-ORG + 20
				;AREA51 begins right after LPT dispatch
BBNMAPIOTDISP-ORG = 5200	;For BBN CONO PAG dispatch
CTYMAPDISP-ORG = 5210		;Not sure why this one is here
APRIOTDISP-ORG = 5300		;For SDISP dispatch on APR IOT
  APRIOTDISP-ORGARG = 53	;To feed to IOTDISP macro
PIIOTDISP-ORG = 5320		;For PI IOT dispatch - not used because contiguous with APR
AREA53 = PIIOTDISP-ORG + 20
				;Beginning of relatively large free area
MAPTRAP-ORG = 6100		;For MAPF field dispatches
OTHER = MAPTRAP-ORG + 17 * 4 + 1
				;Beginning of large general purpose
				; microcode space after Map trap dispatch area.
TNDISP = 7700			;For TYMNET state SDISP dispatches
ECCLOG-ORG = 7760		;For soft ECC logging
SPURIOUS-INTERRUPT-ORG = 7777	;A JUMP[.] for spurious interrupt reporting



COMMENT \

********************************************************

	USEFUL MICROCODE WORD DEFINITIONS

********************************************************
\

F3SW = 1 - F2SW

OTP = 1 - NTP


FIXM1 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[FIXM] $
FIXML = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-RD] CYLEN[LONG] $
FIXM2 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] $
FIXM0 = ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[0] CYLEN[FIXM] $
.DEFINE MEMST [] [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]
  ;  NOTE:  BECAUSE OF XCT MAPPED, MEMST IS SAME AS MEMSTMA
 ; .DEFINE MEMST [] [COND[-MA-AC] LBJUMP[SMAIN] NORM ]
.DEFINE MEMSTMA [] [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]

DOSKIP = D[PC] ALU[D+1] DEST[MA PC] JUMP[MAIN1] NORM $
DONTSKIP = DEST[MA] SPEC[MA_PC] JUMP[MAIN1] $
DOJUMP = D[IR] DEST[MA PC] JUMP[MAIN1] NORM $
DOM1	= SPEC[MA_PC] JUMP[MAIN1] NORM $

CLRR	= ROT 22 D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $
CLRL	= 	 D[MASK 22] ALU[D&AC] ACSEL[AC] DEST[AC] $

;SLFFXM - Self FIXM (?)
;Finish read fetch of read-modify-write type cycle.
;Check to make sure effective address is writable.
;Jump if AC field in IR is non-zero
.DEFINE SLFFXM[ JDST ] 
[	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM] COND[-AC=0] JUMP[ JDST ] $
]

;;;;;;APR-A-MEM DEFINITIONS -- THERE SHOULD BE 7 MORE OF THESE !

A-MEM-ECC-DATA = 1	;Data on last ECC error -- readable by op. 750

;;;;;;;

BADLOC = JUMP[MAIN] $;NOP FOR NOWJUMP BADPC $		;FOR WORDS WE SHOULDN'T USE
;;;;;ILGIOT = NORM JUMP[2000] $

;The standard case for IOTs without devices
.REPEAT 1 - STANSW [
.DEFINE ILGIOT[ ]
[  JUMP [MAIN] ]
];.REPEAT 1 - STANSW

;At Stanford, any devices we don't know about go to the PAN interface.  It
;may have something plugged into it that will respond to that address in a
;PDP-10ish manner.
.REPEAT STANSW [
.DEFINE ILGIOT[ ]
[ COND[-USER] LBJUMP[PANIOT] NORM ]
];.REPEAT STANSW

;Jump not IOT-USER mode
.DEFINE UIOTRP[ XXX ]
[	D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[XXX] $
];DEFINE

.DEFINE GETADR[ADR] [  ;Place the 12-bit value of ADR in Q.
 	D[CONST (77 & (ADR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
	D[CONST (ADR \ 100)] ALU[DORQ] DEST[Q] C600 ]  ;Low-order 6 bits
	 ;NOTICE that a "$" is REQUIRED after a call of GETADR.

UUOLOC = D[CONST 40] JUMP[UUO1] NORM $

.REPEAT 1 - KL [
   .DEFINE MUUO1 [][ D[PC] DEST[Q AR] JUMP[MUUO2] NORM $
   .DEFINE UAOP1 [][ D[PC] DEST[Q AR] JUMP[UAOP] NORM $ ]
]
];.REPEAT 1 - KL
.REPEAT KL [
   .DEFINE MUUO1 [][D[IR] DEST[AR] JUMP[MUUO2] NORM $
]
   .DEFINE UAOP1 [] [MUUO1
]
];.REPEAT KL

SET-TEMP-USER = D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
SET-TEMP-EXEC = D[CONST 0] ROT[11] DEST[MAP-EXEC-SR] NORM $

;
; THESE OUTLANDISHLY EXPLICIT DEFINITIONS OF NOP ASSURE THAT THE
; DECODER WILL PRINT 'NOP' ONLY WHEN YOU REALLY MEAN IT.
;
NOP =    COND[0] DEST[0] CONT ALU[D]
	ACSEL[AC] NO-MA-STB NO-AR-STB ROT[0] MASK[-1] ALU-D[NONE] $

DONOP  = COND 0 DEST[ 0] ALU[D]
	 ROT[0] MASK[-1] ACSEL[AC] JUMP[MAIN] ALU-D[NONE] NORM $

DODISP	= D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $

;------------------------------------------------------------------------------
;
;	CPU special registers				uDevice 0
;
;------------------------------------------------------------------------------
;
; Dev  Subsel	    Read			    Write
;
;  0	 1					Address Break Register
;	 2	Data switches			Data lights
;	 4	Address and console switches	Clear latched switches (no data)
;	10	PC History (unimplemented)	Set AR,ECC enables, MAP ON, etc.
;
;  1	 1	ECC status
;	 2	MAP status			MAP (address in MA, LOCAL USER)
;	 4	(Same as 1)
;	10	(Same as 1)
;

;------------------------------------------------------------------------------
;
;	A-Mem usage					uDevice 0 & 1
;	(Note: Not all references are symbolic as yet.
;
;------------------------------------------------------------------------------
;Device 0
A-MEM-ECC-DATA = 1	;Data on last ECC error -- readable by op. 750
APRSTS = 2	;Firmware status bits for APR
APRENB = 7	;Used to save ECC,AR interrupt enables, MAP ON, etc. during map
		;trap processing
;Device 1
ECCSVP = 3	;Pointer to next place to remember ECC interrupt in microcode
		;memory




COMMENT \

*****************************************************

		REAL CODE

*****************************************************
\

INST-DISP = 2000	;Address of instruction dispatch.
  .REPEAT XUCODE [
HIGHMEM = 10001		;Upper 4K of 8K u-mem.
    ]

			;**** Next macro blows up with multiply defined symbol.			;**** Note that it usually does not complain!!!
	.OPCODE[000];	UUO 0 COMES HERE (ALONG WITH UUO 1 - 7 )

	NORM JUMP[UUO0-7] $

;; Location 2001 is used elsewhere !!!

.REPEAT F3SW [
	; INDIRECTING TRAPS HERE
: 2002	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
	D[MEM] DEST[IR-23 MA AR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
;STOP SWITCH, OV, & ECC TRAPS HERE (4 & 5)
: 2004	DEST[CLR-DEV-FROM-INTR] JUMP[SOED] NORM $
: 2005	DEST[CLR-DEV-FROM-INTR] JUMP[SOED] NORM $
	; INDEXING TRAPS HERE
: 2006	ALU[IX+D] D[IR] MASK[18.] DEST[AR IR-ADR MA] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP]$

	;INTERRUPTS TRAP HERE
: 2007	D[10] SDISP C600       $
.REPEAT 0 [
: 2007	JUMP[7500] $;7500 will probably be used if this is ever turned on again!
: 7500
	D[10] MASK[18.] DEST[Q AR] C550 $
	D[CONST 21] ROT[6] ALU[D#Q] DEST[Q] C550 $
	D[CONST 30] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 34] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 41] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 50] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 56] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $

	D[CONST 1] ROT[6] ALU[D#Q] DEST[Q] C550 $
	D[CONST 62] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[AR] DEST[CLR-DEV-FROM-INTR] JUMP[.] C550 $
INTOK:	D[10] SDISP C600 $

] ;.REPEAT 0
 ];.REPEAT F3SW

.REPEAT F2SW [
.REPEAT 0 [
: 2002 ;I/O INTERRUPTS TRAP HERE
	JUMP[7500] $
: 7500
	D[10] MASK[18.] DEST[Q AR] C550 $
	D[CONST 21] ROT[6] ALU[D#Q] DEST[Q] C550 $
	D[CONST 30] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 34] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 41] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 50] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[CONST 56] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $

	D[CONST 1] ROT[6] ALU[D#Q] DEST[Q] C550 $
	D[CONST 62] ALU[D#Q] COND[OBUS=0] JUMP[INTOK] C550 $
	D[AR] DEST[CLR-DEV-FROM-INTR] JUMP[UINT-DISMISS] C550 $
INTOK:	D[10] SDISP C600 $
];1 - DLS	9 JAN 80 BO

:2002	;I/O INTERRUPTS TRAP HERE
	D[10] SDISP C600 $
		;Just dispatch to ucode intrpt. routine for device.
: 2003 ;STOP SWITCH TRAPS HERE
	DEST[CLR-DEV-FROM-INTR] JUMP[STOPS] NORM $
: 2004	;CAN'T GET HERE FROM THERE...
	JUMP[.] $ ;HANG FOR NOW.
: 2005	;ECC ERRORS TRAP HERE
	DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
: 2006	;PC OV TRAPS HERE
;;;	DEST[CLR-DEV-FROM-INTR] JUMP[SOVRS] NORM $
	D[CONST 1] DEST[DEV-ADR] JUMP[SOVRS] NORM $
		;Start setting up to read AR enabling
: 2007 ;BOTH ECC AND OV (AT THE SAME TIME) TRAPS HERE
	DEST[CLR-DEV-FROM-INTR] JUMP[SECCS] NORM $
: 2010 ;NORMAL INDIRECT TRAPS HERE
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
	D[MEM] DEST[IR-23 MA AR] DISP[2374] SPEC[PC+1-IF] CYLEN[DISP] $
		;WHEN EXTEND HAPPENS, DISP[2176]? NO-- HOW WOULD WE SEE
		;EXTENDED AREA OF IX REG?
		;Changed from 2174 to 2374 to allow stop switch to stop
		;indirection loops.  TVR-Mar80
: 2012	;NORMAL INDEXING TRAPS HERE
	ALU[IX+D] D[IR] MASK[18.] DEST[AR IR-ADR MA] DISP[2024] SPEC[PC+1-IF] CYLEN[DISP]$
		;WHEN EXTEND HAPPENS, DISP[2026]
: 2014	;EXTENDED INDIRECT TRAPS HERE
; SOMETHING MAKES THIS DIFFERENT FROM 2010 -- MAYBE LOADING H.O. MA??
 JUMP[.] $	;FOR NOW ;;;ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
	D[MEM] DEST[IR-23 MA AR] DISP[2176] SPEC[PC+1-IF] CYLEN[DISP] $
: 2016	;EXTENDED INDEXING TRAPS HERE
 JUMP[.] $	;FOR NOW ;;;D[AR] ROT[6] MASK[4] DEST[AC-SEL] NORM $
	D[AR] ALU[D+AC] ACSEL[REG] DEST[IR-ADR MA AR] SPEC[PC+1-IF] DISP[2026] CYLEN[DISP] $
  ]




;UUO1 UUO2 SMAIN SMAIN1 MAIN NMAIN1 MAIN1 MAIN2 MSMAIN MSMAIN1 MUUO MUUO2 MUUO3 MUUO4 PIMUUO MUUO44
; UUOPJ MUUO5X MUUO5Y UAOP AREA216 UMOVE JSYS JSYS3 ADJSP XMOVEM1 DMOVE DMOVN KIFIX DMOVEM DMOVNM FIXR FLTR UFA DFN FSC
;------------------------------------------------------------------------------
;	User UUO Trap
;
;	Traps thru location 40 of the current space
;
;	Instruction is stored in 40 (with effective address computed and
;		index/indirection removed)
;	Instruction in location 41 is executed, in the current space.  It
;		customarily either jumps, saving the PC and flags, or halts.
;------------------------------------------------------------------------------
	.OPCODE[010]	;User UUOs 010:017
UUO1:	D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM  $
		;Setup MA for trap area and make mask for removing index/indir.
UUO2:	D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
		;Store instruction which caused trap.
.REPEAT 1 - KL [;IF BBN MAP, ALL THIS WORKS DIFFERENTLY
	D[PC] ALU[D-1] DEST[PC] MAPF[MASTO] CYLEN[MEMSTO] $
		;Ordinary page fault if not writable.  (*** Is PC correct???)
		;Backup the PC to point at the offensive instruction
];.REPEAT 1 - KL
.REPEAT KL [;IF KL MAP, NEED TO DO THE MAPF FIRST, THEN DECREMENT PC
;ELSE PAGE FAIL OR PAGE REFILL WILL BACK UP PC AGAIN.
	MAPF[MASTO] CYLEN[MEMSTO] $
		;WAIT FOR TRAP TO HAPPEN
	D[PC] ALU[D-1] DEST[PC] JUMP[UUO3] NORM $
		;OK, DECREMENT PC NOW THAT NO TRAP WILL HAPPEN

	.USE[AREA53]
];.REPEAT KL
UUO3:	D[CONST 41] DEST[MA] JUMP[NMAIN1] NORM $
		;Execute contents of (same space) location 41, usually a JSR or
		;a HALT instruction

	.ORG[2024]
SMAIN: ACSEL[MA] D[MEM] DEST[AC AR MA] SPEC[MA_PC] JUMP[NMAIN1] CYLEN[MEMSTO] MAPF[STO] $
SMAIN1:	D[MEM] SPEC[MA_PC] DEST[AR MA] JUMP[NMAIN1] CYLEN[MEMSTO] MAPF[STO] $

.REPEAT 1 - KL [
MAIN:	SPEC[MA_PC] DEST[MA CLR-DEV-FROM-INTR] NORM JPOP[MAIN1] $
	   ;START THE INSTR. FETCH (AND POP THE STACK A LITTLE...)
	   ;Also, clear forcing of interrupt device code, if still present

NMAIN1:
MAIN1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] 
	 JPOP[MAIN2] CYLEN[FIXM] $ ; I.E. FIXM ### AND FLUSH STACK ####

MAIN2:	D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $

AREA202 = .
];.REPEAT 1 - KL
.REPEAT KL [
MAIN:	SPEC[MA_PC] DEST[MA CLR-DEV-FROM-INTR] NORM COND[-HALF] JPOP[MAIN1] $
	   ;START THE INSTR. FETCH (AND POP THE STACK A LITTLE...)
	   ;Also, clear forcing of interrupt device code, if still present
	D[12] ROT[2] SPEC[A-MEM-APR] DEST[AR] COND[OBUS<0] C550 JPOP[MAINJRSTF] $
		;HALF IS ON, IF THE JRSTF TRAP FLAG IS ON, GO CLEAR IT AND TAKE A TRAP

NMAIN1:
MAIN1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[KLIFETCH] COND[-HALF]
	 JPOP[MAIN2] CYLEN[FIXM] $ ; I.E. FIXM ### AND FLUSH STACK ####

	D[12] MASK[36. - 3.] SPEC[A-MEM-APR] DEST[AR Q CLR-DEV-FROM-INTR] JPOP[MAIN1HALF] NORM $
		;GET AMEM STUFF IN AR AND Q AND GO CLEAR THE TRAP IN PROGRESS FLAGS
		;CLR-DEV-FROM-INTR WILL HAPPEN SO A-MEM-APR WILL HAPPEN.

MAIN2:	D[MEM] DEST[IR-ALL MA AR] SPEC[PC+1-IF&] DISP[2374] CYLEN[DISP] $
AREA202 = .			;A FEW LOCS LEFT
	.USE[AREA53]
;HERE FROM MAIN IF HALF WAS ON AND THE JRSTF TRAP FLAG IS ON.
; NEED TO CLEAR THE FLAG AND GENERATE THE PROPER TRAP BASED ON
; THE TRAP IN PROGRESS FLAGS IN AMEM.

MAINJRSTF:
	D[AR] MASK[35.] DEST[AR] NORM $
		;CLEAR THE JRSTF TRAP FLAG
	D[AR] ROT[36. - 2.] DEST[AR 2] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
		;STORE BACK INTO AMEM
	D[AR] ROT[2] MASK[2] DEST[AR] JUMP[DOTRPX] NORM $
		;GET TRAP IN PROGRESS BITS IN AR, DOTRPX WILL GENERATE
		; A TRAP.

;HERE FROM MAIN1 IF HALF FLAG WAS ON, WITH AMEM[2] IN AR AND Q WITH TP1, TP2, JRSTT
; CLEARED OUT.
;SET THE PC HALF FLAG FROM FPD BIT AND STORE THE BITS IN AMEM[2].

MAIN1HALF:
	D[AR] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
		;STORE BITS BACK INTO AMEM
	D[AR] ROT[3] COND[OBUS<0] C550 JUMP[MAIN2] $
		;IF FPD BIT ON IN AMEM, THEN LEAVE HALF SET
	SPEC[CLR-HALF] JUMP[MAIN2] SHORT $
		;ELSE CLEAR HARDWARE HALF FLAG AND REJOIN MAIN INSTRUCTION LOOP
];.REPEAT KL

	.PAIR
MSMAIN:	ACSEL[MA] D[MEM] DEST[AC] JUMP[MAIN] CYLEN[MEMSTO] MAPF[MASTO] $
MSMAIN1:	MAPF[MASTO] JUMP[MAIN] CYLEN[MEMSTO] $

	.OPCODE[020];	User UUOs 020-027
	UUOLOC $
AREA204 = .
	.OPCODE[030];	User UUOs 030-037
UUOGO:	UUOLOC $

AREA206 = .

;$*$*$*$ This should go somewhere else!!!
  .OPCODE[37]  ;Set loc. to 2 before MUUO (opcode 37 doesn't come here).
	       ;We come here (from 2000) on opcodes 0-7.
UUO0-7:	D[IR] ROT[9.] MASK[9.] COND[OBUS=0] JUMP[MUUO] C550 $;J IF 0 UUO
	UUOLOC $

	.OPCODE[040];	Monitor UUOs 040-047 (CALL,INIT,CALLI)
MUUO:	MUUO1
.REPEAT 1 - KL [
;The following need not be contiguous with MUUO, it is merely here for clarity.
;It may be moved to another area if necessary.	TVR-Apr80

;------------------------------------------------------------------------------
;	Monitor UUO Trap
;
;	Traps thru location 40 of the current space, typically to handle user 
;		request to the Monitor
;
;	Instruction is stored in 40 (with effective address computed and
;		index/indirection removed)
;	Instruction in Monitor 41 is executed, in the Monitor space.  It
;		should save PC and flags, and handle the user's request.
;------------------------------------------------------------------------------
MUUO2:	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $
		;Clear USER
	D[CONST 40] DEST[MA] PUSHJ[UUOPJ] NORM $
		;Setup MA for trap area and make mask for removing index/indir.
;	\ /
;Common code for instruction traps
MUUO3:	D[IR] ALU[D&Q] DEST[MEMSTO] NORM $
		;Store instruction which caused trap.
	D[MA] ALU[D+1] DEST[MA] CYLEN[MEMSTO] $
		;Now, get dispatch instruction
;------------------------------------------------------------------------------
;***  CAUTION:	If write fails, micro-machine hangs at 6100.  This should be
;***		fixed when a more general page-fault mechanism is added.  The
;***		best thing would be to just halt the macro machine.
;------------------------------------------------------------------------------
MUUO4:
PIMUUO:	D[CONST 55] ROT[2] DEST[Q FIXMAC-MAPF-RD] CYLEN[FIXM] $; JSR OPCODE
		;TVR-Apr80:  I don't have the foggiest notion what that FIXMAC
		;is supposed to do here.  The FIXM is needed for memory timing,
		;but aren't we guaranteed not to be fetching from ACs here????
];.REPEAT 1 - KL
.REPEAT KL [

PIMUUO:	D[CONST 55] ROT[2] DEST[Q] PUSHJ[MAPON] CYLEN[FIXM] $
		;SETUP JSR OPCODE, TURN MAP BACK ON
];.REPEAT KL
MUUO44:	D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSR] CYLEN[C650] $
		;Jump if trap instruction is a JSR (opcode 264 = 55*4)
	ALU[Q+1] DEST[Q] SHORT $
	D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSP] C550 $
		;Jump if trap instruction is a JSP (opcode 265)
	ALU[Q+1] DEST[Q] SHORT $
	D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSA] C550 $
		;Jump if trap instruction is a JSA (opcode 266)
.REPEAT 1 - KL [;JSYS NOT SPECIAL ON KL
	D[CONST 42] ROT[1] DEST[Q] SHORT $; JSYS OP
	D[MEM] ROT[11] MASK[11] ALU[D#Q] COND[OBUS=0] JUMP[MUJSYS] C550 $
		;Jump if trap instruction is a JSYS (opcode 104 = 42*2)
];.REPEAT 1 - KL
	D[PC] ALU[D-1] DEST[PC] SHORT $
		;Any other opcode will be XCTed and the regular code will
		;resume.
;------------------------------------------------------------------------------
;***  CAUTION:  No special dispensation has been made for BLKI/BLKO.  They
;***		MUST be handled specially, as if they DON'T skip, the
;***		second trap location should be executed and should be a JSR
;***		or some other instruction which saves flags.	TVR-Apr80
;------------------------------------------------------------------------------
	D[AR] DEST[CRYOV] JUMP[MAIN2] $
		;Else restore flags and dispatch
;------------------------------------------------------------------------------
;***  CAUTION:	This probably will not work proper if reference is being made
;***		to EXEC memory and trap was from USER.  What really needs to
;***		happen here is that the instruction should be XCTRed instead,
;***		It may be sufficient to SET-TEMP-EXEC.  I haven't looked at
;***		the problem seriously.				TVR-Apr80
;------------------------------------------------------------------------------

;Construct a mask which excludes indexing and indirection.  Used by UUO trap
;routines (and currently no where else)
UUOPJ:	D[MASK 37] ROT[27] DEST[Q] POPJ NORM $

;(NO SPACE IS LEFT.  You will have plant jumps to another area to expand the
; above code!)

	.OPCODE[050];	Monitor UUOs 050-057 (OPEN,INIT,RENAME,IN,OUT)

.REPEAT 1 - KL [
MUUO5X:	D[IR] ROT[7] MASK[1] DEST[Q] NORM $
		;Special check for UUOs actually used by monitors we care about
	D[IR] ROT[10] MASK[1] ALU[D#Q] COND[OBUS=0] JUMP[MUUO] C550 $
		;Jump if UUO 50,51,56, OR 57
	ALU[Q] COND[OBUS=0] JUMP[MUUO5Y] CYLEN[C450] $
		;Jump if 52 OR 53 ("Reserved for DEC")
	D[IR] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MUUO] C550 $
		;Jump if 55
MUUO5Y:	D[PC] DEST[Q AR] SHORT $
;	\ /
;------------------------------------------------------------------------------
;	Illegal Instruction Trap
;
;	Traps thru Monitor 60
;
;	Instruction is stored in 60 (with effective address computed and
;		index/indirection removed)
;	Instruction in Monitor 61 is executed, in the Monitor space.  It
;		should save PC and flags, and stop the offensive process.
;------------------------------------------------------------------------------
UAOP:	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $; CLR USER
	D[MASK 37] ROT[27] DEST[Q] NORM $
	D[CONST 60] DEST[MA] JUMP[MUUO3] NORM $

];.REPEAT 1 - KL
.REPEAT KL [
	MUUO1 $		;ON KL, NO ILLEGAL INSTRUCTION TRAP.
];.REPEAT KL

AREA212 = .	;$*$** Stupid interrupt code makes this unusable!
.REPEAT KL [
	.USE[AREA53]
MUUO2:	D[CONST 42] ROT[3] DEST[Q] PUSHJ[MAPOF] NORM $
		;GET READY TO COMPUTE RELATIVE ADDRESS TO UPT
		; AND TURN MAP OFF
	D[CONST 1] DEST[DEV-ADR] NORM $
		;UPT COMES FROM DEVICE 1
	D[16] MASK[13.] DEST[MA] NORM $
		;UPT PHYSICAL ADDRESS
	D[MA] ROT[9.] DEST[HI-ABS-MA MA] NORM $
		;CONVERT FROM 13 BIT PAGE NUMBER TO 22 BIT ADDRESS
	D[CONST 4] ALU[D+Q] DEST[Q] NORM $
		;Q NOW HAS 424, MA HAS UPT ADDRESS
	D[MA] ALU[D+Q] DEST[MA] PUSHJ[UUOPJ] NORM $
		;NOW MA HAS UPT+424, GET MASK IN Q TO CLEAR IND AND @
	D[AR] ALU[D&Q] DEST[MEMSTO] NORM $
		;START STORE OF INSTRUCTION THAT TRAPPED
	D[MA] ALU[D+1] DEST[MA AR] CYLEN[MEMSTO] $
		;OLD PC GOES INTO UPT+425, WAIT FOR WRITE TO COMPLETE OF 424
	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] C550 JUMP[MUUO3] $
		;JUMP IF DON'T NEED TO OR IN AMEM OVERFLOW FLAG
	D[CONST 1] ROT[35. - 0] DEST[Q] SHORT $
		;THE BIT TO OR IN
	D[PC] ALU[DORQ] DEST[MEMSTO AR] COND[-HALF] JUMP[MUUONT] NORM $
		;OR IN OVERFLOW TO PC, STORE IT IN AR AND MEMORY.
	JUMP[MUUOT] SHORT $
		;TRAP, GO DO IT.
MUUO3:	D[PC] DEST[MEMSTO AR] COND[HALF] JUMP[MUUOT] NORM $
		;STORE PC INTO UPT+425, JUMP IF HALF ON, MAY BE TRAP
MUUONT:	D[CONST 436 - 425] DEST[Q] COND[USER] JUMP[MUUOU] CYLEN[MEMSTO] $
		;GET CONSTANT TO ADD TO MA TO GET UPT+436
		;(MAKE USER MUUO A CYCLE FASTER)
	D[CONST 6] ALU[Q-D] DEST[Q] NORM $
		;WAS EXEC, TURN 436-7 INTO 430-1
MUUOU:	D[MA] ALU[D+Q] DEST[MA] NORM $
		;START THE NEW PC WORD IN
	ALU[0] DEST[HI-ABS-MA] CYLEN[FIXM] $
		;CLEAR HI PART OF MA OUT AND WAIT FOR PC WORD TO COME IN
	D[MEM] DEST[PC] PUSHJ[MAPON] NORM $
	D[MEM] DEST[CRYOV] JUMP[MAIN] NORM $


MUUOT:	D[12] SPEC[A-MEM-APR] ROT[2] MASK[2] COND[OBUS=0] C550 JUMP[MUUONT] $
		;HALF ON IF HERE, IF NO TRAP IN PROGRESS, JUST REJOIN.
		; ASSUME FPD MUST BE SET, SINCE JRSTT ONLY ON
		; AFTER JRST THAT SETS TRAP BITS
	D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[MUUOT1] $
		;PC WAS CORRECTLY STORED IF FPD IS ON
	D[AR] ROT[4] MASK[35.] DEST[AR] NORM $
		;CLEAR OUT FPD BIT IN PC AND
	D[AR] ROT[36. - 4] DEST[MEMSTO] NORM $
		;WRITE IT INTO UPT+425
MUUOT1:	D[MA] ALU[D+1] DEST[MA] JUMP[MUUONT] CYLEN[MEMSTO] $
		;INCREMENT MA TO CAUSE NEW PC TO COME FROM 431 OR 437
		; BECAUSE THIS MUUO IS A TRAP INSTRUCTION.
;-------------------------------------------------------------------
;
;AMEM[2] BLOCK 0 CONTAINS THE FOLLOWING BITS:
;
;0	TP0
;1	TP1	TRAP IN PROGRESS FLAGS - EITHER 0,1,2, OR 3.
;2	JRSTT	IF SET, A FLAG RESTORING JRST HAS SET TRAP BITS
;		AND FETCH OF INSTRUCTION AT NEW PC IS ABORTED IN FAVOR OF THE TRAP
;3	FPD	FIRST PART DONE STORED HERE WHEN HALF FLAG IN HARDWARE PC REG IS ON
;4	OVF	SAYS THAT OVERFLOW FLAG GOT SET WHEN PAGING AND TRAPS WERE ENABLED.
;		ALL EVENTS THAT STORE PC OR THIS INTO PC BIT 0. NECESSARY
;		BECAUSE MUST TURN OFF REAL OVERFLOW FLAG TO KEEP OVERFLOW MICRO
;		INTERRUPT ENABLED WITHOUT GETTING CONSTANT MICROINTERRUPTS.
;		NOTE THAT IF THIS IS OFF, REAL OVERFLOW FLAG MUST HAVE SAME EFFECT
;		AS IT USED TO ON THINGS, TO HANDLE CASE OF PAGER AND TRAPS BEING TURNED OFF.
;-------------------------------------------------------------------
DOTRPX:	D[12] SPEC[A-MEM-APR] MASK[36. - 3.] DEST[Q] NORM $
		;CLEAR OUT TRAP IN PROGRESS 1,2, AND JRSTT, LEAVE FPD SET FOR NOW
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[17] ROT[22.] COND[-OBUS<0] C550 JUMP[NOTRP] $
		;IF TRAP ENABLE IS CLEAR, DON'T DO TRAP, JUST FIX UP PC AND AMEM
	D[AR] ROT[36. - 2.] ALU[DORQ] DEST[2 Q] SPEC[A-MEM-APR&DEST-A-MEM]
	  COND[HALF] JUMP[DOTRX1] NORM $
		;SET THE APPROPRIATE TRAP BITS, LEAVE FPD ALONE IF HALF SET.
		; NORM CYCLE OK SINCE HALF IS SET AT BEG OF CYCLE
	D[CONST 1] ROT[35. - 3.] ALU[-D&Q] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
		;CLEAR OUT FPD SINCE HALF WAS OFF.
DOTRX1:	D[PC] ALU[D-1] DEST[PC] PUSHJ[SETHLF] NORM $
		;BACKUP PC (DISP AT MAIN2 AND PI CODE WILL INCREMENT IT AGAIN)
		; AND SET THE HALF FLAG SINCE TRAP FLAGS ARE ON.
	D[CONST 1] DEST[DEV-ADR] COND[USER] JUMP[DOTRPU] NORM $
		;GET READY TO READ UPT OR EPT ADDRESS, DISPATCH ON USER
	D[17] MASK[13.] DEST[HOLD] JUMP[DOTRPB] NORM $
		;EXEC, GET EPT PAGE NUMBER IN MEM
DOTRPU:	D[16] MASK[13.] DEST[HOLD] NORM $
		;EXEC, GET EPT PAGE NUMBER IN AR
DOTRPB:	D[MEM] ROT[9.] DEST[Q] NORM $
		;CONVERT TO ADDRESS, PUT INTO Q
	D[AR] ALU[D+Q] DEST[Q] PUSHJ[MAPOF] NORM $
		;ADD OFFSET OF TRAP INTO EPT OR UPT ADDRESS
	D[CONST 42] ROT[3] ALU[D+Q] DEST[HI-ABS-MA MA] NORM $
		;AND STORE FINAL ADDRESS INTO MA TO START THE READ
	ALU[0] DEST[HI-ABS-MA] PUSHJ[MAPON] CYLEN[FIXM] $
		;CLEAR OUT HI MA PART, TURN ON MAP, AND
		;WAIT FOR DATA TO GET INTO MEM AND THEN GO DO THE INSTRUCTION
	JUMP[MAIN2] SHORT $
		; MIGHT PAGE FAULT OR GET INTERRUPT.

;HERE IF TRAP ENABLE IS OFF, AMEM[2] WITH TIX AND JRSTT CLEARED IN Q.
; MUST SET HALF FLAG TO HALF .AND. FPD IN CASE JRSTF SET HALF FLAG.

NOTRP:	ALU[Q] SPEC[A-MEM-APR&DEST-A-MEM] DEST[AR 2] COND[-HALF] JUMP[MAIN] NORM $
		;SET AMEM[2] PROPERLY, AND EXECUTE NEXT INSTRUCTION IF HALF IS OFF.
;HALF IS ON, COULD EITHER BE LEGIT OR SET BY JRSTF BECAUSE IT SET
; THE TRAP FLAGS WHICH WE NOW HAVE CLEARED. SET HALF TO SETTING OF
; FPD.
	D[AR] ROT[4] COND[OBUS<0] C550 JUMP[MAIN] $
		;JUMP IF FPD IS ON IN AMEM.
	SPEC[CLR-HALF] JUMP[MAIN] NORM $
		;WASN'T ON, SO TURN HALF OFF AGAIN.
		;AND EXECUTE NEXT INSTRUCTION
];.REPEAT KL

	.OPCODE[060];	Monitor UUOs 060-067
			;(SETSTS,STATO,GETSTS,STATZ,INBUF,OUTBUF,INPUT,OUTPUT)
	MUUO1 $
;;;AREA214 = .
area214 = 2142		;Sigh... Another fixed location
	.OPCODE[070];	Monitor UUOs 070-077
			;(CLOSE,RELEAS,MTAPE,UGETF,USETI,USETO,LOOKUP,ENTER)
	MUUO1 $
AREA216:

	.OPCODE[100];	UMOVE
.REPEAT 1 - KL [
UMOVE:	D[PC] ALU[D-1] DEST[MA PC] NORM $ ;RE-FETCH INSTR.
	FIXM1 JUMP[UMOVX] $	;WAIT FOR FETCH.

; UMOVEI, UMOVEM, UMOVES
	.REPEAT 3 [ JUMP[UMOVE] NORM $
			NOP $ 
  		]
];.REPEAT 1 - KL
.REPEAT KL [
  .REPEAT 4 [
	MUUO1 $
	NOP $
  ];.REPEAT 4
];.REPEAT KL

	.OPCODE[104];	JSYS
JSYS:
.REPEAT 1 - KL [
.REPEAT 1 - WAITS [
	D[IR] ROT[33] MASK[11] COND[-OBUS=0] JUMP[JSYS1] C550 $; J IF NOT EX JSYS
];.REPEAT 1 - WAITS
.REPEAT WAITS [
;EX JSYS is disabled in WAITS' BBN pager.  We simulate the same.
	JUMP[JSYS1] NORM $
];.REPEAT WAITS
JSYS3:	D[PC] DEST[Q AR] JUMP[JSYS2] $; GET PC & FLAGS
];.REPEAT 1 - KL
.REPEAT KL [;NO JSYS ON KL
	MUUO1
];.REPEAT KL

	.OPCODE[105];	ADJSP
ADJSP:	D[IR] ROT[22] MASK[0] ALU[D+AC] SPEC[LEFT] DEST[Q]
			COND[OBUS<0] JUMP[ADJSP1] C550$
		;Jump if left result is negative
	D[IR] MASK[22] ALU[D+AC] DEST[AR] JUMP[ADJSP2] NORM $	;Add right half
	;(Continued just before TYMNET code)

	.OPCODE[106]	;XMOVEM
.REPEAT 0 [;NEEDS TO HAVE MAPF FIELD OF SOME SORT
	ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
	ALU[AC] DEST[MEMSTO] NORM JUMP[XMOVEM1] $
	.USE[AREA204]
XMOVEM1: ALU[0] DEST[HI-ABS-MA] NORM JUMP[MAIN] $
];.REPEAT 0
.REPEAT 1 [
	MUUO1 $
	NOP $
];.REPEAT 1

	.OPCODE[107]	;XMOVE
.REPEAT 0 [
	ALU[AC] ACSEL[AC+1] DEST[HI-ABS-MA MA] NORM $
	ALU[0] DEST[HI-ABS-MA] JUMP[2401] NORM $
];.REPEAT 0
.REPEAT 1 [
	MUUO1 $
	NOP $
];.REPEAT 1

;Illegal instructions (?)
	.REPEAT 117 - 110 + 1
[	UAOP1 $
	NOP $
	]

	.OPCODE[120]	;DMOVE
DMOVE:	FIXM1 $			; Fetch first word
	ACSEL[AC] D[MEM] DEST[AC] JUMP[DMOVE2] CYLEN[FIXM+1] $
		;Put it in an AC [*** Is CYLEN right? ***]
	;(Continued just before TYMNET code)

	.OPCODE[121]	;DMOVN
DMOVN:	FIXM1 $	;Fetch first word
	ACSEL[AC] D[MEM] ALU[NOTD] DEST[AC] SPEC[CRYOV]
			JUMP[DMOVN2] CYLEN[FIXM+1] $
		;Ones complement high order word.  Set result flags
	;(Continued just before TYMNET code)

	.OPCODE[122]	;KIFIX
KIFIX:	FIXM1 $	;Fetch first word
	D[CONST 33] DEST[Q] JUMP[KIFIX1] NORM $
		;Start making magic constant
	;(Continued just before TYMNET code)

;123
	UAOP1 $
	NOP $

	.OPCODE[124]	;DMOVEM
;*** Note: Like on the KI10, DMOVEM AC,AC+1 will lose.
DMOVEM:	FIXM2 $			; Make sure first word is in core
	ACSEL[AC] ALU[AC] DEST[MEMSTO] COND[-MA-AC] LBJUMP[DMOVM2] NORM $
		;Store first word.  Decide where it really goes.
	;(Continued just before TYMNET code)
	.OPCODE[125]	;DMOVNM
;*** Note: Like on the KI10, DMOVNM AC,AC+1 will lose.
DMOVNM:	FIXM2 $			; Make sure first word is in core
	ACSEL[AC] ALU[NOTAC] DEST[AR] SPEC[CRYOV] JUMP[DMVNM2] NORM $
		;Ones complement high order word, leave result in IR
	;(Continued just before TYMNET code)

	.OPCODE[126]	;FIXR
FIXR:	FIXM1 $	;Fetch first word
	D[CONST 04] ROT[24.] DEST[Q] JUMP[FIXR1] NORM $
		;Start making constant 0.5
	;(Continued just before TYMNET code)

	.OPCODE[127]	;FLTR
FLTR:	FIXM1 $	;Fetch first word
	D[MEM] DEST[AR] JUMP[FLTR1] $
		;Setup for normalize

	.OPCODE[130]	;UFA
UFA:	FIXM1 $
	D[CONST 11] DEST[DEV-ADR] JUMP[UFA1] $

	.OPCODE[131]	;DFN
DFN:	FIXM2 $
	D[MEM] MASK[27.] ALU[0-D] DEST[AR] COND[OBUS=0] LBJUMP[DFN1] C600 $

	.OPCODE[132]	;FSC
FSC:	D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[FSCZAP] C550 $
	ACSEL[AC] ALU[AC] DEST[AR] JUMP[FSC1] NORM $




;IBP ILDB LDB IDPB DPB FAD FSB FMP FDV
;------------------------------------------------------------------------------
;
;	Byte Manipulation Instructions
;
;------------------------------------------------------------------------------
	.OPCODE[133]	;IBP (and ADJBP)
IBP:
.REPEAT 1 - KL [;IF NOT KL, HALF FLAG IS SAME AS PC FPD
	FIXM2 COND[HALF] JUMP[MAIN] $
];.REPEAT 1 - KL
.REPEAT KL [;IF KL, FIRST PART DONE IS HALF .AND. FPD IN AMEM
	FIXM2 COND[HALF] JUMP[IBP0] $
		;JUMP IF NEED TO CHECK FPD IN AMEM
];.REPEAT KL
		;A no-op if we're already incremented.
	D[MEM] DEST[Q AR] COND[AC=0] LBJUMP[IBP1] NORM $
		;Get byte pointer and decide if it's an ADJBP or a IBP

	.OPCODE[134]	;ILDB
ILDB:	FIXM2 $
	D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[ILDB1] NORM $

	.OPCODE[135]	;LDB
LDB:	FIXM1 $
	D[MEM] DEST[Q AR MA] COND[-MEM-IDX-IND] LBJUMP[LDB1] CYLEN[C500] $

IDPB:	.OPCODE[136]	;IDPB
	FIXM2 $
	D[MEM] DEST[Q AR] COND[-HALF] LBJUMP[IDPB1] NORM $

	.OPCODE[137]	;DPB
DPB:	FIXM1 $
	D[MEM] DEST[Q AR MA] LBJUMP[DPB1] COND[-MEM-IDX-IND] CYLEN[C500]  $

;------------------------------------------------------------------------------
;
;	Single Procession Floating Point
;
;------------------------------------------------------------------------------

;
;FAD FADL FADM FADB FADR FADRI FADRM FADRB
;
	.OPCODE[140]		;Opcodes 140-147
FAD:	FIXM1 JUMP[FAOS1] $ NOP $
	FIXM1 JUMP[FAOS2] $ NOP $
	FIXM2 JUMP[FAOS3] $ NOP $
	FIXM2 JUMP[FAOS4] $ NOP $
	FIXM1 JUMP[FAOS1] $ NOP $
	D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
	FIXM2 JUMP[FAOS3] $ NOP $
	FIXM2 JUMP[FAOS4] $ NOP $

;
;FSB FSBL FSBM FSBB FSBR FSBRI FSBRM FSBRB
;
.DEFINE FSBMAC[X] [
	D[MEM] ALU[0-D] DEST[HOLD] JUMP[X] NORM 
]
	.OPCODE[150]		;Opcodes 150-157
FSB:	FIXM1 $ FSBMAC[FAOS1] $
	FIXM1 $ FSBMAC[FAOS2] $
	FIXM2 $ FSBMAC[FAOS3] $
	FIXM2 $ FSBMAC[FAOS4] $
	FIXM1 $ FSBMAC[FAOS1] $
	D[MA] ROT[18.] DEST[HOLD] ALU[0-D] SPEC[LEFT] JUMP[FAOS5] NORM $ NOP $
	FIXM2 $ FSBMAC[FAOS3] $
	FIXM2 $ FSBMAC[FAOS4] $

;
;FMP FMPL FMPM FMPB FMPR FMPRI FMPRM FMPRB
;
	.OPCODE[160]		;Opcodes 160-167
FMP:	FIXM1 JUMP[FMP1] $ NOP $
	FIXM1 JUMP[FMP2] $ NOP $
	FIXM2 JUMP[FMP3] $ NOP $
	FIXM2 JUMP[FMP4] $ NOP $
	FIXM1 JUMP[FMP1] $ NOP $
	D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] JUMP[FMP5] NORM $ NOP $
	FIXM2 JUMP[FMP3] $ NOP $
	FIXM2 JUMP[FMP4] $ NOP $

;FDV FDVL FDVM FDVB FDVR FDVRI FDVRM FDVRB
.DEFINE DIVMAC[X] [
	D[CONST 11] DEST[DEV-ADR] JUMP[X] NORM
]
	.OPCODE[170]		;Opcodes 170-177
FDV:	FIXM1 $ DIVMAC[FD1] $
	FIXM1 $ DIVMAC[FD2] $
	FIXM2 $ DIVMAC[FD3] $
	FIXM2 $ DIVMAC[FD4] $
	FIXM1 $ DIVMAC[FD1] $
	D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $ DIVMAC[FD1] $
	FIXM2 $ DIVMAC[FD3] $
	FIXM2 $ DIVMAC[FD4] $



;MOVE MOVE1 MOVEI MOVEM MOVES MOVS MOVSI MOVSM MOVSS MOVN MOVNI MOVNM MOVNS MOVM MOVM1 MOVMI MOVMM MOVMS MOVMS1 MOVMS3 MOVMS4 MOVMS5 MOVMS6 MOVMS2
;------------------------------------------------------------------------------
;
;	MOVE Group
;
;------------------------------------------------------------------------------

	.OPCODE[200]	;MOVE
MOVE:	FIXM1 $
		;Wait for memory, handle page faults, and fixup AC references
MOVE1:	ACSEL[AC] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
		;Store result of read in AC
		;Start next instruction fetch (DEST[MA] refers to SPEC[MA_PC])
		;We are referring to the AC specified by the AC field in the IR

	.OPCODE[201]	;MOVEI
MOVEI:	ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Store effective address into AC
		;Ignore any page faults or other memory related problems.  Read
		;will be ignored (except for ECC checking)
		;Start next instruction fetch (DEST[MA] refers to SPEC[MA_PC])
		;We are referring to the AC specified by the AC field in the IR

	.OPCODE[202]	;MOVEM
MOVEM:	ACSEL[AC] ALU[AC] DEST[MEMSTO]  MEMST $
		;Start writing AC (selected by AC field in IR) into memory.
		;MEMST macro will send us to MSMAIN (if we're writing to
		;another AC) or MSMAIN1 (if it's a real memory reference)
		;to complete to store.

	.OPCODE[203]	;MOVES
MOVES:	FIXM1 COND[-AC=0] JUMP[MOVE1]  $
		;If AC field (in IR) is non-zero, we treat this as if it
		;were a MOVE instruction (a slight fudge).
		;*** Shouldn't this be a FIXM2?  Then it would do the right
		;*** thing for the clever person trying to fetch and dirty
		;*** a page.   TVR-Apr80
	D[MEM] DEST[MEMSTO] MEMST $
		;If AC field is zero, this is a no-op which writes memory.

	.OPCODE[204]	;MOVS
MOVS:	FIXM1 $
	ACSEL[AC] D[MEM] ROT[18.] DEST[AC MA] SPEC[MA_PC]
			JUMP[MAIN1] CYLEN[FIXM+1] $
		;Rotating by 18 swaps halves.  Otherwise, it's just like a MOVE

	.OPCODE[205]	;MOVSI
MOVSI:	ACSEL[AC] D[IR] ROT[18.] DEST[AC MA] SPEC[LEFT&MA_PC] JUMP[MAIN1] NORM$
		;Just like a MOVEI except it puts the result in the left half
		;of the AC.  (SPEC[LEFT] makes a mask of -1,,0)

	.OPCODE[206]	;MOVSM
MOVSM:	ALU[AC] ACSEL[AC] DEST[AR] NORM $
	D[AR] ROT[18.] DEST[MEMSTO] MEMST $
		;Swap halves and write it into memory like a MOVEM

	.OPCODE[207]	;MOVSS
MOVSS:	SLFFXM[MOVSS1] $
		;Finish read fetch of read-modify-write type cycle.
		;Check to make sure effective address is writable.
		;Jump if AC field in IR is non-zero
	D[MEM] ROT[18.] DEST[MEMSTO] MEMST $
		;Swap halves and write backing into same place in memory.

;*$*$*$ Move MOVSS1 here, a single instruction

	.OPCODE[210]	;MOVN
MOVN:	FIXM1 $
	ACSEL[AC] D[MEM] ALU[0-D] DEST[AC MA] SPEC[CRYOV&MA_PC]
			JUMP[MAIN1] CYLEN[FIXM+1] $
		;Like MOVE except it negates the number it loads.
		;Set flags.  400000,,0 will overflow.

	.OPCODE[211]	;MOVNI
MOVNI:	ACSEL[AC] D[IR] ALU[0-D] MASK[18.] DEST[AC MA] SPEC[CRYOV&MA_PC]
			JUMP[MAIN1] NORM $
		;Like MOVEI except that it load a negative number
		;Set flags.  Cannot overflow.

	.OPCODE[212]	;MOVNM
MOVNM:	ACSEL[AC] ALU[0-AC] DEST[MEMSTO] SPEC[CRYOV] MEMST $
		;Write negative of AC into memory.
		;Set flags.  400000,,0 will overflow.

	.OPCODE[213]	;MOVNS
MOVNS:	SLFFXM[MOVNS1] $
		;Complete fetch of read-modify-write
		;Jump if AC field (of IR) is non-zero, i.e. it loads an AC
	D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] MEMST $
		;Write negative of number read back into memory.

;
; MOVM - Move Magnitude (Absolute value)
;
	.OPCODE[214]	;MOVM
MOVM:	FIXM1 $	;Complete data fetch
	ACSEL[AC] D[MEM] DEST[AC] COND[OBUS<0] LBJUMP[MOVM1] C600 $
		;Load number.
		;If negative, negate it to make it positive.
		;In either case, start fetch of next instruction
	.USE[AREA214]	;$*$*$ Random hole
	.PAIR
MOVM1:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
		;Number is positive, leave it alone
		;Start next instruction fetch
	ACSEL[AC] ALU[0-AC] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] NORM$
		;Number is negative, make it positive.
		;Start next instruction fetch

	.OPCODE[215]	;MOVMI
MOVMI:	ACSEL[AC] D[IR] MASK[18.] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Immediate implies it's positive.  Equivalent to MOVEI

	.OPCODE[216]	;MOVMM
MOVMM:	ACSEL[AC] ALU[AC] COND[OBUS<0] JUMP[MOVNM] CYLEN[C450] $
		;If AC is negative, store its negation and set flags
		;Note:  It will set overflow if AC contains 400000,,0
	ACSEL[AC] ALU[AC] DEST[MEMSTO] SPEC[CRYOV] MEMST $
		;Otherwise, store positive form.  (Both paths take same amount
		;of time.)
		;Also, set flags.

	.OPCODE[217]	;MOVMS
MOVMS:	COND[MA-AC] JUMP[MOVMS2]
			DEST[FIXMAC-MAPF-WRT] MAPF[NORM-WRT] CYLEN[FIXM]$
		;Finish fetch of read-modify-write
		;Jump if we have to deal with two ACs
	COND[AC=0] LBJUMP[MOVMS1] NORM $
		;Split off case where we load AC as side effect
	.USE[AREA204]
	.PAIR
MOVMS1:	D[MEM] COND[OBUS<0] LBJUMP[MOVMS3] C550 $
		;AC field of IR is non-zero, AC is loaded as side effect
	D[MEM] COND[OBUS<0] LBJUMP[MOVMS4] C550 $
		;Reference is only to memory
	.PAIR
MOVMS3:	D[MEM] ACSEL[AC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
		;Memory location is positive, just load AC
	D[MEM] ALU[0-D] ACSEL[AC] DEST[MEMSTO AC] SPEC[CRYOV] MEMST $
		;Load AC with negative of memory and write negative back
		;into memory.
		;Set flags.  Will overflow if memory contains 400000,,0
	.PAIR
MOVMS4:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
		;Memory is positive.  Don't have to do anything here.
	D[MEM] ALU[0-D] DEST[MEMSTO] SPEC[CRYOV] JUMP[MSMAIN1] NORM $
		;Memory is negative.  Store negation.
		;Set flags.  Will overflow if memory contains 400000,,0
;Special cases for references to two ACs
	.PAIR
MOVMS5:	ACSEL[MA] ALU[0-AC] DEST[AC AR] SPEC[CRYOV]
			COND[AC=0] LBJUMP[MOVMS6] NORM $
		;'memory' AC is negative, negate it and put it somewhere
		;the other AC loaded from.
		;Then, decide whether to load it into another AC
	ACSEL[MA] ALU[AC] DEST[AR] COND[AC=0] LBJUMP[MOVMS6] NORM $
		;'memory' AC is positive.  Put it somewhere the other AC
		;can reference.
		;Decide whether to load it into	another AC
	.PAIR
MOVMS6:	ACSEL[AC] D[AR] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;AC field (of IR) is non-zero, load corresponding AC from
		;saved value of 'memory' AC.
		;Start next instruction fetch
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
		;AC field (of IR) is zero, just start next instruction fetch
;	---
;MA refers to an AC.  Decide which special case we're dealing with.
MOVMS2:	ACSEL[MA] ALU[AC] COND[-OBUS<0] LBJUMP[MOVMS5] CYLEN[C500] $
		;Decide sign of 'memory' AC




;------------------------------------------------------------------------------
;
;	Integer Multiply
;
;------------------------------------------------------------------------------

	.OPCODE[220]	;IMUL
	FIXM1 $
	D[MEM] DEST[Q] JUMP[IMUL1] NORM $

	.OPCODE[221]	;IMULI
	D[IR] MASK[18.] DEST[Q] JUMP[IMUL1] NORM $

	.OPCODE[222]	;IMULM
	FIXM2 $
	D[MEM] DEST[Q] JUMP[IMUL2] NORM $

	.OPCODE[223]	;IMULB
	FIXM2 $
	D[MEM] DEST[Q] JUMP[IMUL3] NORM $

	.OPCODE[224]	;MUL
	FIXM1 $
	D[MEM] DEST[Q] JUMP[MUL1] NORM $

	.OPCODE[225]	;MULI
	D[IR] MASK[18.] DEST[Q] JUMP[MUL1] NORM $

	.OPCODE[226]	;MULM
	FIXM2 $
	D[MEM] DEST[Q] JUMP[MUL2] NORM $

	.OPCODE[227]	;MULB
	FIXM2 $
	D[MEM] DEST[Q] JUMP[MUL3] NORM $

;*$*$* Move rest of multiply code here

;------------------------------------------------------------------------------
;
;	Integer Divide
;
;------------------------------------------------------------------------------

	.OPCODE[230]	;IDIV
	FIXM1 $
IDIV9:	ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV1] CYLEN[C500] $
		;LO PART TO Q, CHECK SIGN

	.OPCODE[231]	;IDIVI
	D[IR] MASK[18.] DEST[HOLD] JUMP[IDIV9]  NORM $ ;IMMD

	.OPCODE[232]	;IDIVM
	FIXM2 $
	ALU[AC] ACSEL[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV2]  CYLEN[C500] $
		;LO PART TO Q, SAVE AC, CHECK SIGN

	.OPCODE[233]	;IDIVB
	FIXM2 $
	ACSEL[AC] ALU[AC] DEST[Q AR] COND[-OBUS<0] LBJUMP[IDIV3] CYLEN[C500] $

	.OPCODE[234]	;DIV
	FIXM1 $
DIV9:	ACSEL[AC+1] ALU[AC] DEST[Q] JUMP[DIV1] $ ;LO PART

	.OPCODE[235]	;DIVI
	D[IR] MASK[18.] DEST[HOLD] JUMP[DIV9] $ ;IMMD

	.OPCODE[236]	;DIVM
	FIXM2 $
	ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV2] $

	.OPCODE[237]	;DIVB
	FIXM2 $
	ALU[AC] ACSEL[AC+1] DEST[Q] JUMP[DIV3] $

;$*$*$	Move rest of divide code here

;------------------------------------------------------------------------------
;
;	Shifts and Rotates
;
;	Two branches are taken for each shift/rotate, depending on direction.
;	The macro SH1ST handles that.  The positive case gets ROTR loaded by
;	that macro and other negative case will have to load it itself.
;
;	Note that by the time we get here, indexing and indirection have
;	already been done, so the left half of the IR contains an honest
;	shift count, albeit not necessarily in the range -35..35
;
;------------------------------------------------------------------------------
   .DEFINE SH1ST [LAB1 LAB2]
[	D[IR] COND[OBUS18] DEST[Q] JUMP[LAB1] C550 $
	D[IR] MASK[10] DEST[Q ROTR] JUMP[LAB2] NORM $
]

	.OPCODE[240]	;ASH
	SH1ST [ASHNEG ASHPLS]

	.OPCODE[241]	;ROT
	SH1ST [ROTNEG ROTPLS]

	.OPCODE[242]	;LSH
	SH1ST [LSHNEG LSHPLS]

	.OPCODE[243]	;JFFO (a funny kind of shift instruction)
	ACSEL[AC] ALU[AC] COND[OBUS=0] JUMP[JFFO1] DEST[AR] CYLEN[C450] $
	ACSEL[AC+1] ALU[0] DEST[AC] JUMP[JFFO2] NORM $

	.OPCODE[244]	;ASHC
	ACSEL[AC+1] D[MASK 43] ALU[D&AC]   DEST[AR] NORM $
	D[AR] ROT[1] DEST[Q] JUMP[ASHC1] NORM $

	.OPCODE[245]	;ROTC
	ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
	D[IR] COND[-OBUS18] LBJUMP[ROTC1] C550 $

	.OPCODE[246]	;LSHC
	ACSEL[AC+1] ALU[AC] DEST[Q]   NORM $
	D[IR] COND[-OBUS18] LBJUMP[LSHC1] C550 $

	.OPCODE[247]	;(KAFIX at SAIL: "A. Kotok should have done this")
	ACSEL[AC] ALU[AC] DEST[HOLD AR] COND[-OBUS<0] JUMP[KAFIXP] C550 $
		;Load up things for FIXER, check for positive mantissa
	ACSEL[AC] ALU[0-AC] DEST[AR] JUMP[KAFIXN] NORM $
		;Negate AR so that its exponent can be used.



;------------------------------------------------------------------------------
;	Exchange AC and memory
;------------------------------------------------------------------------------
	.OPCODE[250]	;EXCH
	FIXM2 $
		;Finish fetch of read-modify-write, checking for faults
	ACSEL[AC] D[MEM] DEST[MEMSTO O_AC] MEMST $
		;Store result of fetch into AC, writing the old contents of
		;that AC into memory (O_AC means store new AC and output old
		;contents).

;------------------------------------------------------------------------------
;	Block Transfer Instruction
;------------------------------------------------------------------------------
	.OPCODE[251]	;BLT
	D[MASK 16] ROT[4] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA1] C550 $ ;J IF DEST IS AC
	D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[-OBUS=0] LBJUMP[BLTA2] C600 $ ; J ON SRC NOT AC

;------------------------------------------------------------------------------
;	Conditional jumps which add one to both halves
;
;  Caution:	With these instructions, overflow from the right half will be
;		added to the left half, as on a KA.
;------------------------------------------------------------------------------
	.OPCODE[252]	;AOBJP
	D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC]
			COND[OBUS<0] JUMP[MAIN] C600 $
		;Add to both halves.  If result is negative, do not jump
	DOJUMP $

	.OPCODE[253]	;AOBJN
	D[CONST 1,,1] ACSEL[AC] ALU[D+AC]   DEST[AC]
	  COND[-OBUS<0] JUMP[MAIN] C600 $
	DOJUMP $

;------------------------------------------------------------------------------
;	Jump Instructions (and halts)
;
;  Caution:	Halts set PC to effective address instead of the instruction
;		that caused the halt.  This is especially bad because most
;		programs which do not use UUOs place a halt in location 40,
;		and the location of the UUO is then lost on an F2.  This
;		might be cured by replicating the instruction fetch seqeunce
;		herein with the copying of the IR into the PC happening later
;		during that sequence.
;------------------------------------------------------------------------------
	.OPCODE[254]	;JRST
	D[IR] DEST[MA PC] COND[AC=0] JUMP[MAIN1] NORM $
		;Make ordinary jumps as fast as possible.  Always load the PC
		;from the effective address, even on halts!?!
	D[IR] ROT[12] MASK[1] COND[OBUS=0] LBJUMP[JRST1] C550 $
		;Seperate according to the 10 bit of the AC field.

	.OPCODE[255]	;JFCL
	D[IR] ROT[15] MASK[4] DEST[AR] COND[AC=0] JUMP[MAIN] NORM $
		;Check AC field and jump to instruction fetch if zero.
		;JFCL 0,  is the fastest no-op on a KA
	D[PC] DEST[Q] JUMP[JFCL1] NORM $

	.OPCODE[256]	;XCT
	FIXM1 COND[-AC=0] JUMP[XCT1] $
	D[PC] ALU[D-1] DEST[PC] JUMP[XCT2] NORM $

	.OPCODE[257]	;A No-Op on KA's not having special features
.REPEAT 1 - KL [
	JUMP[MAIN] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
	JUMP[MAP] NORM $
];.REPEAT KL

;------------------------------------------------------------------------------
;
;	Stack Instructions
;
;  Caution:	If a stack crosses zero (i.e. a carry from the right half
;		occurs, the left half will be off by one, as on a KA
;		(People who wrap their stacks around and thru ACs deserve to
;		lose!)
;------------------------------------------------------------------------------
	.OPCODE[260]	;PUSHJ
.REPEAT 1 - KL [
	ACSEL[AC] D[CONST 1,,1] ALU[D+AC]   DEST[AC MA]
	  COND[CRY0] JUMP[PDLO1] C600 $
		;Increment stack pointer.
		;Jump on overflow (overflow code will complete instruction)
	D[PC] DEST[MEMSTO] JUMP[PUSHJ1] NORM $
		;Store the PC and flags on the stack
];.REPEAT 1 - KL
.REPEAT KL [
	ACSEL[AC] D[CONST 1,,1] ALU[D+AC]   DEST[AC MA]
	  COND[CRY0] JUMP[PDLO1] C600 $
		;Increment stack pointer.
		;Jump on overflow (overflow code will complete instruction)
	D[PC] DEST[Q] JUMP[PUSHJ0] SHORT $
		;On KL, need to OR in the fake overflow flag in AMEM.
		; (Could have saved if real flag was on here, but whats
		; the use, its always off if map is turned on anyway)
		;Store the PC and flags on the stack
		;(NOTE Q ADDED HERE)
];.REPEAT KL

	.OPCODE[261]	;PUSH
	FIXM1 $
		;Complete fetch of thing to push
	D[MEM] DEST[AR] JUMP[PUSH1] NORM $
		;Move it somewhere else so we set MA to point to stack.
		;(Setting the MA implies a read, which would destroy the thing
		;to push).
		;*$*$* Go elsewhere to finish instruction

	.OPCODE[262]	;POP
	ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC]
			COND[-CRY0] JUMP[PDLO3] C600 $
		;Decrement stack pointer, but setting the MA to the old top of
		;stack.
		;If stack underflow, jump.  (Underflow code will finish the
		;instruction).
	 MAPF[PPOP] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
			JUMP[POP1] CYLEN[FIXM] $
		;If page fault, trap to special code to handle POP
		;*$*$* Go elsewhere to finish instruction

	.OPCODE[263]	;POPJ
	ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC]
			COND[-CRY0] JUMP[PDLO4] C600 $
		;Decrement stack pointer, but setting the MA to the old top of
		;stack.
		;If stack underflow, jump.  (Underflow code will finish the
		;instruction).
	MAPF[PPOP] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
			JUMP[POPJ1] CYLEN[FIXM] $
		;If page fault, trap to special code to handle POP
		;*$*$* Go elsewhere to finish instruction

	.OPCODE[264]	;JSR
.REPEAT 1 - KL [
	FIXM2 JUMP[JSR1] $
];.REPEAT 1 - KL
.REPEAT KL [
	FIXM2 COND[-HALF] JUMP[JSR1] $
	D[PC] DEST[Q] SHORT JUMP[HFJSR] $
		;PUT PC INTO Q FOR MODIFICATION IF NECESSARY.
	.USE[AREA53]

HFJSR:	D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[HFJSR1] $
		;JUMP IF FPD ON IN AMEM (THEN HALF SET IN PC OK)
	D[CONST 1] ROT[35. - 4] ALU[-D&Q] DEST[Q] SHORT $
		;NOT REALLY SUPPOSED TO BE ON, CLEAR IT.
HFJSR1:	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] C550 JUMP[HFJSR2] $
		;JUMP IF FAKE OVERFLOW BIT IS OFF. ELSE
	D[CONST 1] ROT[35. - 0] ALU[DORQ] DEST[Q] NORM $
		;SET IT IN PC.
HFJSR2:	ALU[Q] DEST[MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
	D[MA] ALU[D+1] DEST[MA PC] MAPF[STO] SPEC[CLR-HALF] JUMP[MAIN1] CYLEN[MEMSTO] $

];.REPEAT KL

	.OPCODE[265]	;JSP
.REPEAT 1 - KL [
	D[PC] ACSEL[AC] DEST[AC] NORM $
		;Store PC (and flags) in AC
];.REPEAT 1 - KL
.REPEAT KL [
	D[PC] ACSEL[AC] DEST[AC] COND[-HALF] LBJUMP[JSP0] NORM $
		;For KL, need to check fake overflow bit.
];.REPEAT KL
JSP1:	D[MA] DEST[PC] JUMP[MAIN1] SPEC[CLR-HALF] NORM $
		;Jump to effective address
		;Make sure some nurd hasn't left the BIS flag on. (*** i assume
		;  that's what going on here.  TVR-Apr80)
.REPEAT KL [
	.USE[NORMAL]
	.PAIR
JSP0:	D[12] SPEC[A-MEM-APR] ROT[3] COND[-OBUS<0] JUMP[HFJSP] C550 $
		;JUMP IF FPD NOT ON IN AMEM, ELSE FALL INTO NORMAL CASE
JSP2:	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] C550 JUMP[JSP1] $
		;Jump if fake overflow not on.
	D[CONST 1] ROT[35. - 0] ACSEL[AC] ALU[DORAC] DEST[AC] JUMP[JSP1] NORM $
		;fake overflow bit on, turn it on in PC.
		;STORE PC AND FLAGS IN AC, JUMP IF NEED TO SEE IF FPD IS CORRECT
HFJSP:	D[CONST 1] ROT[35. - 4.] ACSEL[AC] ALU[-D&AC] DEST[AC] JUMP[JSP2] SHORT $
		;TURN OFF FPD IN PC AND COMPLETE THE INSTRUCTION.
	
];.REPEAT KL

	.OPCODE[266]	;JSA
	FIXM2 $
	D[PC] MASK[18.] DEST[O_AC AR] ACSEL[AC] JUMP[JSA1] NORM $
		;Copy PC into left half of AC and save old contents of AC in AR
		; DID SAVE A CYCLE WITH O_AC ****
		;*$*$* (Finish instruction elsewhere)

	.OPCODE[267]	;JRA
	ACSEL[AC] ALU[AC] DEST[AR] NORM  $
		;Save the return address in AR
	D[AR] ROT[18.] MASK[18.] DEST[MA] JUMP[JRA1] NORM $
		;Begin read of location containing what's to be restored into
		;the AC (to invert a JSA)
		;*$*$* (Finish instruction elsewhere)




;------------------------------------------------------------------------------
;
;	Integer Add and Subtract
;
;------------------------------------------------------------------------------

;These two macros make xxx,xxxI,xxxM,xxxB for instructions which map into a
;single 2901 instruction involving AC and MEM.  OP is thing to put in the 
;ALU field to do this 2901 instruction.
;
;ADOP and LOGOP differ only in that ADOP sets flags, and can get integer
;overflow
;
.DEFINE ADOP [OP]
BEGIN ADOP
	FIXM1 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $

	ACSEL[AC] D[IR] MASK[18.] ALU[ OP ] DEST[AC MA] SPEC[CRYOV&MA_PC] JUMP[MAIN1] NORM $
	NOP $

	FIXM2 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[MEMSTO]
	  SPEC[CRYOV] MEMST $

	FIXM2 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[MEMSTO AC]
	  SPEC[CRYOV] MEMST $
END ADOP

.DEFINE LOGOP [OP]
BEGIN LOGOP
	FIXM1 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $

	ACSEL[AC] D[IR] MASK[18.] ALU[ OP ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
	NOP $

	FIXM2 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[MEMSTO]
	 MEMST $

	FIXM2 $
	ACSEL[AC] D[MEM] ALU[ OP ] DEST[MEMSTO AC]
	  MEMST $
END LOGOP

	.OPCODE[270]	;Opcodes 270-273: ADD,ADDI,ADDM,ADDB
	ADOP[D+AC]
		;Macro defines four instructions.  See above

	.OPCODE[274]	;Opcodes 274-277: SUB,SUBI,SUBM,SUBB
	ADOP[AC-D]
		;Macro defines four instructions.  See above

;------------------------------------------------------------------------------
;
;	Conditional Instructions
;
;	Instruction dispatch sends each group of eight instructions to one 
;	place.  The condition JCOND looks at the IR to decide whether the
;	condition specified by the low order three bits of the opcode has
;	been satisfied.
;
;------------------------------------------------------------------------------

;Compare AC to effective address
	.OPCODE[300]	;CAI
	D[IR] MASK[18.] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
	DOSKIP $

AREA260:	;Recover space from hole in instruction dispatch

;Compare AC to memory
	.OPCODE[310]	;CAM
	FIXM1 $
	D[MEM] ACSEL[AC] ALU[AC-D] COND[-JCOND] JUMP[MAIN] C600 $
DOSKP1:	DOSKIP $

AREA262:	;Recover space from hole in instruction dispatch

;Jump on AC [compared with zero]
	.OPCODE[320]	;JUMP
	D[CONST 0] ACSEL[AC] ALU[AC+D] COND[-JCOND] JUMP[MAIN] C600 $
	DOJUMP $

AREA264:	;Recover space from hole in instruction dispatch

;Skip on memory [compared with zero]
	.OPCODE[330]	;SKIP
	FIXM1 COND[AC=0] JUMP[SKIPX1] $
		;Jump if AC not loaded as side effect
	D[MEM] ALU[D-0] ACSEL[AC] DEST[AC] COND[-JCOND] JUMP[MAIN] C600 $
		;AC field (in IR) is zero.  Just skip on appropriate condition
	DOSKIP $
SKIPX1:	D[MEM] ALU[D-0] COND[-JCOND] JUMP[MAIN] C600 $
		;Load memory into AC as well as skipping on appropriate
		;condition
	DOSKIP $

AREA266:	;Recover space from hole in instruction dispatch

;Add One to AC and jump [on AC compared with zero]
	.OPCODE[340]	;AOJ
	ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
	DOJUMP $

AREA270:	;Recover space from hole in instruction dispatch

;Add One to Memory and skip [on memory compared to zero]
	.OPCODE[350]	;AOS
	FIXM2 COND[AC=0] JUMP[ASOS1]  $
		;Finish fetch part of read-modify-write
		;Jump if AC is not loaded as a side effect.
	D[MEM] ALU[D+1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV]
			COND[JCOND] LBJUMP[ASOS2] C600 $
		;(AC field (in IR) is non-zero.  Load AC as side effect.)
		;Increment memory and store result in AC.
		;Set flags (set overflow if memory was 377777,,777777)
		;Decide where or not to skip before checking for store to AC
	.PAIR
ASOS2:	MEMST $
		;Do not skip.  Finish store (checking for store to AC)
	D[PC] ALU[D+1] DEST[PC] MEMST $
		;Do skip.  Finish store.
;	---
ASOS1:	D[MEM] ALU[D+1] DEST[MEMSTO] SPEC[CRYOV]
			COND[JCOND] LBJUMP[ASOS2] C600 $
		;Simply increment memory location.  Otherwise, same as above.

AREA272 = .	;Recover space from hole in instruction dispatch

;Subtract One from AC and jump [on AC compared with zero]
	.OPCODE[360]	;SOJ
	ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[CRYOV] COND[-JCOND] JUMP[MAIN] C600 $
	DOJUMP $

AREA274:	;Recover space from hole in instruction dispatch

;Subtract One from Memory and skip [on memory compared to zero]
	.OPCODE[370]	;SOS
	FIXM2 COND[AC=0] JUMP[ASOS3] $
		;Finish fetch part of read-modify-write
		;Jump if AC is not loaded as a side effect.
	D[MEM] ALU[D-1] ACSEL[AC] DEST[AC MEMSTO] SPEC[CRYOV]
			COND[JCOND] LBJUMP[ASOS2] C600 $
		;(AC field (in IR) is non-zero.  Load AC as side effect.)
		;Decrement memory and store result in AC.
		;Set flags (set overflow if memory was 400000,,0)
		;Decide where or not to skip before checking for store to AC
ASOS3:	D[MEM] ALU[D-1] DEST[MEMSTO] SPEC[CRYOV]
			COND[JCOND] LBJUMP[ASOS2] C600 $
		;Simply decrement memory location.  Otherwise, same as above.

AREA276 = .	;Recover space from hole in instruction dispatch



;------------------------------------------------------------------------------
;
;	Boolean Instructions
;
;------------------------------------------------------------------------------

.DEFINE CLRAC [] [ ALU[0] ACSEL[AC] DEST[AC] NORM ]

	.OPCODE[400]	;SETZ
	CLRAC   JUMP[MAIN] $

	.OPCODE[401]	;SETZI
	CLRAC   JUMP[MAIN] $

	.OPCODE[402]	;SETZM
	  ALU[0] DEST[MEMSTO] MEMST $

	.OPCODE[403]	;SETZB
	  ALU[0] DEST[MEMSTO AC] MEMST $

	.OPCODE[404]	;AND,ANDI,ANDM,ANDB
		;Generates code for four instructions.  See ADD (ADOP)  
	LOGOP[D&AC]

	.OPCODE[410]	;ANDCA
	FIXM1 $
	ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA1] CYLEN[FIXM+1] $

	.OPCODE[411]	;ANDCAI
	ALU[NOTAC] DEST[Q] ACSEL[AC] NORM $
	D[IR] MASK[18.] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC]
			JUMP[MAIN1] NORM $

	.OPCODE[412]	;ANDCAM
	FIXM2 $
	ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA2] CYLEN[FIXM+1] $

	.OPCODE[413]	;ANDCAB
	FIXM2 $
	ACSEL[AC] ALU[NOTAC] DEST[Q] JUMP[ANDCA3] CYLEN[FIXM+1] $

	.OPCODE[414]	;SETM,SETMI,SETMM,SETMB
SETM:	LOGOP[ D ]

	.OPCODE[420]	;ANDCM,ANDCMI,ANDCMM,ANDCMB
	LOGOP[-D&AC]

	.OPCODE[424]	;SETA,SETAI,SETAM,SETAB
	LOGOP[ AC ] $

	.OPCODE[430]	;XOR,XORI,XORM,XORB
	LOGOP[AC#D]

	.OPCODE[434]	;IOR,IORI,IORM,IORB
	LOGOP[DORAC]

	.OPCODE[440]	;ANDCB
	FIXM1 $
	ACSEL[AC] ALU[DORAC] DEST[Q] D[MEM] JUMP[ACBI1] CYLEN[FIXM+1] $

	.OPCODE[441]	;ANDCBI
	  ACSEL[AC] D[IR] MASK[18.] ALU[DORAC] DEST[Q] NORM $
ACBI1:	ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

	.OPCODE[442]	;ANDCBM
	FIXM2 $
	ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $

	.OPCODE[443]	;ANDCBB
	FIXM2 $
	ACSEL[AC] ALU[DORAC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $

	.OPCODE[444]	;EQV,EQVI,EQVM,EQVB
	LOGOP[AC/#D]

	.OPCODE[450]	;SETCA,SETCAI,SETCAM,SETCAB
	LOGOP[NOTAC]

	.OPCODE[454]	;ORCA
	FIXM1 $
	ACSEL[AC] D[MEM] ALU[-D&AC] DEST[Q] JUMP[OCAI1] CYLEN[FIXM+1] $

	.OPCODE[455]	;ORCAI
	  ACSEL[AC] D[IR] MASK[18.] ALU[-D&AC] DEST[Q] NORM $
OCAI1:	ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

	.OPCODE[456]	;ORCAM
	FIXM2 $
	ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $

	.OPCODE[457]	;ORCAB
	FIXM2 $
	ACSEL[AC] ALU[-D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $

	.OPCODE[460]	;SETCM,SETCMI,SETCMM,SETCMB
	LOGOP[NOTD]

	.OPCODE[464]	;ORCM,ORCMI,ORCMM,ORCMB
	FIXM1 $
	D[MEM] ALU[NOTD] DEST[Q] JUMP[OCMI1] CYLEN[FIXM+1] $

	.OPCODE[465]	;ORCMI
	  D[IR] MASK[18.] ALU[NOTD] DEST[Q] NORM $
OCMI1:	ACSEL[AC] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

	.OPCODE[466]	;ORCMM
	FIXM2 $
	D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM2] CYLEN[FIXM+1] $

	.OPCODE[467]	;ORCMB
	FIXM2 $
	D[MEM] ALU[NOTD] DEST[Q] JUMP[ORCM3] CYLEN[FIXM+1] $

	.OPCODE[470]	;ORCB
	FIXM1 $
	ACSEL[AC] D[MEM] ALU[D&AC] DEST[Q] JUMP[OCBI1] CYLEN[FIXM+1] $

	.OPCODE[471]	;ORCBI
	  ACSEL[AC] D[IR] MASK[18.] ALU[D&AC] DEST[Q] NORM $
OCBI1:	ACSEL[AC] ALU[NOTQ] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

	.OPCODE[472]	;ORCBM
	FIXM2 $
	ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG2] CYLEN[FIXM+1] $

	.OPCODE[473]	;ORCBB
	FIXM2 $
	ACSEL[AC] ALU[D&AC] D[MEM] DEST[Q] JUMP[LOG3] CYLEN[FIXM+1] $

	.OPCODE[474]	;SETO
	ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

	.OPCODE[475]	;SETOI
	ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

	.OPCODE[476]	;SETOM
	ALU[-1] DEST[MEMSTO] MEMST     $

	.OPCODE[477]	;SETOB
	ALU[-1] ACSEL[AC] DEST[MEMSTO AC] MEMST $
	NOP $



;------------------------------------------------------------------------------
;
;	Half Word Instructions
;
;------------------------------------------------------------------------------

.DEFINE MH1 [ RR MM SS RR2 D1 OP1 JJ CYL1 D2 SS1  ]
[	FIXM1 $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] CYLEN[FIXM+1] $
	D[MA] ROT[RR] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $
	NOP $
	D[MASK 22] ROT[ RR2 ] ACSEL[AC] ALU[D&AC] DEST[ D1 ] COND[-MA-AC] OP1 [ JJ ]  CYLEN[ CYL1 ] $
	D[AR] ROT[18.] DEST[MEMSTO] MEMST $
	ACSEL[MA] ALU[AC] COND[MA-AC] JUMP[ D2 ] DEST[FIXMAC-MAPF-WRT] MAPF[3] CYLEN[FIXM] $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS1 ] DEST[MEMSTO] COND[-AC=0] LBJUMP[HSMN1] CYLEN[FIXM+1] $
]

.DEFINE MH2 [ RR MM SS CC OP DST RR2 DST2 CC2 OP2 JJ CYL2 RR3 DST3 CC4 ]
[	FIXM1 $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[AC AR] COND[ CC ] OP [ DST ] CYLEN[FIXM+1] $
	D[MA] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[AC AR] COND[ CC ] OP [ DST ] NORM $
	NOP $
	D[MASK 22] ROT[ RR2 ] ACSEL[AC] ALU[DORAC] DEST[Q DST2 ] COND[ CC2 ] OP2[JJ] CYLEN[ CYL2 ] $
	D[AR] ROT[RR3] DEST[MEMSTO] MEMST $
	FIXM2 $
	D[MEM] ROT[ RR ] DEST[Q AR] COND[ CC4 ] LBJUMP[ DST3] CYLEN[FIXM+1] $
]

.DEFINE MH3 [ RR MM SS JDST RR2 JDST2 DST OP1 JJ ]
[	FIXM1 $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[O_AC AR] JUMP[ JDST ] CYLEN[FIXM+1] $
	D[MA] ROT[ RR ] MASK[ MM ] SPEC[ SS ] ACSEL[AC] DEST[O_AC AR] JUMP[ JDST ] NORM $
	NOP $
	FIXM2 $
	D[MASK 22] ROT[ RR2 ] ACSEL[AC] ALU[D&AC] DEST[Q AR] JUMP[ JDST2 ] CYLEN[FIXM+1] $
	ACSEL[MA] ALU[AC] DEST[ DST ] MAPF[3] COND[-AC=0] OP1[JJ] CYLEN[FIXM] $
	D[MEM] ROT[ RR ] MASK[ MM ] SPEC[ SS ] DEST[Q AR] COND[-AC=0] LBJUMP[HHS] CYLEN[FIXM+1] $
]

	.OPCODE[500]	;HLL,HLLI,HLLM,HLLS
	MH3[ 0 0 LEFT HRAR 22 HLLM1 0 LBJUMP HMV ]
;HRL
	MH3[ 22 0 LEFT HRAR 0 HRLM1 FIXMAC-MAPF-WRT CONTA 0]
;HLLZ
	MH1[0 0 LEFT&MA_PC 22 MEMSTO LBJUMP MSMAIN NORM HLLZS1 LEFT]
;HRLZ
	MH1[22 0 LEFT&MA_PC 0 AR CONTA 0 NORM HRLZS1 LEFT]
;HLLO
	MH2[0 44 0 0 JUMP HOR 0 MEMSTO -MA-AC LBJUMP MSMAIN NORM 0 HLLOS1 -AC=0]
;HRLO
	MH2[22 44 0 0 JUMP HOR 22 AR 0 CONTA 0 NORM 22 HLLOS1 -AC=0]
;HLLE
	MH2[0 0 LEFT OBUS<0 LBJUMP HLSZ 0 AR -OBUS<0 JUMP HLLEM1 C550 0 HLLES1 OBUS<0 ]
;HRLE
	MH2[22 0 LEFT OBUS<0 LBJUMP HLSZ 22 AR -OBUS18 JUMP HRLEM1 C550 22 HLLES1 OBUS<0 ]
;HRR
	MH3[0 22 0 HLAR 0 HRRM1 0 LBJUMP HMV ]
;HLR
	MH3[22 22 0 HLAR 22 HLRM1 FIXMAC-MAPF-WRT CONTA 0]
;HRRZ
	MH1[0 22 MA_PC 0 MEMSTO LBJUMP MSMAIN NORM HRRZS1 0]
;HLRZ
	MH1[22 22 MA_PC 22 AR CONTA 0 NORM HLRZS1 0]
;HRRO
	MH2[0 44 0 0 JUMP HOL 22 MEMSTO -MA-AC LBJUMP MSMAIN NORM 0 HRROS1 -AC=0]
;HLRO
	MH2[22 44 0 0 JUMP HOL 0 AR 0 CONTA 0 NORM 22 HRROS1 -AC=0]
;HRRE
	MH2[0 22 0 OBUS18 LBJUMP HRSZ 22 AR -OBUS18 JUMP HRREM1 C550 0 HRRES1 OBUS18]
;HLRE
	MH2[22 22 0 OBUS18 LBJUMP HRSZ 0 AR -OBUS<0 JUMP HLREM1 C550 22 HRRES1 OBUS18]




;------------------------------------------------------------------------------
;
;	Bit Test Instructions
;
;  Caution:	Instruction dispatch for these instructions is peculiar.
;
;------------------------------------------------------------------------------

	.OPCODE[600]	;TRN GROUP
	  D[IR] MASK[18.] ACSEL[AC] ALU[D&AC]
	    SPEC[MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
	DOSKIP $

	.OPCODE[601]	;TLN GROUP
	  D[IR] ROT[18.] ACSEL[AC] ALU[D&AC]
	    SPEC[LEFT&MA_PC] DEST[MA] COND[-JCOND] JUMP[MAIN1] C550 $
	DOSKIP $

   .DEFINE T2GRP [OP RR MM SS]
[	ACSEL[AC] D[IR] ROT[RR] MASK[MM] SPEC[SS] ALU[OP] DEST[AC] NORM $
	DOSKIP $
]

;Following code is NOT dispatched to, it is JUMPed to.
TRZ1:	T2GRP [-D&AC 0 22 0 ]
TLZ1:	T2GRP [-D&AC 22 0 LEFT]
TRO1:	T2GRP [DORAC 0 22 0]
TLO1:	T2GRP [DORAC 22 0 LEFT]
TRC1:	T2GRP [D#AC 0 22 0]
TLC1:	T2GRP [D#AC 22 0 LEFT]

;(No space left before dispatch entry)

	.OPCODE[610]	;TDN GROUP
	FIXM1 $
	D[MEM] ACSEL[AC] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $
	.OPCODE[611]	;TSN GROUP
	FIXM1 $
	D[MEM] ACSEL[AC] ROT[18.] ALU[D&AC] COND[JCOND] LBJUMP[SKMAIN] C600 $

;(Following is not dispatched to.  It probably belongs with MSMAIN, etc.)
	.PAIR
SKMAIN:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
	DOSKIP $

AREA342:	;Recover space from hole in instruction dispatch

  .DEFINE T1GRP [OP RR MM SS1 SS2 D1]
[	ACSEL[AC] D[IR] ROT[RR] MASK[MM] SPEC[SS1] ALU[D&AC] COND[JCOND] JUMP[D1] C550 $
	ACSEL[AC] D[IR] ROT[RR] MASK[MM] SPEC[SS2] ALU[OP] DEST[AC MA] JUMP[MAIN1] NORM $
]
	.OPCODE[620]	;TRZ GROUP
	T1GRP [-D&AC 0 22 0 MA_PC TRZ1]

	.OPCODE[621]	;TLZ GROUP
	T1GRP [-D&AC 22 0 LEFT LEFT&MA_PC TLZ1]

AREA344:	;Recover space from hole in instruction dispatch

	.OPCODE[630]	;TDZ
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDZ1] NORM $

	.OPCODE[631]	;TSZ
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] NORM $
;	\ /
;Following is not in instruction dispatch
	ACSEL[AC] D[MEM] ROT[18.] ALU[-D&AC] DEST[AC] SHORT $
TSZ2:	D[MEM] ROT[18.] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $
TDZ1:	ACSEL[AC] D[MEM] ALU[-D&AC] DEST[AC] SHORT $
TDZ2:	D[MEM] ALU[D&Q] COND[JCOND] LBJUMP[SKMAIN] C600 $

AREA346:	;Recover space from hole in instruction dispatch

	.OPCODE[640]	;TRC GROUP
	T1GRP [D#AC 0 22 0 MA_PC TRC1]

	.OPCODE[641]	;TLC GROUP
	T1GRP [D#AC 22 0 LEFT LEFT&MA_PC TLC1]

AREA350:	;Recover space from hole in instruction dispatch

	.OPCODE[650]	;TDC
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDC1] NORM $

	.OPCODE[651]	;TSC
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] NORM $
	ACSEL[AC] D[MEM] ROT[18.] ALU[AC#D] DEST[AC] JUMP[TSZ2] NORM $
TDC1:	ACSEL[AC] D[MEM] ALU[AC#D] DEST[AC] JUMP[TDZ2] NORM $

AREA352:	;Recover space from hole in instruction dispatch

	.OPCODE[660]	;TRO GROUP
	T1GRP [DORAC 0 22 0 MA_PC TRO1]

	.OPCODE[661]	;TLO GROUP
	T1GRP [DORAC 22 0 LEFT LEFT&MA_PC TLO1]

AREA354:	;Recover space from hole in instruction dispatch

	.OPCODE[670]	;TDO GROUP
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] JUMP[TDO1] NORM $

	.OPCODE[671]	;TSO GROUP
	FIXM1 $
	ALU[AC] ACSEL[AC] DEST[Q] NORM $
	ACSEL[AC] D[MEM] ROT[18.] ALU[DORAC] DEST[AC] JUMP[TSZ2] NORM $
TDO1:	ACSEL[AC] D[MEM] ALU[DORAC] DEST[AC] JUMP[TDZ2] NORM $

AREA356:	;Recover space from hole in instruction dispatch



; IOT GROUP -- FOR NOW

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;									;;;;
;;;;	CAUTION: Hardware currently does not check for User when doing	;;;;
;;;;	IOTs.  Most, but not all, now check it in micro code.  The	;;;;
;;;;	instruction dispatch hardware is probably the right place to	;;;;
;;;;	check for this, but try to convince Poole of that...		;;;;
;;;;									;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


.repeat 0[
.DEFINE IOTDIS [ WHERE ]
[	D[IR] ROT[15] MASK[4] DEST[Q] NORM $
	D[IR] ROT[15] MASK[4] ALU[D+Q] DEST[Q] SHORT $
	D[CONST WHERE] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
]
];repeat 0

.DEFINE IOTDIS [ WHERE ]
[	D[IR] ROT[16] MASK[5] DEST[Q] NORM $
	D[CONST WHERE] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
];.DEFINE IOTDIS
	;Bit 14 is guaranteed zero by instruction decode process and therefore
	;doubling can be obtained by extraction.   TVR-Apr80

	.OPCODE[700]	;APR & PI
	MAPF[2] D[CONST 6] DEST[DEV-ADR] COND[-USER] LBJUMP[APIOT] NORM $
	NOP $

.REPEAT 1 - KL [
	.OPCODE[701]
	ILGIOT $
	NOP $

	.OPCODE[702]	;UNUSED & MAP
	MAPF[2] D[CONST 1] DEST[DEV-ADR] NORM $
	D[IR] ROT[15] MASK[4] DEST[Q] COND[-USER] LBJUMP[MAPIOT] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
	.OPCODE[701]	;UNUSED & MAP
	MAPF[2] D[CONST 1] DEST[DEV-ADR] NORM $
	D[IR] ROT[15] MASK[4] DEST[Q] COND[-USER] LBJUMP[MAPIOT] NORM $

	.OPCODE[702]
	ILGIOT $
	NOP $
];.REPEAT KL

.REPEAT 7 [ILGIOT $
	NOP $
	 ]

	.OPCODE[712]	;CTY & LPT
	MAPF[2] D[CONST 4] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[CTYIOT] $
	NOP $

	ILGIOT $
	 NOP $
	ILGIOT $
	 NOP $

;DISK CTRL IOTS-- 140 - 174

	.OPCODE[715]	;DISK CTRL IOTS-- OPCODES 715 TO 724
	D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
	 MAPF[0] D[IOD] DEST[MEMSTO] 
		COND[-MA-AC] LBJUMP[SMAIN] $
	D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
	 MAPF[1] D[IOD] DEST[MEMSTO] 
		COND[-MA-AC] LBJUMP[SMAIN] $
	D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
	 MAPF[2] D[IOD] DEST[MEMSTO] 
		COND[-MA-AC] LBJUMP[SMAIN] $
	D[CONST 10] DEST[DEV-ADR] SPEC[IOB-IN] COND[USER] JUMP[UDSKST] $
	 MAPF[3] D[IOD] DEST[MEMSTO] 
		COND[-MA-AC] LBJUMP[SMAIN] $
	FIXML PUSHJ[SET-DSK-OUT] $ ;ld cmd -- opcode 721
	 MAPF[4] d[ar] DEST[2]  DEST-A-MEM JUMP[MAIN] $
	FIXML PUSHJ[SET-DSK-OUT] $
	 MAPF[5] DEST[MA]  SPEC[MA_PC] 	JUMP[MAIN1] $
	FIXML PUSHJ[SET-DSK-OUT] $
	 MAPF[6] DEST[MA]  SPEC[MA_PC] 	JUMP[MAIN1] $
	FIXML PUSHJ[SET-DSK-OUT] $
	 MAPF[7] DEST[MA]  SPEC[MA_PC] 	JUMP[MAIN1] $
	
;TAPE IOTS - OPCODES 725 - 732 --Dispatch entries on page headed ";TAPE DISP"


.OPCODE[733]

  .REPEAT  4 [ILGIOT $	;SKIP OPCODES 733 - 736
	NOP $
  ]
	.OPCODE[737]	;DLS iot's (DLS is device 370)
 .REPEAT 1 - DLS [ 	;If DLS present, this entry is part of DLS code.
	D[IR] ROT[12.] C550 COND[OBUS<0] JUMP[MAIN] $
	  ;If it can't be a CONSZ, do nothing.
	D[PC] ALU[D+1] DEST[PC] NORM JUMP[MAIN] $
	  ;If it could be a CONSZ, assume it is and perform a skip.
  ] ;1 - DLS

   ;skip space for disk cono,coni, etc. OPS 740 - 743
   ;locs 3700 to 3707
	  ; these dispatch entries are on dsk page.

	.OPCODE[744]	;Tymnet opcodes (or undefined)
 .repeat 1 - Tymnet [
	.repeat 4 [ ilgiot $  nop $  ;if no tymnet, 744-747 = nop
		   ]
		   ]

.repeat tymnet [
   ;skip space for TYMNET IOTS.  OPS 744 - 747
	  ; these dispatch entries are on TYMNET page.
    ]

	.OPCODE[750]	 ;READ ECC INFO
	D[11] A-MEM-APR DEST[MEMSTO] MEMST $
	 ;Get info on last ECC error from A-MEM(1), store in eff. adr.
	NOP $

	.OPCODE[751]	;Undefined
	ILGIOT $
	NOP $

	.OPCODE[752]	;
.REPEAT 1 - VC [
	ILGIOT $
	NOP $
];.REPEAT 1 - VC
.REPEAT VC [		;Versatec
	D[CONST VCDEV] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[VCIOT] $
		;Set micro device address for Versatec and check for
		;IOT-User mode
	NOP $
];.REPEAT VC

	.OPCODE[753]	;Undefined
	ILGIOT $
	NOP $

	.OPCODE[754]	;Undefined
	ILGIOT $
	NOP $

	.OPCODE[755]	;IMP (BBN), device code 550
.REPEAT 1 - IMP [ILGIOT $
	NOP $
];1 - IMP

.REPEAT IMP [	;Reserve space for the IMP IOT dispatch instructions
IMP-IOT:
];IMP

	.OPCODE[756]	;Undefined
.REPEAT (757 - 756 + 1) [ILGIOT $
	NOP $
 ]

TIMER-IOTS:
  
	.OPCODE[760]	;760:765
.REPEAT 0 * (1 - TIMER) * (765 - 760 + 1) [ILGIOT $
	NOP $
 ]
;;; : TIMER-IOTS + 12.	;LEAVE SPACE FOR OPCODES 760-765
;*** This is an unreasonably large waste of opcode space.  It should dispatch
;*** on the AC field at least if normal PDP-10 I/O opcodes aren't suitable.
;*** Furthermore, this kind of opcode has no chance of being properly
;*** disassembled by DDT.					TVR-Apr80

	.OPCODE[774]
.REPEAT STANSW [			;OP 774
	D[CONST GRN-UDEV] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[GRNIOT] $
		;Set micro device address for Grinnell and check for
		;IOT-User mode
	NOP $
]
.REPEAT 1 - STANSW [CURRENTLY-UNUSED[1]  JUMP[MAIN] $

	NOP $
]

	.OPCODE[775]

 .REPEAT 1 [
	
;CAM -- A COPY OF CAM WHICH HALTS IF IT DOESN'T SKIP.  WOW !
	FIXM1 $
	D[MEM] ACSEL[AC] ALU[AC-D] COND[JCOND] JUMP[DOSKP1] C600 $
	D[MEM] CURRENTLY-UNUSED[1] JUMP[.] $

;;DSKWT  -- DELAY UNTIL DISK NOT BUSY
;	JUMP[DSKWT1] $		;OPCODE 775
;	NOP $
;	NOP $
;	NOP $

]

.REPEAT 0 [ ILGIOT $
			NOP $

			ILGIOT $
			NOP $  ]

	.OPCODE[777]	;OPCODE 777 --- MAKE IT A UUO
;;;	JUMP[MUUO] $
	UAOP1 $		;Illegal instruction rather than an IOT.  It's an
			;easy thing to stumble upon in buggy programs (or
			;hardware), being it is most common negative integers




;MSTART MSTRT1 BADPC ILDB1 ILDB2 IDPB1 IDPB2 ILDB3 LDB1 LDB5 LDB2 LDB4 DPB1 DPB5 DPB7 IDPB3 DPB2 DPB4 BIIH1 BIIH BII IBP1 IBT1
;NON DISPATCH STUFF HERE

	.ORG[RESTART-ORG]
; INIT THINGS -- INITIALIZE MACHINE, POWER-UP COMES HERE.

MSTART:
JUMP[MSTRT1] $	;to help operator start from switches (KEEP THIS SIMPLE -- MLB)

	.USE[NORMAL]
MSTRT1:

;******* This code to be made a subroutine to allow machine resetting *******
;******* to be done by auto-loading and via CONO APR,20000  TVR-Mar80 *******

.REPEAT 1 - CROCK [	;$*$*$ This crock will shortly vanish!
;Set up vectors for unused devices 9JAN80 BO (23JAN MLB/TVR)
;This code fills the zeroth location of all the AMEM blocks with a vector to
;the address SPURIOUS-INTERRUPT, which should contain the handler for them.

	.ORG[SPURIOUS-INTERRUPT-ORG]		;this is randomly here, it could be anywhere
SPURIOUS-INTERRUPT:	JUMP[.] $	;here on spurious interrupts

	.RELOC

D[CONST (SPURIOUS-INTERRUPT / 100)] ROT[6] DEST[Q] $	;Put high 6 bits in Q
..LOW6 = (SPURIOUS-INTERRUPT \ 100)
.IF ..LOW6 /= 0 [	;assemble low order 6 bits if non-zero
D[CONST ..LOW6] ALU[DORQ] DEST[Q] $
]
D[CONST 40] DEST[AR CLR-DEV-FROM-INTR] NORM $	;init AR for device num
ALU[Q] DEST[0] DEST-A-MEM NORM $		;store vector 
D[AR] ALU[D-1] DEST[AR DEV-ADR]			;decrement dev adr
	COND[-OBUS<0] JUMP[. - 1] C550 $	;and loop
];1 - CROCK


;The following code sets up the AMEM zero vectors for various random devices.
;this is a complete CROCK!  The device reset subroutines should do this!!
;I plan to fix this soon (when I have time, ha ha)	-- MLB 23JAN80
;$*$*$ Fix this soon.	TVR-Apr80

	D[CONST 20] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $

	.DEFINE AMLD2 [ DEV ALOC VAL ]
[	D[CONST DEV] DEST[DEV-ADR] NORM $
	D[CONST VAL] ALU[DORQ] DEST-A-MEM DEST[ALOC] NORM $
]
	AMLD2 [ 1 0 62 ] ; INTERRUPTS FROM DEV 1 (SWITCHES) GO TO 2062
	D[CONST 21] ROT[6] DEST[Q] NORM $
;;;	AMLD2 [ 4 0 30 ] ; INTERRUPTS FROM DEV 4 GO TO 2130 [Now set at CTYRST]
	AMLD2 [ 5 0 34 ] ; INTRS FROM DEV 5 GO TO 2134
	AMLD2 [ 6 0 41 ] ; INTS FROM DEV 6 GO TO 2141
	AMLD2 [ 7 0 50 ] ; INTS FROM DEV 7 GO TO 2150
	AMLD2 [ 10 0 56 ] ; INTS FROM DEV 10 GO TO 2156
.REPEAT DLS [
	AMLD2 [ DLSDEV 0 37 ] ; DLS GOES TO 2137
];DLS
;;	the IMP reset code takes care of this for itself!!

;;; Moved code to set MAP-DISP to MAPRST (due to lack of space between
;;; 4000:4777).						  TVR-Apr80
	ALU[0] DEST[CRYOV] NORM $
	ALU[0] DEST[CLR-MI-ERR] NORM $
	D[CONST 0] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	JUMP[RESLOP] NORM $

BADPC:	BADLOC $

;------------------------------------------------------------------------------
;$*$*$*	THIS JUNK HAS GOT TO MOVE! TVR-Apr80
;
;Some of it also needs commenting but this must be postponed until after CCRMA
;merge.
;------------------------------------------------------------------------------

	.USE[AREA260]
	.PAIR	;Goes to second if HALF is not set
ILDB1:
.REPEAT 1 - KL [
	D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[ILDB2] NORM $
		;Extract S field.  Being HALF was set, don't increment
];.REPEAT 1 - KL
.REPEAT KL [
	D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[ILDBH] $
		;JUMP IF FPD IS REALLY ON IN PC, ELSE FALL INTO REGULAR BYTE INSTRUCTION
];.REPEAT KL
	D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
		;Extract S field.  Increment word if byte overflow will happen
	D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $;SUB S FROM P
		;Increment byte pointer, no overflow possible now
		;Store into memory, check for store into AC
	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
		;Store is into an AC, write it there.
ILDB2:	ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[ILDB3] NORM $
		;Fetch data, perhaps.  Maybe also do indexing or indirection
.REPEAT KL [
ILDBH:	D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[ILDB2] NORM $
		;SAME AS AT ILDB1 FOR 1 - KL.
];.REPEAT KL
	.PAIR
IDPB1:
.REPEAT 1 - KL [
	D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[IDPB2] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
	D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[IDPBH] $
		;JUMP IF FPD REALLY ON IN PC, ELSE FALL THRU AS IF HALF NOT ON
];.REPEAT KL
	D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
	D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $;SUB S FROM P
	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] $
IDPB2:	ALU[Q] DEST[MA] COND[-MEM-IDX-IND] LBJUMP[IDPB3] NORM $
.REPEAT KL [
IDPBH:	D[AR] ROT[14] MASK[6] DEST[MASKR] JUMP[IDPB2] NORM $
		;GET S IN MASK REGISTER, JUMP TO SECOND PART OF INSTRUCTION
];.REPEAT KL

	.PAIR	;Goes to second if not indexing or indirecting
ILDB3:	MAPF[NORM-RD] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
	MAPF[BYTE-ILD] ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD]
			JUMP[LDB2] CYLEN[FIXM] $
		;Finish read of data word, then go extract byte

	.USE[AREA262]
	.PAIR	;Goes to second if not indexing or indirecting
LDB1:	MAPF[2] PUSHJ[BII] NORM $
LDB5:	FIXM1 $	;Also gets here from XBY13
	D[AR] ROT[14] MASK[6] DEST[MASKR] SHORT $
		;GET S FLD
	SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
	D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[Q ROTR] SHORT $
		;SUB P FLD FROM 44
	D[AR] ROT[12.] MASK[6] ALU[Q-D] COND[-OBUS<0] JUMP[LDB4] C550 $
		;Also, subtract S field.  If result is positive, then byte
		;of size S fits with at least P bits remaining in the right
		;side of the word
	ALU[Q] DEST[MASKR] JUMP[LDB4] NORM $
		;Byte does not fit!!!  We want only the stuff to the left
		;of postion P, which is 36.-P bits, coincidentally, the same
		;size as the rotation
;S field is already set up.  Set up P field and extract data from word.
LDB2:	SPEC[CLR-HALF] D[CONST 44] DEST[Q] SHORT $
	D[AR] ROT[6] MASK[6] ALU[Q-D] DEST[ROTR] SHORT $
		;SUB P FLD FROM 44
LDB4:	D[MEM] ACSEL[AC] ROT[R] MASK[R] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $; DO THE LDB


	.PAIR
DPB1:	MAPF[2] PUSHJ[BII] NORM $
DPB5:		;Also gets here from XBY13
;;;	FIXM2 $	;Wrong thing for WAITS.
	  MAPF[BYTE-IDP] CYLEN[FIXM]
			ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] JUMP[DPB7] $
		;KA/KL set half flag even on DPB.  They would also set read
		;failure, not write, in the case of not in map; but we don't
		;have time to be particular.  			TVR-Apr80

	.USE[NORMAL]
DPB7:	D[AR] ROT[12.] MASK[6] DEST[MASKR] SHORT $
		;Fetch S field.
	SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[Q ROTR] SHORT $
		;Fetch P field.
	D[CONST 44] ALU[D-Q] DEST[Q] SHORT $
		;Calculate 36-P, which is maximum number of bits in this byte
	D[AR] ROT[12.] MASK[6] ALU[Q-D] COND[-OBUS<0] JUMP[DPB4] C550 $
		;Does this byte fit?  I.e. 36-P-S is non-negative.  If so,
		;use this mask field
	ALU[Q] DEST[MASKR] JUMP[DPB4] NORM $
		;Setup mask which is everything to the left of the position
		;designated by P.

	.USE[AREA266]
	.PAIR
IDPB3:	MAPF[2] PUSHJ[BIIH] NORM $;HANDLE IDX-IND
	MAPF[BYTE-IDP] CYLEN[FIXM]
		ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-WRT] $
	D[AR] ROT[14] MASK[6] DEST[MASKR] SHORT $
DPB2:	SPEC[CLR-HALF] D[AR] ROT[6] MASK[6] DEST[Q ROTR] SHORT $
DPB4:	D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $;GET BYTE
	D[MEM] DEST[Q] SHORT $; GET DEST WORD
	D[2] MASK[R] ROT[R] ALU[-D&Q] DEST[Q] SHORT $;CLR DEST BYTE
	D[AR] ROT[R] ALU[DORQ] DEST[MEMSTO] MEMST $;DO IT

.DEFINE BIIMAC[BIMAPF BIIH BIIH1]
[	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[BIIH1] C550 $;IDX FLD
	D[MA] ACSEL[REG] MASK[18.] ALU[D+AC] DEST[MA] SHORT $;DO INDEXING
	D[AR] ROT[16] MASK[1] MAPF[2] COND[OBUS=0] POPJ CYLEN[C500] $;LEAV IF NO IND
BIIH1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BIMAPF] CYLEN[FIXM] $
	D[MEM] MASK[27] DEST[Q MA] COND[-MEM-IDX-IND] POPJ CYLEN[C500] $;GET INDIRECT WORD, LEAVE IF NO MORE IND OR IDX
	D[AR] ROT[14] MASK[14] DEST[AR] MAPF[2] NORM $
	D[AR] ROT[30] ALU[DORQ] DEST[Q AR] JUMP[BIIH] NORM $
]
	.USE[AREA264]
BIIH:	BIIMAC [BYTE-IND BIIH BII1]
BII:	BIIMAC [NORM-RD BII BII2]

	.USE[NORMAL]
.REPEAT KL [;HERE FOR KL CASE WHERE HALF FLAG IS SET
IBP0:	D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[MAIN] $
		;IF FPD REALLY ON IN PC, THEN DON'T DO ANYTHING
	D[MEM] DEST[Q AR] COND[AC=0] LBJUMP[IBP1] NORM $
		;ON FOR SOME OTHER REASON, DO WHAT NORMALLY WHAT WOULD HAVE BEEN DONE IF HALF OFF.
];.REPEAT KL
	.PAIR	;Skip if AC=0
IBP1:	UAOP1 $	;Non-zero AC implies ADJBP.  We don't, yet.
	D[AR] ROT[14] MASK[6] DEST[AR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $;GET S FLD, OVFL?
		;Zero AC.  Do ordinary increment byte pointer.
		;PUSHJ if we are about to overflow a word.
	D[AR] ROT[36] ALU[Q-D] DEST[Q MEMSTO] MEMST $
		;Finish updating byte position part of pointer

;Increment byte pointer which crosses a word boundary
IBT1:	D[MASK 36] ALU[D&Q] DEST[Q] SHORT $
	D[CONST 44] ROT[36] ALU[D+Q+1] DEST[Q] POPJ NORM $
		;NEW P FLD OF 44, ADD 1 TO ADR



IMUL1:	ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $	;0 TO AC,AC TO AR
	ALU[Q] DEST[AC] JUMP[MAIN] NORM $
IMUL2:	ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $	;0 TO AC
	D[AR] DEST[AC] NORM $
	ALU[Q] DEST[MEMSTO] MEMST $

IMUL3:	ALU[0] DEST[AR O_AC] PUSHJ[DOIMUL] NORM $
	ALU[Q] DEST[AC MEMSTO] MEMST $

MUL1:	ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
	ACSEL[AC+1] ALU[Q] DEST[AC] JUMP[MAIN] NORM $

MUL2:	ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
	D[AR] DEST[O_AC MEMSTO] MEMST $
MUL3:	ALU[0] DEST[AR O_AC] PUSHJ[DOMMUL] NORM $
	ACSEL[AC+1] ALU[Q] DEST[AC] NORM $
	ALU[AC] DEST[MEMSTO] MEMST $

DOIMUL:	PUSHJ[DOMUL] NORM $
	ALU[AC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF 0
	ALU[NOTAC] COND[OBUS=0] POPJ CYLEN[C500] $; NO OV IF -1
MSETOV:	D[PC] DEST[AC] SHORT $; GET FLAGS
MSTOV1:	D[CONST 1] ROT[43] ALU[DORAC] DEST[CRYOV] NORM POPJ $; SET OV
DOMMUL:	D[AR] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; NO OV IF DIFF OPERS
	D[CONST 1] ROT[43] ALU[D#Q] COND[-OBUS=0] JUMP[DOMUL] CYLEN[C500] $; J IF NOT -2**35
	PUSHJ[MSETOV] NORM $;SET OV
	ALU[0] DEST[AC] SHORT $
DOMUL:	D[CONST 42] LLOAD NORM $	;LOOP 35 TIMES

DOMUL1:	D[AR] ALU[MULAC+D] DEST[D4] MASK[3]
			LOOP[DOMUL1] NORM $ ;SHIFT, END-COND MUL; SOJGE, SH RT
		;This shifts right, with the low order bit of the partial
		;product being saved in Q.  At the same time, shift out of Q
		;a bit of the multiplier (and somehow??? the hardware uses this
		;to decide whether to add or not???)
		;MASK field specifies what gets shifted into AC, in this case,
		;(ALU OV) XOR (-OUT<0)
	D[AR] ALU[MULAC+D] DEST[D4] MASK[3]
			COND[-Q0-35] JUMP[. + 2] CYLEN[C450] $ ;J IF QUOT WAS +
		;Do last step of multiply. Jump on sign of multiplier(?)
	D[AR] ALU[MULAC-D] DEST[D7]
			JUMP[. + 2] NORM $ ; DEST AC SH LFT, ALU=1, ALU S=0
		;Multiplier was positive... ???: Shift left to make properly
		;signed result, with low order bit coming from Q0 (i think???)
	ALU[SH-AC] DEST[D7] NORM $ ;DEST AC SH LFT
		;SINCE DEST IS >3, ALU[QORAC] IS ALU[AC]
		;Multiplier was negative... ???
	ALU[AC] COND[OBUS<0] LBJUMP[DOMUL4] CYLEN[C500] $
		;Decide what sign should be in the low order result.

	.PAIR
DOMUL4:	D[MASK 35.] ALU[D&Q] DEST[Q] POPJ NORM $
		;Positive.  Turn off Q0, which was copied into AC35.
	D[CONST 1] ROT[35.] ALU[DORQ] DEST[Q] POPJ NORM $
		;Negative.  Set Q0 so the number is negative (Q0 was copied into
		;AC35).

  CCC1	= SHORT $	;Apparently used as a NO-OP for macros below. TVR-Apr80
  MEMST1 = MEMST $	;Store to memory. (Cause macro expansion now, rather
			;than in macro call.)

.DEFINE DMACFN [AA A2 D1 D2 OP1]
[	ALU[AA] D[AR] DEST[O_AC AR] SHORT $
	ACSEL[AC+1] D[AR] ALU[A2] DEST[D1 D2] OP1 $
	ALU[AC] DEST[MEMSTO] MEMSTMA $
]
.DEFINE DMAC2 []
[	D[MEM] ALU[D#AC] DEST[AR] PUSHJ[DODDIV] NORM $
]
.DEFINE DMAC1 []
[	.PAIR
	ALU[-1] DEST[AC] JUMP[. + 2] NORM $
	ALU[0] DEST[AC] SHORT $
	D[MEM] ALU[D#AC] DEST[AR] SHORT $
	D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
	ALU[Q] DEST[AR] PUSHJ[DODIV] NORM $
]

IDIV1:	DMAC1
	DMACFN[Q D AC MA DOM1]
IDIV2:	DMAC1
	DMACFN[D Q MEMSTO AR MEMST1]
IDIV3:	DMAC1
	DMACFN[Q D AC 0 CCC1]
DIV1:	DMAC2
	DMACFN[Q D AC MA DOM1]
DIV2:	DMAC2
	DMACFN[D Q MEMSTO AR MEMST1]
DIV3:	DMAC2
	DMACFN[Q D AC 0 CCC1]

DODDIV:	D[AR] ROT[1] MASK[1] DEST[IR-ADR] SHORT $
	ALU[SH-AC] DEST[AR D5] MASK[1] NORM $
	D[AR] MASK[1] COND[OBUS=0] JUMP[. + 2] C550 $
	D[CONST 1] ROT[43] ALU[DORQ] DEST[Q] JUMP[. + 2] NORM $
	D[MASK 43] ALU[D&Q] DEST[Q] NORM $
;------------------------------------------------------------------------------
;
;	Single Precision Divide (and continuation of double precision)
;
;	(Reminder: Quotient, Remainder = Dividend / Divisor)
;
;Where we get here:
;    MEM	36 bit signed divisor
;    AC		High order dividend (0 or -1 for single precision)
;    Q		Low order dividend
;    IR<35>	Sign of dividend XOR sign of divisor
;    AR		Sign of dividend and original contents of AC
;  
;------------------------------------------------------------------------------
DODIV:	D[MEM] COND[-OBUS<0] JUMP[DODIV1] C550 $
		;Jump if divide by positive number
	D[MEM] ALU[0-D] DEST[HOLD] SHORT $
		;Take absolute value
DODIV1:	ALU[AC] COND[-OBUS<0] JUMP[DODIV2] CYLEN[C450] $
		;Check sign of high order word.  If positive, we're ready to go
	ALU[0-Q] DEST[Q] COND[OBUS=0] JUMP[DODIV3] CYLEN[C500] $
		;Double precision negate, low order word
	ALU[NOTAC] DEST[AC] JUMP[DODIV2] NORM $
		;High order word, no carry
DODIV3:	ALU[0-AC] DEST[AC] NORM $
		;High order word, with carry
DODIV2:	D[CONST 44] LLOAD NORM $
		;LOOP 37 TIMES
;Now have:
;   MEM		Absolute value of divisor
;   AC		Absolute value of high order dividend
;   Q		Absolute value of low order dividend
;   R		Repeat count for division
	D[MEM] ALU[AC-D] COND[OBUS<0] JUMP[DODIV7] C550 $
		;Jump if not no divide case
	D[PC] DEST[AC] SHORT $
		;Get ready to set flags
	D[CONST 1] ROT[23.] ALU[DORAC] DEST[AC] PUSHJ[MSTOV1] NORM $
		;Set no divide
	D[AR] DEST[AC] POPJ NORM $
		;Fix clobbered AC

	;$*$*$* NORMAL area runs of space for now.  TVR-Apr80
	.USE[AREA216]
DODIV7:	NORM PUSHJ[DODIV4] $
	D[AR] COND[-OBUS<0] JUMP[. + 2] C550 $; J IF DIVIDEND WAS +
	ALU[0-AC] DEST[AC] SHORT $
	D[IR] MASK[1] COND[OBUS=0] POPJ C550 $ ;LEAVE IF RESULT SHOULD BE +
	ALU[0-Q] DEST[Q] POPJ NORM $
;On completion:
;   MEM		Absolute value of divisor
;   AC		Remainder
;   Q		Quotient
;   AR<0>	Sign of dividend
;   IR<35>	Sign of dividend

	.QUAD
DODIV4:	D[MEM] ALU[DIVAC-D] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
	ALU[SH-AC] DEST[D5] MASK[0] JUMP[DODIV6] NORM $ ; RE-SHIFT REMAINDER
	D[MEM] ALU[DIVAC+D] DEST[D6] MASK[3] COND[OBUS<0] SLOOP[DODIV4] C600 $
	ALU[SH-AC] DEST[D5] MASK[0] NORM $
    ;end of .QUAD
DODIV6:	D[CONST 1] ROT[43] ALU[D#AC] DEST[AC] COND[-OBUS<0] C550 POPJ $ 
		;ADJUST REM SIGN, CHECK IT
	D[MEM] ALU[D+AC] DEST[AC] NORM POPJ $ 
		;ADJUST REM.

	.USE[NORMAL]



;JFFO1 JFFO2 JFFO3 JFFO5 JFFO4 ROTDO BIGLSH LSHPDO LSHDO LSHDO1 ASHDO1 BIGASH SETOV1 ASHDO ASHDOP
; BIGAS2 ASHC1 ASHC8 ASHC6 ASHC9 ASHC4 ASHC2 ASHC7 ROTC1 ROTC2 LSHC1 LSHC2 SJMAIN PUSH1 POP1 POPJ1 PUSHJ1

JFFO1:	ACSEL[AC+1] ALU[0] DEST[AC] JUMP[MAIN] NORM $
JFFO2:	D[AR] ROT[6] MASK[6] COND[-OBUS=0] JUMP[JFFO3] C550 $
	D[AR] ROT[6] DEST[AR] NORM $
	D[CONST 6] ACSEL[AC+1] ALU[AC+D] DEST[AC] JUMP[JFFO2] NORM $
JFFO3:	D[AR] COND[OBUS<0] JUMP[JFFO4] C550 $
JFFO5:	ACSEL[AC+1] ALU[AC+1] DEST[AC] NORM $
	D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[JFFO5] C550 $
JFFO4:	D[IR] DEST[PC MA] JUMP[MAIN1] NORM $; JUMP
.DEFINE SH2ND [ TYP DST1 DST2 DST3 ]
[TYP`PLS:	D[CONST 44] ALU[Q-D] COND[OBUS18] JUMP[DST3] C600 $
	D[CONST 44] ALU[Q-D] DEST[Q ROTR] JUMP[DST1] NORM $
TYP`NEG:	D[MASK 22] ROT[10] ALU[DORQ] DEST[Q ROTR] NORM $
TYP`NN1:	D[CONST 44] ALU[D+Q] DEST[Q ROTR] COND[-OBUS18] JUMP[TYP`DO] C600 $
	JUMP[DST2] NORM $
]

	.USE[AREA270]
	SH2ND [ROT ROTPLS ROTNN1 ROTDO]
ROTDO:	ACSEL[AC] ALU[AC] DEST[AR] SHORT $
	D[AR] ROT[R] ACSEL[AC] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $
	SH2ND [LSH BIGLSH BIGLSH LSHPDO]

	.USE[AREA272]
BIGLSH:	ACSEL[AC] ALU[0] SPEC[MA_PC] DEST[AC MA] JUMP[MAIN1] NORM $

LSHPDO:	D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
	D[2] MASK[R] ALU[D&AC] ACSEL[AC] DEST[AR] SHORT $
	D[AR] ROT[R] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

LSHDO:	ALU[Q] DEST[MASKR] SHORT $
	ALU[AC] ACSEL[AC] DEST[AR] SHORT $
LSHDO1:	D[AR] MASK[R] ROT[R] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
ASHDO1:	ALU[Q] DEST[MASKR] JUMP[LSHDO1] NORM $

	.USE[NORMAL]
	SH2ND [ASH BIGASH BIGAS2 ASHDOP]
BIGASH:	ALU[AC] ACSEL[AC] COND[OBUS=0] JUMP[MAIN] CYLEN[C450] $
	D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
	D[PC] DEST[Q] SHORT $
SETOV1:	D[CONST 1] ROT[43] ALU[DORQ] DEST[MA CRYOV] SPEC[MA_PC] NORM JUMP[MAIN1] $
ASHDO:	ACSEL[AC] ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[ASHDO1] CYLEN[C500] $
	D[CONST 44] ALU[D-Q] DEST[MASKR] SHORT $
	D[2] MASK[R] ROT[R] DEST[Q] SHORT $
	D[AR] ROT[R] ALU[DORQ] SPEC[MA_PC] DEST[AC MA] ACSEL[AC] JUMP[MAIN1] NORM $
ASHDOP:	D[CONST 43] ALU[D-Q] DEST[MASKR] SHORT $
	ALU[Q] DEST[IR-ADR] SHORT $; SAVE SH AMT
	D[CONST 1] ROT[43] ACSEL[AC] ALU[D&AC] DEST[Q] SHORT $ ;GET SIGN BIT
	D[2] MASK[R] ACSEL[AC] ALU[D&AC] DEST[AR] SHORT $
	D[AR] ROT[R] ACSEL[AC] ALU[DORQ] DEST[O_AC AR] SHORT $
	D[IR] ALU[D+1] DEST[MASKR] SHORT $
	D[AR] ROT[R] DEST[Q] SHORT $
	D[2] MASK[R] ROT[43] ALU[D&Q] DEST[Q] COND[OBUS=0] JUMP[MAIN] C550 $
	D[2] MASK[R] ROT[43] ALU[D#Q] COND[OBUS=0] JUMP[MAIN] C550 $
	D[PC] DEST[Q] JUMP[SETOV1] NORM $
BIGAS2:	ACSEL[AC] ALU[AC] COND[-OBUS<0] JUMP[BIGLSH] CYLEN[C450] $
	ACSEL[AC] ALU[-1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

ASHC1:	D[CONST 1] ROT[43] ALU[D&AC] ACSEL[AC] DEST[HOLD] NORM $ ; SAVE SIGN BIT
	D[IR] MASK[18.] COND[OBUS18] JUMP[ASHC2] C550 $
	D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
	ALU[0] ACSEL[AC+1] DEST[AC] SHORT $
	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
ASHC8:	ALU[SH-AC] DEST[D6] MASK[1] ACSEL[AC] NORM $
	ACSEL[AC] D[MEM] ALU[D#AC] COND[OBUS<0] JUMP[ASHC9] C550 $
ASHC6:	LOOP[ASHC8] NORM $
	D[PC] ACSEL[AC+1] ALU[DORAC] DEST[CRYOV] JUMP[ASHC7] NORM $
ASHC9:	D[CONST 1] ROT[43] ACSEL[AC+1] DEST[AC] JUMP[ASHC6] NORM $

.DEFINE SHLOOP [SHTYP DIR]
[	D[IR] MASK[10] ALU[D-1] LLOAD NORM $
	ALU[SH-AC] DEST[DIR] MASK[SHTYP] ACSEL[AC] LOOP[.] NORM $
]

ASHC4:	D[MEM] DEST[Q] SHORT $
	D[AR] ROT[43] MASK[43] ALU[DORQ] ACSEL[AC+1] DEST[AC] NORM $
	D[MASK 43] ACSEL[AC] ALU[D&AC] DEST[AC] SHORT $
	ACSEL[AC] ALU[QORAC] DEST[AC] JUMP[MAIN] NORM $
ASHC2:	D[IR] ALU[0-D] DEST[IR-ADR] NORM $
	SHLOOP [ 1 D4 ]
ASHC7:	ALU[Q] DEST[AR] JUMP[ASHC4] NORM $

	.USE[AREA274]
ROTC1:	D[IR] ALU[0-D] DEST[IR-ADR] JUMP[ROTC2] NORM $
	D[IR] COND[OBUS=0] MASK[10] JUMP[MAIN] C550 $
	SHLOOP[ 0 D6 ]
	ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
ROTC2:	SHLOOP[ 0 D4 ]
	ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $

	.PAIR
LSHC1:	D[IR] MASK[18.] ALU[0-D] DEST[IR-ADR] JUMP[LSHC2] NORM $
	D[IR] MASK[10] COND[OBUS=0] JUMP[MAIN] C550 $
	SHLOOP [ 2 D6 ]
	ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $
	.USE[AREA272]
	debuguse = .		;See if it is still losing
: 2735	;%$@#&@# SLOEXP didn't redefine AREA272 properly!!! $*$*$*
LSHC2:	SHLOOP[ 2 D4 ]
	ALU[Q] DEST[AC] ACSEL[AC+1] JUMP[MAIN] NORM $

	.USE[AREA202]
SJMAIN:	ACSEL[MA] D[MEM] DEST[AC] $
	D[IR] DEST[MA PC] JUMP[MAIN1] $

	.USE[NORMAL]
.REPEAT 1 - KL [
PUSH1:	ACSEL[AC] D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[PDLO2] C600 $
	D[AR] DEST[MEMSTO] MEMSTMA $

POP1:	D[MEM] DEST[AR] SHORT $
	D[IR] MASK[18.] DEST[MA] SHORT $
	D[AR] DEST[MEMSTO] MEMST $

POPJ1:	D[MEM] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $

PUSHJ1:	MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] MEMST $
];.REPEAT 1 - KL
.REPEAT KL [
PUSH1:	ACSEL[AC] D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[PDLO2] C600 $
	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PMSMAIN] NORM $

POP1:	D[MEM] DEST[AR] SHORT $
	D[IR] MASK[18.] DEST[MA] SHORT $
	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PMSMAIN] NORM $

POPJ1:	D[MEM] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $

PUSHJ0:	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] JUMP[PUSHJA] C600 $
		;JUMP IF FAKE OVERFLOW FLAG IS OFF.
	D[CONST 1] ROT[35. - 0] ALU[DORQ] DEST[MEMSTO Q] COND[HALF] LBJUMP[PUSHJ1] NORM $
		;FAKE OVERFLOW IS ON, OR IT INTO THE PC.
PUSHJA:	ALU[Q] DEST[MEMSTO] COND[HALF] LBJUMP[PUSHJ1] NORM $
		;FAKE OVERFLOW FLAG OFF, JUST STORE PC ON STACK.
.PAIR
;LBJUMP HERE FROM PUSHJ ON COND[HALF]
PUSHJ1:	MAPF[PPOP] COND[-MA-AC] LBJUMP[PUSHJMSMAIN] CYLEN[MEMSTO] $
		;WAIT FOR TRAP IF IT WILL HAPPEN, THEN RESET PC
		;COND[-MA-AC] DOESN'T NEED C550 CYCLE.
;HERE IF HALF FLAG ON IN OLD PC

PUSHJ2:	MAPF[PPOP] D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[PUSHJ1] $
		;IF FPD ON IN AMEM, PC STORED WAS CORRECT
	D[CONST 1] ROT[35. - 4.] ALU[-D&Q] DEST[MEMSTO] JUMP[PUSHJ1] $
		;CLEAR FPD, DO THE STORE AGAIN, REJOIN REAL CODE
.PAIR
PUSHJMSMAIN:
	ACSEL[MA] D[MEM] DEST[AC] NORM $
		;IN CASE STACK WAS IN REGISTERS
	D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] JUMP[MAIN] NORM $
		;NOW SET PC AND DO NEXT INSTRUCTION.
.PAIR
PMSMAIN: MAPF[PPOP] ACSEL[MA] D[MEM] DEST[AC] JUMP[MAIN] CYLEN[MEMSTO] $
	MAPF[PPOP] JUMP[MAIN] CYLEN[MEMSTO] $
];.REPEAT KL




;BLTA2 BLT1 BLT7 BLT5 BLT3 BLT2 BLT9 BLT4 BLT6 BLT8 BLTA3 BLTL1 BLTA4 BLTA1 BLTAL2 BLTA10 BLTL2 BLTA12 ANDCA1 ANDCA2 ANDCA3 LOG2 LOG3 ORCM2 ORCM3
	.PAIR
BLTA2:	ACSEL[AC] ALU[AC] DEST[AR MA] JUMP[BLTA3] NORM $ ;SRC IS AC GET DEST ADR
BLT1:	D[PC] DEST[O_AC AR] ACSEL[AC] SHORT $
	D[AR] MASK[18.] DEST[Q PC] SHORT $
	D[IR] MASK[18.] ALU[D-Q] DEST[Q] LLOAD NORM $;GET COUNT
	ALU[Q] COND[OBUS<0] JUMP[BLT4] CYLEN[C450] $ ; J IF END PRECEDES STRT
BLT7:	D[AR] MASK[18.] ROT[18.] DEST[Q MA AR] SHORT $; FETCH FIRST WORD
BLT5:	DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] JUMP[BLT2] CYLEN[FIXM] $
BLT3:	DEST[FIXMAC-MAPF-RD] MAPF[BLT-RD] SPEC[PC+1] CYLEN[FIXM] $
BLT2:	D[MEM] SPEC[MA_PC] DEST[MEMSTO MA] COND[INTRPT] JUMP[BLT6] NORM $
	ALU[Q+1] DEST[Q AR MA] LOOP[BLT3] MAPF[BLT-WRT] CYLEN[MEMSTO] $
BLT9:	D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $
	ACSEL[AC] D[IR] MASK[18.] ALU[AC-D] COND[-OBUS<0] JUMP[MAIN] C550 $ ;J IF DONE
	ACSEL[AC] ALU[AC+1] DEST[AC] SHORT $
	D[IR] ACSEL[AC] ALU[D-AC] LLOAD NORM $ ;GET COUNT
	D[PC] ACSEL[AC] DEST[O_AC PC] SHORT $
	ALU[Q] DEST[MA] JUMP[BLT5] NORM $
BLT4:	ALU[0] LLOAD NORM $
	JUMP[BLT7] NORM $
BLT6:	ALU[Q+1] DEST[Q AR] LOOP[BLT8] MAPF[BLT-WRT] CYLEN[MEMSTO] $
	JUMP[BLT9] $
BLT8:	ACSEL[AC] ALU[AC-1] DEST[AC] SPEC[PC+1] NORM $
	ACSEL[AC] D[PC] MASK[18.] DEST[O_AC PC] SHORT $
	D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] SHORT $
	DISP[2320] SPEC[PC+1-IF&] CYLEN[DISP] $
BLTA3:	D[AR] ROT[18.] DEST[AC-SEL] SHORT $ ;GET SRC ADR
	D[IR] MASK[18.] DEST[Q] SHORT $
	D[MA] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $
	ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $
	D[AR] ROT[18.] MASK[18.] ALU[D+Q] DEST[Q] SHORT $
	D[MASK 30] ROT[4] ALU[D&Q] COND[-OBUS=0] JUMP[BLTA10] C550  $;J IF SRC LEAVES AC'S
BLTL1:	ACSEL[REG] ALU[AC] DEST[MEMSTO] NORM $
	D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] MAPF[BLT-WRTA] LOOP[BLTL1] CYLEN[MEMSTO] $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
BLTA4:	ALU[0] DEST[Q] LLOAD NORM $
	POPJ NORM $
BLTA1:	D[MASK 16] ROT[26] ACSEL[AC] ALU[D&AC] COND[OBUS=0] JUMP[BLTA10] C550 $; DEST IS AC, J IF SRC AC?
	D[IR] ROT[40] MASK[16] COND[-OBUS=0] JUMP[BLTA10] C550 $;J IF FINAL DEST NOT AC
	ACSEL[AC] ALU[AC] DEST[AR AC-SEL] SHORT $;GET DEST ADR
	D[IR] MASK[18.] DEST[Q] SHORT $
	D[AR] MASK[18.] ALU[Q-D] DEST[Q] LLOAD NORM $;GET COUNT
	ALU[Q] COND[OBUS<0] PUSHJ[BLTA4] CYLEN[C450] $;ADJUST IF CNT NEG.
	D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET SRC ADR
BLTAL2:	DEST[FIXMAC-MAPF-RD AC] MAPF[BLT-RDA] D[MA] ALU[D+1] ACSEL[REG] CYLEN[FIXM] $
	ACSEL[REG] D[MEM] DEST[O_AC MA A-MEM-CNTR&INC] LOOP[BLTAL2] NORM $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
BLTA10:	ACSEL[AC] ALU[AC] DEST[AR] SHORT $
BLTL2:	D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $;GET WORD
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
	D[MEM] DEST[HOLD Q] SHORT $
	D[AR] MASK[18.] DEST[MA STRT-WRT] SHORT $
	MAPF[BLT-WRTA] COND[-MA-AC] JUMP[. + 2] C500 $
	ALU[Q] ACSEL[MA] DEST[AC] SHORT $
	D[AR] MASK[18.] DEST[Q] NORM $
	D[IR] MASK[18.] ALU[Q-D] MAPF[BLT-WRTA] COND[-OBUS<0] JUMP[MAIN] C600 $
	D[CONST 1,,1] DEST[Q]  NORM $
	D[AR] ALU[D+Q] DEST[AR] JUMP[BLTL2] NORM $;*** TEST FOR INTERRUPT HERE?
BLTA12:	MEMST $

	.USE[AREA276]

ANDCA1:	D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

ANDCA2:	D[MEM] ALU[D&Q] DEST[MEMSTO] MEMST $

ANDCA3:	D[MEM] ACSEL[AC] ALU[D&Q] DEST[AC MEMSTO] MEMST $

LOG2:	ALU[NOTQ] DEST[MEMSTO] MEMST $

LOG3:	ACSEL[AC] ALU[NOTQ] DEST[AC MEMSTO] MEMST $

ORCM2:	ACSEL[AC] ALU[QORAC] DEST[MEMSTO] MEMST $

ORCM3:	ACSEL[AC] ALU[QORAC] DEST[AC MEMSTO] MEMST $

	.USE[NORMAL]



;SWINT NORSW NOSW RESW1 RESET RESET RESLOP DOHALT STPLOP STPLP1 NORSW2 RESW2 STRTSW CONSW DEPTSW
; DEPNSW DEPSW1 EXMTSW EXMNSW SETLTS EXMSW1 BRPNT MOVSS1 MOVNS1 HLLZS1 HRLZS1 HRRZS1 HLRZS1 HRAR
; HLAR HLLEM1 HRLEM1 HLREM1 HRREM1 HSMAIN HSMN1 HLLOS1 HRROS1 HLLES1 HRRES1 HLLES2 HMV HHS HLSZ HOR
; HRSZ HOL HRLM1 HLLM1 HLRM1 HRRM1 JRST1 JRST4 JRST5 JRST9 JRST8 JRST2 JRST3 JFCL1 JSR2 JSA1 JRA1 MUJSR MUJSP
;  MUJSA MUJSYS MUJSM1
;;;RESW1:
	.ORG[2062]	;*$*$* No REAL reason for this
: 2062	;SWITCH INTERRUPTS COME HERE
SWINT:	DEST[CLR-DEV-FROM-INTR] SHORT $
	ALU[0] DEST[DEV-ADR] SPEC[IOB-IN] SHORT $
	D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $ 		;GET SW BITS
	D[CONST 15] ROT[1] DEST[Q] SPEC[IOB-OUT] SHORT $
	D[AR] ROT[14] ALU[D&Q] MAPF[4] COND[OBUS=0] JUMP[NOSW] C550 $	;CHECK FOR RELEVANT SW, & CLR FF.
	D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW1] C550 $	;J IF RESET SW
NORSW:	D[AR] ROT[13. + 1] MASK[1] ALU[NOTD] DEST[MAP-DISABLE] NORM $
		;IF SWITCH 13 IS OFF, DISABLE MAP, ELSE ENABLE IT IF MAPPING IS ON.
	D[AR] ROT[13] MASK[1] COND[-OBUS=0] PUSHJ[EXMTSW] C550 $
		;PUSHJ IF EXAM THIS
	D[AR] ROT[11] MASK[1] COND[-OBUS=0] PUSHJ[DEPTSW] C550 $
		;PUSHJ IF DEPO THIS
	ALU[0] DEST[MAP-DISABLE] JUMP[UINT-DISMISS] NORM $
		;ENABLE MAPPING AGAIN, IF IT WAS TURNED ON.
area206 = .	;Sigh...
	.RELOC
NOSW:
UINT-DISMISS:
	D[12] SPEC[A-MEM-APR] ROT[2] MASK[2] DEST[AR] COND[-HALF] JUMP[MAIN] NORM $
		;IF HALF FLAG NOT ON, NO TRAP IS IN PROGRESS
	D[AR] COND[OBUS=0] C550 JUMP[MAIN] $
		;IF TRAP FLAGS ARE ZERO, NO TRAP IN PROGRESS, JUST RESTART INSTRUCTION

	D[PC] ALU[D+1] DEST[PC] JUMP[DOTRPX] NORM $
		;TRAP GOT INTERRUPTED - INCREMENT PC, SINCE IT POINTED TO
		; INSTRUCTION BEFORE NEXT TO BE EXECUTED, AND RE-EXECUTE THE
		; TRAP INSTRUCTION.

RESW1:	SPEC[IOB-IN] SHORT $
	D[IOD] DEST[AR]  CYLEN[IOB-IN] $	;DOUBLE CHECK RESET SW
	D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW] CYLEN[C650] $	;DOUBLE CHECK RESET SW

;******* This code to be made a subroutine to allow machine resetting *******
;******* to be done by auto-loading and via CONO APR,20000  TVR-Mar80 *******

.REPEAT F2SW [
RESET:	D[CONST 0] DEST[IOD] SPEC[IOB-OUT] NORM $
  ]  ;END F2SW

.REPEAT 1 - F2SW [
RESET:	D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
  ]  ;END 1 - F2SW
;*** Disable ECC interrupts on F3's?????

	MAPF[10] ALU[0] DEST[CRYOV] CYLEN[IOB-OUT] $
		;CLR MAP-IN-USE & PC FLAGS & AR INT ENBL, ETC.
.REPEAT KL [
	D[12] SPEC[A-MEM-APR] MASK[36. - 5] DEST[Q] NORM $
		;CLEAR OUT BITS 0-4 IN AMEM[2]
	ALU[Q] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
		;(THE SHADOW PC FLAGS, AND JRSTF TRAP FLAG)
];.REPEAT KL
	DEST[CLR-MI-ERR] JUMP[RESLOP] NORM $
RESLOP:	ALU[0] DEST[HI-ABS-MA] NORM $
	DEST[CLR-DEV-FROM-INTR] $
	D[CONST 0] DEST[DEV-ADR] PUSHJ[APRRST] NORM $
	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPRST] NORM $
	D[CONST 4] DEST[DEV-ADR] PUSHJ[CTYRST] NORM $
	D[CONST 10] DEST[DEV-ADR] PUSHJ[DSKRST] NORM $
	D[CONST 7] DEST[DEV-ADR] PUSHJ[TAPRST] NORM $
.REPEAT DLS [; 9 JAN 80  BO
	D[CONST DLSDEV] DEST[DEV-ADR] PUSHJ[DLSRST] NORM $
];DLS
.REPEAT VC [ ; 24 AUG 80  BO
	D[CONST VCDEV] DEST[DEV-ADR] PUSHJ[VCRST] NORM $
] ; VC
.REPEAT IMP [; 23JAN80 MLB
	D[CONST 16] DEST[DEV-ADR] PUSHJ[IMPRST] NORM $
];IMP
.REPEAT LPT [
.REPEAT STANSW [
	D[CONST 15] DEST[DEV-ADR] PUSHJ[LPTRST] NORM $
		;Hardware is trapping to wrong place!!!
];.REPEAT STANSW
	D[CONST 35] DEST[DEV-ADR] PUSHJ[LPTRST] NORM $
];LPT
.REPEAT STANSW [;Mar80 TVR
	D[CONST 30] DEST[DEV-ADR] PUSHJ[PANRST] NORM $
	D[CONST 30] DEST[DEV-ADR] PUSHJ[GRNRST] NORM $
];REPEAT STANSW
	D[CONST 6] DEST[DEV-ADR] PUSHJ[CLKRST] NORM $
	D[CONST 6] DEST[DEV-ADR] PUSHJ[TYMRST] NORM $
	D[CONST 6] DEST[DEV-ADR] PUSHJ[PI-RESET] NORM $
DOHALT:	DEST[CLR-DEV-FROM-INTR] NORM $
STPLOP:	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[CONST 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] $; SET PROG HALT LIGHT
	ALU[0] DEST[DEV-ADR MA] SPEC[MA_PC] NORM $
	FIXM1 SPEC[IOB-OUT] $
	D[MEM] MAPF[6] CYLEN[LONG] $
	SPEC[IOB-IN] NORM $
	D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $
	D[AR] COND[OBUS<0] JUMP[BRPNT] C600 $; J IF BRK POINT SW
	SPEC[IOB-IN] NORM $
STPLP1:	D[IOD] DEST[AR] MAPF[4] CYLEN[IOB-IN] $	;GET SW BITS
	D[AR] ROT[10] MASK[1] COND[-OBUS=0] JUMP[RESW2] C550 $	;J IF RESET SW
	D[AR] ROT[14] MASK[11] DEST[Q] NORM $
	D[CONST 7] ROT[4] ALU[-D&Q] COND[OBUS=0] SPEC[IOB-IN] JUMP[STPLP1] C600 $; LOOP IF NO SW
	SPEC[IOB-OUT] NORM $
	MAPF[4] CYLEN[IOB-OUT] $    	;CLR SW FF'S
	.DEFINE SWTEST [ RAMT DIS ADR ]
[	D[AR] ROT[RAMT] MASK[1] COND[-OBUS=0] DIS [ ADR ] C550 $
]
NORSW2:	SWTEST[4 JUMP CONSW]
	SWTEST[5 JUMP STRTSW]
	D[AR] ROT[13. + 1] MASK[1] ALU[NOTD] DEST[MAP-DISABLE] NORM $
		;IF ADDRESS SWITCH 13 IS CLEAR, DISABLE MAP FOR NOW
	SWTEST[11 PUSHJ DEPTSW]
	SWTEST[12 PUSHJ DEPNSW]
	SWTEST[13 PUSHJ EXMTSW]
	SWTEST[14 PUSHJ EXMNSW]
	ALU[0] DEST[MAP-DISABLE] NORM $
		;RE-ENABLE MAP IF IT WAS ON
	D[CONST 0] DEST[DEV-ADR] SPEC[IOB-IN] JUMP[STPLP1] NORM $	;LOOP

RESW2:	SPEC[IOB-IN] SHORT $
	D[IOD] DEST[AR]  CYLEN[IOB-IN] $	;DOUBLE CHECK RESET SW
	D[AR] ROT[10] MASK[1] COND[OBUS=0] JUMP[NORSW2] CYLEN[IOB-IN] $	;DOUBLE CHECK RESET SW
	JUMP[RESET] NORM $
STRTSW:	D[AR] MASK[23] DEST[PC] NORM $
CONSW:	ALU[0] SPEC[MA_PC] DEST[MA HI-ABS-MA] NORM $
	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] NORM $
	D[CONST 7] ALU[D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] $; CLEAR PROG HALT LIGHT
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[1] CYLEN[FIXM] $
	D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $; IGNORE STOP SW

DEPTSW:	D[AR] MASK[23] DEST[MA HI-ABS-MA] SPEC[IOB-IN] JUMP[DEPSW1] NORM $
DEPNSW:	D[MA] ALU[D+1] DEST[MA] NORM SPEC[IOB-IN] $
DEPSW1:	D[IOD] DEST[MEMSTO] MAPF[2] CYLEN[IOB-IN] $
	MAPF[TEMP] COND[-MA-AC] POPJ CYLEN[MEMSTO] $
	ACSEL[MA] D[MEM] DEST[AC] POPJ NORM $

EXMTSW:	D[AR] MASK[23] DEST[MA HI-ABS-MA] JUMP[EXMSW1] NORM $
EXMNSW:	D[MA] ALU[D+1] DEST[MA] JUMP[EXMSW1] NORM $
;NOTE: This subroutine is called by DATAO PI, which displays in the lights
SETLTS:	FIXM1 $			;Take page faults, if any.
EXMSW1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[TEMP] CYLEN[FIXM] $
	SPEC[IOB-OUT] NORM $
	D[MEM] MAPF[2] CYLEN[LONG] POPJ $
BRPNT:	D[AR] MASK[27] DEST[Q] NORM $
	D[PC] MASK[27] ALU[D-Q] COND[-OBUS=0] JUMP[CONSW] C600 $
	SPEC[IOB-IN] JUMP[STPLP1] NORM $

	.USE[AREA276]
MOVSS1:	D[MEM] ROT[18.] ACSEL[AC] DEST[AC MEMSTO] MEMST $

MOVNS1:	D[MEM] ALU[0-D] ACSEL[AC] DEST[AC MEMSTO] MEMST $

HLLZS1:	ACSEL[MA] D[MEM] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC] LBJUMP[HSMAIN] NORM $

HRLZS1:	ACSEL[MA] D[MEM] ROT[18.] COND[AC=0] DEST[AC AR MA] SPEC[LEFT&MA_PC] LBJUMP[HSMAIN] NORM $

HRRZS1:	ACSEL[MA] D[MEM] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC] LBJUMP[HSMAIN] NORM $

HLRZS1:	ACSEL[MA] D[MEM] ROT[18.] MASK[18.] COND[AC=0] DEST[AC AR MA] SPEC[MA_PC] LBJUMP[HSMAIN] NORM $

	.USE[AREA342]
HRAR:	D[AR] MASK[18.] ALU[DORAC] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

HLAR:	D[AR] SPEC[LEFT&MA_PC] MASK[0] ALU[DORAC] ACSEL[AC] DEST[AC MA] JUMP[MAIN1] NORM $

HLLEM1:	D[AR] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST $

HRLEM1:	D[AR] ROT[18.] MASK[0] SPEC[LEFT] DEST[MEMSTO] MEMST $

HLREM1:	D[AR] ROT[18.] MASK[18.] DEST[MEMSTO] MEMST $

HRREM1:	D[AR] MASK[18.] DEST[MEMSTO] MEMST $

	.USE[AREA344]
	.PAIR
HSMAIN:	ACSEL[AC] D[AR] DEST[AC] NORM $
	FIXM1 JUMP[MAIN2] $
	.PAIR
HSMN1:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] CYLEN[MEMSTO] $
	D[MEM] ACSEL[AC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[MEMSTO] $
	.PAIR
HLLOS1:	D[MASK 22] ALU[DORQ] DEST[MEMSTO] MEMST $
	D[MASK 22] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST $
	.PAIR
HRROS1:	D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST $
	D[MASK 22] ROT[18.] ALU[DORQ] DEST[MEMSTO AC] ACSEL[AC] MEMST $
	.PAIR
HLLES1:	D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
	COND[-AC=0] LBJUMP[HLLOS1] NORM $
	.PAIR
HRRES1:	D[MASK 22] ALU[D&Q] DEST[Q] COND[-AC=0] LBJUMP[HLLES2] NORM $
	COND[-AC=0] LBJUMP[HRROS1] NORM $
	.USE[AREA346]
	.PAIR
HLLES2:	ALU[Q] DEST[MEMSTO] MEMST $
	ALU[Q] ACSEL[AC] DEST[MEMSTO AC] MEMST $
	.PAIR
HMV:	JUMP[MAIN] NORM $
	JUMP[MOVE] NORM $
	.PAIR
HHS:	D[AR] ROT[18.] ALU[DORQ] DEST[MEMSTO] MEMST $
	D[AR] ROT[18.] ALU[DORQ] ACSEL[AC] DEST[MEMSTO AC] MEMST $
	.USE[AREA352]
	.PAIR
HLSZ:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
HOR:	D[MASK 22] ACSEL[AC] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
	.PAIR
HRSZ:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
HOL:	D[MASK 22] ACSEL[AC] ROT[18.] ALU[DORAC] SPEC[MA_PC] DEST[MA AC] JUMP[MAIN1] NORM $
	.PAIR
HRLM1:	D[AR] ROT[18.] DEST[Q] NORM $
HLLM1:	D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] MEMST $
	.PAIR	;(??) Added TVR-Apr80
HLRM1:	D[AR] ROT[18.] DEST[Q] NORM $
HRRM1:	D[MEM] MASK[0] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST $

.REPEAT 1 - KL [
	.USE[AREA350]
	.PAIR
JRST1:	COND[USER] JUMP[JRST8] NORM $; ILLEGAL IF USER MODE
	D[IR] ROT[14] MASK[1] COND[-OBUS=0] JUMP[JRST2] C550 $
	JUMP[JRST4] NORM $
JRST4:	D[IR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JRST3] C550 $
JRST5:	D[IR] ROT[13] MASK[1] COND[-OBUS=0] JUMP[JRST9] C550 $;J TO STOP SWITCH IF HALT
	D[IR] ROT[12] MASK[1] COND[-OBUS=0] JUMP[PI-DISMISS] C550 $; J IF DISMISS BIT ON
	JUMP[MAIN1] NORM SPEC[MA_PC] DEST[MA] $
JRST9:	COND[EXEC] JUMP[DOHALT] NORM $; HALT IF EXEC MODE
JRST8:	MUUO1

JRST2:	D[PC] DEST[Q] SHORT $
	D[CONST 1] ROT[36] ALU[D&Q] DEST[Q] SHORT $
	D[AR] ALU[DORQ] DEST[CRYOV] JUMP[JRST4] NORM $
	.USE[AREA354]
JRST3:	D[CONST 1] ROT[36] DEST[Q] SHORT $
	D[PC] ALU[DORQ] DEST[CRYOV] JUMP[JRST5] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
;HERE WITH RH(PC) SETUP TO NEW PC, AR CONTAINS 36 BIT NEW PC WORD
; LEFT FROM EFFECTIVE ADDRESS CALCULATION.
; GET HERE VIA LBJUMP ON THE 10 BIT IN AC FIELD


	.USE[AREA53]
.PAIR

JRST1:	COND[USER] JUMP[MUUO] NORM $;JRST 1X ILLEGAL IN USER MODE, IT TRAPS
	D[IR] ROT[10.] COND[OBUS<0] JUMP[JRSTH] C550 $
		;JUMP IF THIS IS HALT.
	D[IR] ROT[11.] COND[OBUS<0] JUMP[JRSTF] C550 $
		;JUMP IF THIS IS JRSTF
JRST2:	D[IR] ROT[9.] COND[OBUS<0] JUMP[PI-DISMISS] C550 $
		;IF ITS JRST 10 CAN'T BE USER, DO PI DISMISS
	JUMP[MAIN] NORM $
		;DO NORMAL JUMP.

JRSTH:	COND[EXEC] JUMP[DOHALT] NORM $
		;HALT IF EXEC MODE
	JUMP[MUUO] NORM $
		;ELSE TRAP

JRSTF:	D[AR] MASK[35.] DEST[Q] COND[EXEC] JUMP[JRSTF0] NORM $
		;GET NEW PC INTO Q, MASK OFF OVERFLOW BIT,
		; JUMP IF EXEC MODE DID THIS INSTRUCTION
		;AR STILL CONTAINS ORIGINAL USER ARGUMENT TO JRSTF,
		; AND WILL FOR THE REST OF JRSTF CODE.
	D[CONST 1] ROT[35. - 5.] ALU[DORQ] DEST[Q] SHORT $
		;FROM USR MODE, FORCE USR MODE BIT ON
	D[PC] ROT[6] COND[OBUS<0] C550 JUMP[JRSTF0] $
		;IF USER IOT ON ON OLD PC, DON'T FORCE CLEARING IT IN NEW PC
	D[CONST 1] ROT[35. - 6.] ALU[-D&Q] DEST[Q] NORM $
		;AND FORCE USER IOT BIT OFF.
JRSTF0:	D[CONST 1] ROT[35. - 9.] ALU[-D&Q] DEST[CRYOV] $
		;SET PC FLAGS, CLEARING 9 (TRAP FLAG)
JRSTF1:	D[12] SPEC[A-MEM-APR] DEST[Q] NORM $
		;GET WORD WITH OVERFLOW BIT IN IT
	D[AR] ROT[0] COND[-OBUS<0] C550 JUMP[JRSTF1A] $
		;JUMP IF HES NOT TRYING TO SET OVERFLOW
	D[CONST 1] ROT[35. - 4] ALU[DORQ] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM]
	   JUMP[JRSTF1B] NORM $
		;SET FAKE OVERFLOW BIT AND REJOIN.
JRSTF1A:D[CONST 1] ROT[35. - 4] ALU[-D&Q] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM]
	  NORM $
		;CLEAR FAKE OVERFLOW BIT.
JRSTF1B:D[AR] ROT[10. + 1] MASK[2] DEST[Q] COND[OBUS=0] JUMP[JRSTF3] C550 $
		;JUMP IF NOT SETTING TRAP FLAGS
	D[CONST 1] ROT[35. - 0.] ALU[DORQ] DEST[AR] SHORT $
		;SET THE JRSTF TRAP FLAG IN SIGN BIT
	D[12] SPEC[A-MEM-APR] MASK[36. - 4.] DEST[Q] COND[-HALF] JUMP[JRSTF2] NORM $
		;GET AMEM LOC WITH THE BITS IN IT
		;JUMP IF HALF IS OFF IN PC
	D[CONST 1] ROT[35. - 3.] ALU[DORQ] DEST[Q] NORM $
		;FPD ON IN NEW PC, SO SET IT IN AMEM DATA
	
JRSTF2:	D[AR] ROT[35. - 1.] ALU[DORQ] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] PUSHJ[SETHLF] NORM $
		;ADJUST BITS TO BE TP0,TP1,JRSTT AND OR THEM INTO AMEM
		; AND SET HALF FLAG IN CASE IT ISN'T SET
	JUMP[JRST2] NORM $
		;AND GO SEE IF NEED TO DO A JEN FUNCTION

JRSTF3:	D[12] SPEC[A-MEM-APR] DEST[Q] COND[HALF] JUMP[JRSTF4] NORM $
		;GET BITS IN CASE NEED TO CLEAR FPD, JUMP IF HAVE TO SET IT.
	D[CONST 1] ROT[35. - 3] ALU[-D&Q] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] JUMP[JRST2] NORM $
		;CLEAR FPD (HALF ALREADY CLEARED FROM DEST[CRYOV] ABOVE
		; AND GO SEE IF HAVE TO DO JEN

JRSTF4:	PUSHJ[SETFPD] NORM $
		;SET THE BIT IN AMEM
	JUMP[JRST2] SHORT $
		;AND GO CHECK FOR JEN
;ROUTINE CALLED WITH PC IN AR IF HALF FLAG IS SET
; FROM THE ROUTINE THAT INTERPRETS THE JSX INSTRUCTIONS WHEN
; THEY ARE EXECUTED FROM THE PI VECTOR LOCATIONS.
; ALSO CALLED FROM PAGE FAULT IF HALF IS ON TO ADJUST PC AND CLEAR THE
; AMEM FLAGS.
; COPIES FPD, TI1 AND TI2 FROM AMEM[2] TO PC IN AR, CLEARS THE JRSTF
; TRAP FLAG AND TI1, TI2, FPD.
; ALSO INCREMENTS THE PC IF THE TRAP FLAGS IN AMEM ARE SET, SINCE IF WE
; ARE INTERRUPTING A TRAP CYCLE, THE PC WAS DECREMENTED EITHER BY
; DOTRPX IF TRAP INSTRUCTIONS DISPATCH HASN'T HAPPENED YET, OR BY
; PAGE FAIL IF DISPATCH ON TRAP HAS HAPPENED, OR BY THE TRAP INSTRUCTION
; CODE THAT PREPARES TO BE INTERRUPTED (SUCH AS XCT, WHICH MUST DECREMENT
; PC AGAIN BEFORE DOING A DISPATCH SO THAT IF IT GETS INTERRUPTED
; THE XCT WILL BE RESTARTED PROPERLY.


TPCFIX:	D[AR] DEST[Q] NORM $
		;SAVE PC IN Q FOR AWHILE
	D[12] SPEC[A-MEM-APR] ROT[2] MASK[2] DEST[AR] COND[OBUS=0] C550 JUMP[TPCFI1] $

		;GET TI1 AND TI2 IN 34 AND 35 OF AR
		; AND JUMP IF NEITHER IS SET
	D[12] SPEC[A-MEM-APR] ROT[2] COND[OBUS<0] C550 JUMP[TPCFI1] $
		;IF JRSTT SET, THEN WE ARE HERE FROM INTERRUPT INSTRUCTION
		; THAT WAS STARTED AFTER A JRSTF SETTING TRAP FLAGS BUT
		; BEFORE DOTRPX WAS CALLED, SO PC NOT DECREMENTED. DON'T INCREMENT
		; IT, THEREFORE.
	ALU[Q+1] DEST[Q] SHORT $
		;MUST INCREMENT PC, TRAP IS IN PROGRESS
TPCFI1:	D[AR] ROT[35. - 10.] ALU[DORQ] DEST[Q AR] NORM $
		;SET TI1 AND TI2 INTO PC, RESULTS IN Q AND AR
	D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[TPCFI2] $
		;JUMP IF FPD ON IN AMEM (ALREADY SET IN PC, SO PC OK)
	D[CONST 1] ROT[35. - 4.] ALU[-D&Q] DEST[AR] NORM $
		;CLEAR FPD IN OLD PC, STORE IN AR
TPCFI2:D[12] SPEC[A-MEM-APR] MASK[36. - 4.] DEST[Q] NORM $
		;CLEAR THE JRSTF TRAP FLAG, SINCE MAY HAVE GOTTEN
		; AN INTERRUPT RIGHT AFTER A JEN OR JRSTF SET IT,
		; IN WHICH CASE TRAP FLAGS ARE ON.
	ALU[Q] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] POPJ NORM $
		;STORE CLEARED BITS AND RETURN
		; (DOESN'T HURT TO CLEAR TI FLAGS, MAIN1 WILL CLEAR
		; THEM ANYWAY. ALSO, MAKES ROUTINE USEFUL FOR PAGE FAULT)
;ROUTINE TO SET THE FIRST PART DONE BIT IN THE "VIRTUAL" PC,
; MEANING SET HALF BY CALLING SETHLF AND SET THE FPD BIT
; IN AMEM[2]. USES Q.

SETFPD:	D[12] SPEC[A-MEM-APR] DEST[Q] NORM $
		;GET BITS
	D[CONST 1] ROT[35. - 3.] ALU[DORQ] DEST[Q 2] SPEC[A-MEM-APR&DEST-A-MEM] COND[HALF] POPJ NORM $
		;SET FPD. IF HALF ON ALREADY, DONE.
	D[MASK 33.] ALU[D&Q] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] JUMP[SETHLF] NORM $
		;CLEAR OUT TI1 TI2 AND JRSTT, GO SET HALF.
	.USE[AREA354]
];.REPEAT KL


.REPEAT KL [;ON KL MUST OR IN OVERFLOW FROM AMEM[2]
	.USE[NORMAL]
JFCL1:	D[AR] ROT[40] COND[-OBUS<0] C550 JUMP[JFCL2] $
		;JUMP IF NOT SELECTING OVERFLOW
	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] C550 JUMP[JFCL2] $
		;JUMP IF SELECTING OVERFLOW BUT ITS NOT ON IN AMEM
		; AND STORE THE DATA IN HOLD
		; (IF TRAPS OFF STILL WILL DEAL WITH REAL OVERFLOW ON BELOW.)
	D[AR] ROT[40] ALU[-D&Q] DEST[CRYOV] SHORT $
		;CLEAR THE REST OF THE FLAGS NOW AND FREE UP Q.
	D[12] SPEC[A-MEM-APR] DEST[Q] NORM $
		;GET AMEM WORD SO CAN CLEAR OUT OVERFLOW FLAG
	D[CONST 1] ROT[35. - 4] ALU[-D&Q] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
		;CLEAR OUT FAKE OVERFLOW BIT IN AMEM AND THEN
	DOJUMP $
	.USE[AREA354]
];.REPEAT KL
.REPEAT 1 - KL [
JFCL1:
];.REPEAT 1 - KL

JFCL2:	D[AR] ROT[40] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $;TEST SELECTED FLAGS
	D[AR] ROT[40] ALU[-D&Q] DEST[CRYOV] SHORT $;CLEAR FLAGS
	DOJUMP $
JSR1:	D[12] SPEC[A-MEM-APR] ROT[4] COND[OBUS<0] C550 JUMP[JSR1B] $
		;JUMP IF FAKE OVERFLOW ON IN AMEM
	D[PC] DEST[AR MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
		;Write PC (and flags) into effective address.
		;Watch for special case of store into AC
JSR1A:	MAPF[STO] D[MA] ALU[D+1] DEST[PC] CYLEN[MEMSTO] $
		;STORE PC. CON'T CLEAR HALF YET, MAY BE IN TRAP CYCLE.
	SPEC[CLR-HALF] JUMP[MAIN] NORM $
		;NO PAGE TRAP, SO CAN CLEAR HALF FLAG NOW.
		;Set PC into one after effective address (where we stored old
		;PC) and take next instruction from there.
		;Make sure some nurd hasn't left the BIS flag on. (*** i assume
		;  that's what going on here.  TVR-Apr80)

;HERE IF FAKE OVERFLOW FLAG IS ON IN AMEM.
JSR1B:	D[CONST 1] ROT[35. - 0] DEST[Q] SHORT $
	D[PC] ALU[DORQ] DEST[AR MEMSTO] COND[-MA-AC] JUMP[JSR1A] $
		;SET FAKE OVEFLOW IN PC, STORE IN MEMORY AND AR, JUMP
		; IF NOT AC REF, ELSE FALL INTO JSR2
JSR2:	D[MA] ALU[D+1] DEST[PC] SPEC[CLR-HALF] MAPF[STO] NORM $
	ACSEL[MA] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

	.USE[NORMAL]

JSA1:	D[MA] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] NORM $
		;Put effective address into right half, i.e. were the old
		;contents of the AC is stored.
		;(This is the FORTRAN subroutine call, in case you were
		; wondering why it was so wierd...)
	D[MA] ALU[D+1] DEST[PC] SHORT $
	D[AR] DEST[MEMSTO] MEMST $


JRA1:	FIXM1 $
	ACSEL[AC] D[MEM] DEST[AC] CYLEN[FIXM+1] $
	D[IR] MASK[18.] DEST[PC MA] JUMP[MAIN1] NORM $

	.USE[NORMAL]
.REPEAT 1 - KL [
MUJSR:	D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
	D[AR] DEST[MEMSTO] COND[MA-AC] JUMP[JSR2] NORM $
	D[MA] ALU[D+1] DEST[MA PC] MAPF[STO] SPEC[CLR-HALF] JUMP[MAIN1] CYLEN[MEMSTO] $
MUJSP:	D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
	D[AR] ACSEL[AC] DEST[AC] JUMP[JSP1] NORM $
MUJSA:	D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
	D[AR] ACSEL[AC] DEST[O_AC AR] JUMP[JSA1] NORM $
MUJSYS:	D[MEM] DEST[IR-ALL MA] SHORT $
	D[IR] ROT[33] MASK[11] COND[OBUS=0] JUMP[JSYS3] C550 $; J IF EX JSYS
MUJSM1:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[MAPFTR] CYLEN[FIXM] $
	D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
	D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET READY TO STORE
	D[AR] DEST[MEMSTO] MEMSTMA $

];.REPEAT 1 - KL
.REPEAT KL [
MUJSR:	PUSHJ[MAPOF] NORM $
		;INTERRUPT JSR HAS TO STORE IN PHYSICAL SPACE, ELSE
		; COULD GET PAGE REFILL AND NO WAY TO RESTART THE INTERRUPT
	D[MEM] DEST[MA] COND[HALF] PUSHJ[TPCFIX] NORM $
		;GET INSTRUCTION AND
		;AND FIX PC UP IN AR IF HALF IS ON
	D[AR] DEST[MEMSTO Q] NORM $
		;START PC WORD GOING TO MEMORY.
	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] JUMP[MUJSR0] C550 $
		;IF FAKE OVERFLOW BIT IS ON,
	D[CONST 1] ROT[35. - 0] ALU[DORQ] DEST[AR MEMSTO] NORM $
		;SET OVERFLOW BIT IN PC AND START STORING INTO MEMORY
MUJSR0:	PUSHJ[MAPON] CYLEN[MEMSTO] $	;TURN MAP BACK ON
	COND[MA-AC] JUMP[JSR2] NORM $ ;IF AC REF, DO REST OF INSTRUCTION WITH SPECIAL AC CODE
	D[MA] ALU[D+1] DEST[MA PC] SPEC[CLR-HALF] JUMP[MAIN1] NORM $
		;FINISH.

;HERE ON NORMAL JSR IF HALF FLAG WAS ON IN PC BUT FPD WAS OFF.
		;TURN ON MAP AGAIN (WAS OFF IF FROM MUJSR)
MUJSP:	D[MEM] DEST[IR-ALL MA] COND[HALF] PUSHJ[TPCFIX] NORM $; GET INSTR.
		;AND FIX PC UP IN AR IF HALF FLAG IS ON
	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] C550 JUMP[MUJSP1] $
		;JUMP IF FAKE OVERFLOW NOT ON IN AMEM
	D[CONST 1] ROT[35. - 0] DEST[Q] SHORT $
	D[AR] ACSEL[AC] ALU[DORQ] DEST[AC] JUMP[JSP1] NORM $
		;JUST LIKE INSTRUCTION AT MUJSP1 EXCEPT OR IN BIT 0 (OVERFLOW).
MUJSP1:	D[AR] ACSEL[AC] DEST[AC] JUMP[JSP1] NORM $
MUJSA:	D[MEM] DEST[IR-ALL MA] NORM $; GET INSTR.
	D[AR] ACSEL[AC] DEST[O_AC AR] JUMP[JSA1] NORM $
];.REPEAT KL



;CTYDSP CTYINT CTYIOT CTYDI CTYDO CTYCO CTYCI CTYCI2 CTYCI1 CTYCI9 CTYCI8 CTYCI3 CTYCO1
; CTYCO3 CTYCO4 CTYCO5 CTYRST ctyrs1 CTYCZ CTYCS
;------------------------------------------------------------------------------
;
;	CTY - Console Teletype				Device 120
;
;------------------------------------------------------------------------------

;
;A-MEM Usage
;
CTY-DISP = 0		;Instruction and interrupt dispatch
CTY-CONT = 1		;Control bits for UART, etc.
CTY-STATUS = 2		;Firmware status

;
;*** Meanings of hardware bits should be documented here.
;
;MAPF values

.REPEAT NTP [
TTY.DI = 0	;read data
TTY.WD = 12	;write data
TTY.WC = 14	;write control
  ] ;NTP

.REPEAT OTP [
TTY.DI = 0	;read data
TTY.WD = 4	;write data
TTY.WC = 10	;write control
  ] ;OTP

;*$*$*	This ORG is ready to be flushed.  It only remains to test the code
;	and merge the AREAs

	.ORG[CTYIOTDISP-ORG]	;CTY IOT DISPATCH TABLE

CTYDSP:	ILGIOT $	;BLKI
	NOP $
	D[CTY-STATUS + 10] DEST[Q] SPEC[IOB-IN] NORM $ ;DATAI
	MAPF[TTY.DI] D[IOD] DEST[AR] JUMP[CTYDI] CYLEN[IOB-IN] $
	ILGIOT $	;BLKO
	NOP $
	FIXM1 $		;DATAO
	D[CTY-STATUS + 10] DEST[Q] JUMP[CTYDO] NORM $ ; GET CONI BITS
	D[CTY-STATUS + 10] MASK[7] DEST[Q] NORM $ ;CONO, GET CONI BITS
	D[IR] MASK[7] ROT[40] ALU[-D&Q] DEST[Q] JUMP[CTYCO] NORM $ ;CLR THE CLR BITS
	D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
		; CONI, GET BITS
	D[AR] DEST[MEMSTO] MEMST $
	D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
		;CONSZ, GET BITS
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
		;CONSO, GET CONI BITS
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
;$*$*$ We may not be able to afford this in the future...  TVR-Apr80
LPTDSP:
.REPEAT 1 - LPT [
     .REPEAT 10 [ILGIOT $
	NOP $
];.REPEAT 10
];.REPEAT 1 - LPT

.REPEAT LPT [		;Allocate space for LPT dispatch
:. + 20
];.REPEAT LPT

;AREA51 starts here.


: 2130 ;CTY and 60 HZ CLOCK INTS COME HERE

CTYINT:
  .REPEAT NTP [;With new tape controller, 60HZ clk shares DEV 4 w/ CTY.
	START-IN SHORT $
	MAPF[5] D[IOD] ALU[NOTD] DEST[AR] C600 $
		;Read the NET interface status...
	D[AR] MASK[1] C550 -OBUS=0 JUMP[CLKINT] $
		;Is 60HZ clk requesting an int. ? Jump if so.
	NORM JUMP[CTYIN1] $
		;Else it is the CTY's turn.
: 2144
      ] ;NTP

CTYIN1:	D[CTY-STATUS + 10] DEST[Q] PUSHJ[CTYCI] NORM SPEC[IOB-IN] $
		; DO A CONI, GET BITS
	D[CTY-CONT + 10] MASK[11] DEST[IOD] SPEC[IOB-OUT] NORM $; DISABLE INTS
	MAPF[TTY.WC] CYLEN[IOB-OUT] D[CTY-STATUS + 10] MASK[3] DEST[Q AR] $
		; GET PI CHAN
	NORM  DEST[CLR-DEV-FROM-INTR] JUMP[PIGEN] $;CAUSE INTR.

;$*$*$ This one is referenced off the MAP dispatch
: 5210
	.PAIR
	UIOTRP[MUUO] $
CTYIOT:	IOTDIS [CTYIOTDISP-ORGARG]

CTYDI:	D[CONST 40] ALU[-D&Q] DEST-A-MEM DEST[CTY-STATUS] NORM $; CLR TTI FLAG
	D[CONST 10] ROT[3] DEST[Q] SHORT $
	D[CTY-CONT + 10] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $;CLR RCV. CHR
	MAPF[TTY.WC]  CYLEN[IOB-OUT] $
	D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[TTY.WC] CYLEN[IOB-OUT] $
	D[AR] MASK[10] DEST[MEMSTO] MEMST $
CTYDO:	D[MEM] DEST[IOD] SPEC[IOB-OUT] NORM $;SEND CHR.
	MAPF[TTY.WD] CYLEN[IOB-OUT] D[CONST 10] ALU[-D&Q] DEST[Q] $;CLR TTO FLAG
	D[CTY-CONT + 10] ALU[D+1] DEST[IOD] SPEC[IOB-OUT] NORM $
		;ENABLE UART STB
	MAPF[TTY.WC] CYLEN[IOB-OUT]
			D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM $
		;SET TTO BUSY
	D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR UART STB
	MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST 7] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] $ ; DONE IF NO PI CHAN
	D[CTY-CONT + 10] DEST[Q] SHORT $; GET IOB-OUT BITS
	D[CONST 4] ROT[11] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ ;ENABLE XMT INT
	MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
CTYCO:	D[CONST 17] ROT[3] ALU[D&Q] DEST[Q] NORM $;CLR PI BITS
	D[IR] MASK[7] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM JUMP[CTYCO1] NORM $
		;OR IN NEW PI BITS
CTYCI:	MAPF[TTY.DI] D[IOD] DEST[HOLD] CYLEN[IOB-IN] $;GET UART BITS
	D[CTY-CONT + 10] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[TTY.WC] D[MEM] ROT[26] MASK[1] COND[-OBUS=0] JUMP[CTYCI1] CYLEN[MAX,IOB-OUT,C550] $; J IF RCV RDY
CTYCI2:	D[CONST 10] ROT[3] ALU[-D&Q] DEST[Q AR] JUMP[CTYCI9] NORM $;CLR TTI BUSY
CTYCI1:	D[CONST 40] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI2] C550 $;J IF TTI FLAG ON
	D[CONST 10] ROT[3] ALU[D#Q] DEST[Q AR] NORM $;COMPL BUSY.
	D[CONST 10] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[CTYCI9] C550 $;J IF BUSY NOW ON
	D[CONST 40] ALU[DORQ] DEST[Q AR] NORM $; SET TTI FLAG
CTYCI9:	D[MEM] ROT[25] MASK[1] COND[-OBUS=0] JUMP[CTYCI8] C550 $;J IF XMT RDY
	D[CONST 20] ALU[DORQ] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $
		;SET BUSY -- NOTE, NO "AR DEST" IS CORRECT
CTYCI8:	D[CONST 20] ALU[D&Q] COND[OBUS=0] JUMP[CTYCI3] C550 $; J IF BUSY OFF
	D[CONST 10] ALU[DORQ] DEST[Q] NORM $; SET FLAG
CTYCI3:	D[CONST 20] ALU[-D&Q] DEST[CTY-STATUS] DEST-A-MEM POPJ NORM $ ;CLR BUSY
CTYCO1:	D[IR] ROT[41] MASK[10] DEST[Q] NORM $; GET SET&CLR BITS
	D[CONST 10] ROT[3] ALU[D&Q] COND[OBUS=0] JUMP[CTYCO4] $
		; J IF CLR TTI FLAG OFF
	D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $;GET IOB-OUT BITS
	D[CONST 10] ROT[3] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $
		;GET CLR RCV RDY BIT
CTYCO3:	MAPF[TTY.WC] CYLEN[IOB-OUT] $
	ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM $;CLR IT
	MAPF[TTY.WC] CYLEN[IOB-OUT] $
CTYCO4:	D[CTY-CONT + 10] MASK[11] DEST[Q] NORM $; GET IOB-OUT BITS
	D[CTY-STATUS + 10] MASK[3] COND[OBUS=0] JUMP[CTYCO5] C550 $
		; J IF NO PI CHAN
	D[CONST 2] ROT[11] ALU[DORQ] DEST[Q] SHORT $; ENBL RCV INT
	D[CTY-STATUS + 10] ROT[41] MASK[2] COND[OBUS=0] JUMP[CTYCO5] C550 $
		; J IF NO OUT FLAG OR BUSY
	D[CONST 4] ROT[11] ALU[DORQ] DEST[Q] SHORT $;ENBL XMT INT
CTYCO5:	ALU[Q] DEST[IOD] SPEC[IOB-OUT] SHORT $; FIX INT ENBLS
	MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[Q] DEST[CTY-CONT] DEST-A-MEM JUMP[MAIN] $
; **** HERE IS DEFN. OF CTY UART CONSTANTS ****

CTYRST:	D[CONST 4] DEST[DEV-ADR] NORM $
	D[CONST 4] ROT[6] DEST[Q CLR-DEV-FROM-INTR] NORM $
	D[CONST 74] ALU[DORQ] DEST[Q CTY-CONT] DEST-A-MEM NORM $
	D[CONST 3] ROT[6] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] NORM $; RESET UART
	MAPF[TTY.WC] CYLEN[IOB-OUT] ALU[0] DEST[CTY-STATUS] DEST-A-MEM $
	ALU[Q] DEST[IOD] SPEC[IOB-OUT] NORM JUMP[CTYRS1] $
    .USE[AREA356] 	;$*$*$*$ Temporary ****
CTYRS1:
;Setup entry vectors: IOT vector in left half, interrupt vector in right half	
	MAPF[TTY.WC] CYLEN[IOB-OUT] D[CONST (CTYDSP / 100)] ROT[18. + 6.] DEST[Q] $
		;High order 6 IOT bits
	D[CONST (CTYDSP \ 100)] ROT[18.] ALU[DORQ] DEST[Q] NORM $
		;Low order 6 IOT bits
	D[CONST (CTYINT / 100)] ROT[6.] ALU[DORQ] DEST[Q] NORM $
		;High order 6 interrupt bits
	D[CONST (CTYINT \ 100)] ROT[0] ALU[DORQ]
			SPEC[DEST-A-MEM] DEST[CTY-DISP] POPJ NORM $
		;Low order 6 interrupt bits
		;Finish setting up vectors and return.

AREA52:	;$*$*$* Recover what space may be left???

;;;	.USE[AREA206]
;;;	debuguse = .

;;;:2074	;%$#@#$% SLOEXP didn't redefine AREA206 properly??? $*$*$*$

	.USE[NORMAL]

	.PAIR
CTYCZ:	D[AR] ALU[D&Q] COND[-OBUS=0] JUMP[MAIN] C550 $
	DOSKIP $
CTYCS:	D[AR] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $
	DOSKIP $




;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
;      be moved to the end of regular disk stuff.  TVR-Apr80
DSKRST:	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
	  ;SET DSK CTRL COMMAND REGISTER TO 0 (DISABLES INTS).
	MAPF[4] D[CONST 2] DEST[IOD] SPEC[IOB-OUT]
				CYLEN[IOB-OUT] $
	  ;NOW RESET THE CONTROLLER.
	MAPF[7] ALU[0] DEST[1] DEST-A-MEM  CYLEN[IOB-OUT]  POPJ $
	  ;ALSO CLEAR THE PI CHANNEL ASSIGNMENT.

SET-DSK-OUT:
	D[CONST 10] DEST[DEV-ADR] NORM COND[-USER] JUMP[SDSKO2] $
	UIOTRP[MUUO] $
		;Watch for IOT-USER mode.
SDSKO2:	D[MEM] DEST[IOD AR] SPEC[IOB-OUT] NORM POPJ $

;Kludge to allow disk controller status IOTs from IOT-USER Mode.  This is
;so a wizard can look at the state of the disk controller from MDDT (or UEDDT).
UDSKST:	UIOTRP[MUUO] $
		;Ignore SPEC[IOB-IN] we just did and trap if in user mode.
	D[IR] ROT[8 + 1 + 1] MASK[10.] DEST[Q] $
		;Extract opcode
	D[CONST 1] ALU[DORQ] DEST[Q] $
		;Skip first micro instruction that got us here
	D[CONST 2] ROT[9.] ALU[DORQ] SDISP CYLEN[DISP] SPEC[IOB-IN] $
		;Dispatch again to finish instruction

;$*$*$ This code should set up dispatch and interrupt vectors.  It will have to
;      be moved to the end of regular disk stuff.  TVR-Apr80
TYMRST:		;RESET TYMNET INTERFACE
	D[CONST 1] DEST[Q] PUSHJ[DEV6CL] NORM $
.REPEAT TYMNET [
	JUMP[TYMRS1] NORM $	;SET INITIAL COROUTINE ADR, INT ENBLS.
];TYMNET
.REPEAT 1 - tymnet [
	POPJ NORM $
]; 1 - tymnet

;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80

 .REPEAT OTP [

CLKRST:	  ;RESET 60HZ CLOCK FLAG AND DISABLE ITS INTERRUPTS.
	D[CONST 1] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
		;LOAD A MASK INTO Q AND GO TO COMMON ROUTINE.
	;FALLS IN
CLKCLR:	  ;CLEAR 60HZ CLOCK FLAG.
	D[CONST 6] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT]  ;THIS CLEARS THE FLAG.
.REPEAT 1 - KL [
	 D[10 + APRSTS] SPEC[A-MEM-APR] ROT[32] MASK[1] DEST[AR] $
		;FOR KA STYLE CONI WORD
];.REPEAT 1 - KL
.REPEAT KL [
	D[10 + APRSTS] SPEC[A-MEM-APR] ROT[13. + 1.] MASK[1] DEST[AR] $
	  ;GET THE CLOCK ENABLE FLAG IN AR35
];.REPEAT KL
	D[CONST 1] ALU[NOTD] DEST[Q] JUMP[DEV6ST] NORM $
	 ;SET OR CLEAR THE HARDWARE INTRPT. ENB. ACCORDING TO
	 ; STATE OF CLK INT ENB BIT IN APR 
  ] ;OTP

 .REPEAT NTP [

CLKRST:		;Fall in to CLKCLR
CLKCLR:	START-OUT D[CONST 4] DEST[DEV-ADR] NORM $
		;Clear clk flag.
.REPEAT 1 - KL [
CLKENB:	MAPF[7] D[10 + APRSTS] SPEC[A-MEM-APR] ROT[26.] DEST[IOD] C600 $
];.REPEAT 1 - KL
.REPEAT KL [
CLKENB:	MAPF[7] D[10 + APRSTS] SPEC[A-MEM-APR] ROT[13. + 1.] DEST [IOD] C600 $
];.REPEAT KL
	  	;GET THE APR CONDITIONS WD, PUT CLK INT ENB BIT IN BIT 35.
	START-OUT NORM $
	MAPF[6] C600 POPJ $
	 	;SET OR CLEAR THE HARDWARE INTRPT. ENB. ACCORDING TO
	 	; STATE OF CLK INT ENB BIT IN APR 
  ] ;NTP

.REPEAT OTP [  ;Tape and Timer interact only with old tape ctrl...

TAPRST:	 ;RESET THE TAPE CONTROLLER AND ASSOCIATED DEVICES.

	D[CONST 7] DEST[DEV-ADR] NORM $ ;SELECT DEVICE.
;;	ALU[0] DEST[] DEST-A-MEM NORM $
		;Set tape mode to CORE-DUMP
   .REPEAT KNYTAPE [ PUSHJ[KNYRST] $ 
			;Clear KENNEDY formatter, if any. ]

   	D[CONST 1] ROT[35.] DEST[Q] NORM $	;

   .REPEAT TIMER [  ;IF INTERVAL TIMER IS PRESENT...
	D[CONST 1] ROT[35. - 19.] ALU[DORQ] DEST[Q 1] DEST-A-MEM $
	   ;FORM DATA TO CLR TAPE ERR FF'S, ENABLE TIMER INTRPTS
     ] ;TIMER
   .REPEAT 1 - TIMER [  ;IF INTERVAL TIMER IS ABSENT...
	ALU[Q] DEST[Q 1] DEST-A-MEM $
	   ;FORM DATA TO CLR TAPE ERR FF'S, DISABLE TIMER INTRPTS
     ] ;1 - TIMER

	START-OUT D[CONST 1] ROT[35. - 6] ALU[DORQ] DEST[IOD] NORM $
	   ;DO SO;  ALSO CLEAR TIMER OVERFLOW INTRPT FLAG.
	MAPF[1] START-OUT D[CONST 1] ROT[35. - 9] DEST[Q IOD] C800 $
	   ;ALSO CLEAR ALL SIGNALS TO THE DEVICE, SET "CLOCK RUN"
	MAPF[6] ALU[Q] DEST[2] DEST-A-MEM  C800 $
	   ;RECORD THE "CLOCK RUN" BIT IN A-MEM[2]; EVERYONE WHO
	   ; LOADS THE CTL REG (MAPF[4]) SHOULD INCLUDE IT.
	D[CONST 60] ROT[35. - 15.] DEST[Q] NORM $
	D[CONST 30] ROT[35. - 21.] ALU[DORQ] DEST[Q] NORM $
	   ;ASSEMBLE -1000. AS 12-BIT NO. ENDING AT BIT 21.
	START-OUT D[CONST 41] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
	   ;THIS SETS TIMER CLOCK FOR 100 USEC TICKS, ZEROES COUNTER.
	MAPF[1] ALU[0] DEST[3] DEST-A-MEM C800 POPJ $
	   ;INIT THE TIMER REG. TO 0 AND RETURN.
   ] ;OTP

;$*$*$*$* This should be moved to CFKNYD.SLO   TVR-Sep80
  .REPEAT NTP [

TAPRST:	 ;RESET THE TAPE CONTROLLER.
	D[CONST 7] DEST[DEV-ADR] NORM $ ;SELECT DEVICE.
	START-OUT ALU[0]  DEST[IOD] $
	 ;Turn off "FORMATTER ENABLE"
	MAPF[2] LONG $
	  ;Fall in to TIMRST.

TIMRST:	D[CONST 5] DEST[DEV-ADR] NORM $
	START-OUT D[CONST TIMER] DEST[IOD] NORM $
		;Enable timer interrupts if TIMER is 1, else disable them.
	MAPF[10] ALU[0] DEST[1] DEST-A-MEM C600 $
		;Clear pi channel
	ALU[0] DEST[3] DEST-A-MEM NORM POPJ $
		;Clear timer reg.
   ] ;NTP

APRRST:
.REPEAT F2SW [
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $	;Clear Addr. Break
];REPEAT F2SW
	MAPF[1] ALU[0] DEST[APRSTS] SPEC[A-MEM-APR&DEST-A-MEM] CYLEN[IOB-OUT] POPJ $
;$*$*$ This code should set up dispatch and interrupt vectors.  TVR-Apr80

CLRDEVINT:	   DEST[CLR-DEV-FROM-INTR] POPJ NORM $
		;CLEAR FLAG WHICH CAUSES DEV-ADR TO BE
		; ADR OF LAST INTERRUPTING DEVICE,
		; SO THE DEV-ADR REGISTER WILL WORK AGAIN.




;------------------------------------------------------------------------------
;
;	PI - Priority Interrupt Service			Device 4
;
;------------------------------------------------------------------------------

;PI SYSTEM USE OF APR AMEM---
; 4	MEM PAR ERR(BIT 19), MEM PAR ERR INTRPT ENB(BIT 20),
;	 PI SYSTEM ON(BIT 28) CHN1-7 ON (BITS 29-35)
; 5	WAITING RQ 1-7 (11-18)  IN PROG 1-7 (29-35)
; 6	RQ COUNTS - 4-BIT FIELDS, CHN. 7 AT RIGHT END OF WORD.
;
;Other uses of APR AMEM are documented at the beginning 

PI-GET-CHN:	;MAKE BINARY CHN. NO. FROM MASK IN AR.
	D[AR] ROT[34] DEST[AR] NORM $
		;PUT RQ 1 INTO BIT 1
	D[CONST 6] DEST[MA] NORM $
		;MA WILL GET 7-CHN (FOR USE IN SHIFTING)
PIL1:	D[AR] ROT[1] DEST[AR] C550
	   COND[OBUS<0] JUMP[PIGETMASK] $ ;FOUND FIRST BIT ?
	D[MA] ALU[D-1] DEST[MA] NORM JUMP[PIL1] $
		;NO. DECREMENT COUNT AND LOOP.
PIGETMASK:	D[MA] DEST[ROTR] NORM $ ;LOAD ROTATE AMT.
	D[CONST 1] ROT[R] DEST[AR] NORM 
	  POPJ $	;MAKE MASK OF FIRST BIT ONLY IN AR.


PI-CHECK-RQS:	 ;SEE IF IT IS TIME TO TAKE AN INTRPT.
.REPEAT STANSW [	;Determine which PI channels should be enabled for PAN
	D[14] SPEC[A-MEM-APR] ROT[35. - 10.] DEST[Q] PUSHJ[PANIST] NORM $
		;Select only those channels turned on and readyt to interrupt
	MAPF[PAN-INT-ENB] CYLEN[IOB-OUT] 
	 D[15] SPEC[A-MEM-APR] ROT[18.] MASK[7] DEST[AR]
	 COND[OBUS=0] JUMP[MAIN] $ ;ANY RQ'S ?
];.REPEAT STANSW
.REPEAT 1 - STANSW [
	D[15] SPEC[A-MEM-APR] ROT[18.] MASK[7] DEST[AR]
	  C550 COND[OBUS=0] JUMP[MAIN] $ ;ANY RQ'S ?
];.REPEAT 1 -STANSW
	ALU[0] DEST[DEV-ADR] NORM PUSHJ[PI-GET-CHN] $
		;GET UNARY CHN NO. IN AR, SHIFT AMT. IN MA, ROTR
	D[14] ROT[34] C550 COND[-OBUS<0] JUMP[MAIN] $
		;EXIT IF PI SYS NOT ON.
	D[MASK 7] ROT[R] DEST[Q] NORM $
		;MASK OF CHN AND ALL HIGHER CHNS.
	D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[MAIN] $
		;EXIT IF THIS OR HIGHER CHN IN PROGRESS.
	D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
	D[14] ALU[D&Q] C550 COND[OBUS=0] JUMP[MAIN] $
		;EXIT IF CHN NOT ON.
	D[MA] ROT[2] DEST[ROTR] NORM $
		;GET SHIFT AMT 4 TIMES LARGER, TO ACCESS CNT FIELD
	D[CONST 1] ROT[R] DEST[Q] NORM $
		;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
	D[16] ALU[D-Q] DEST[Q HOLD] NORM $
		;DECREMENT OUR WAITING RQ COUNT.
	D[16] ALU[D#Q] DEST[Q] NORM $ ;DID WE OVERFLOW ?
	D[CONST 20] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[.] $
	  ;LOOP HERE FOREVER IF WE OVERFLOWED 4-BIT CNT FIELD
	D[MEM] DEST[6 Q] DEST-A-MEM NORM $
		;PUT BACK WORD OF RQ COUNTS.
	D[CONST 17] ROT[R] ALU[D&Q] C550
	  COND[-OBUS=0] JUMP[PIINTGO] $ ;JUMP IF OUR COUNT NEQ 0
	D[AR] ROT[18.] ALU[NOTD] DEST[Q] NORM JUMP[PIL11] $
		;MASK FOR CLEARING THE WAITING RQ BIT.
PIINTGO:	D[CONST 0] ALU[NOTD] DEST[Q] NORM $
		;DON'T CLEAR THE BIT, RQ'S STILL WAITING
PIL11:	D[15] ALU[D&Q] DEST[Q] NORM $
		;GET STATUS B, EITHER DO OR DO NOT CLEAR RQ BIT
	D[AR] ALU[DORQ] DEST[5] DEST-A-MEM NORM $
		;SET IN PROGRESS BIT, STORE STATUS B.
	D[PC] DEST[Q AR] NORM $ ;GET PC INTO Q, AR.
	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $ ;CLR USR MODE

;;;	D[MA] ROT[18.] ALU[DORQ] DEST[1] DEST-A-MEM NORM $
;;; This is an obsolete bug trap -- DWP 9/80

.REPEAT 1 - KL [
	D[CONST 56] DEST[Q] NORM $
		;PREPARE TO CALC. INTRPT. ADDRESS.
	D[MA] ROT[1] ALU[Q-D] DEST[MA] NORM JUMP[PIMUUO] $
		;FETCH INTRPT. INSTR AND GO INTERPRET IT.
];.REPEAT 1 - KL
.REPEAT KL [;KL PI VECTORS ARE RELATIVE TO THE EPT

	D[CONST 1] DEST[DEV-ADR] NORM$
		;SET TO AMEM BLOCK 1 WHERE PAGING STUFF IS
	D[17] ROT[9.] MASK[9. + 13.] DEST[Q] PUSHJ[MAPOF] NORM $
		;GET EPT ADDRESS IN Q, TURN MAP OFF.
	D[CONST 56] ALU[D+Q] DEST[Q] NORM $
		;GET EPT+56 (IF CHANNEL 7)
	D[MA] ROT[1] ALU[Q-D] DEST[HI-ABS-MA MA] NORM $
		;START INSTRUCTION IN, TURN MAP ON (HAPPENS AFTER)
	ALU[0] DEST[HI-ABS-MA] NORM JUMP[PIMUUO] $
		;CLEAR OUT HI MA PART AND GO DO THE INSTRUCTION WITH MAP ON
		; AR HAS PC BEFORE WE TURNED OFF USER.
		; WILL GET NORMAL PAGE FAULT IF IT FAULTS, THIS IS PROBLEM.
];.REPEAT KL



PIGEN:	 ;ENTER WITH CHN IN AR TO REQUEST INTRPT.
	ALU[0] DEST[DEV-ADR] NORM PUSHJ[CLRDEVINT] $
	D[14] DEST[Q] NORM $
	D[CONST 1] ROT[18.] ALU[D+Q] DEST[4] DEST-A-MEM
		NORM $
	D[CONST 7] DEST[Q] NORM $
		;7-CHN IS AMT TO SHIFT BY FOR MASK BIT.
	D[AR] MASK[3] ALU[Q-D] DEST[MA] NORM
	  PUSHJ[PIGETMASK] $ ;LOAD ROTR, FORM MASK IN AR
PIGEN1:	D[14] ROT[34] C550 COND[-OBUS<0] JUMP[PIGENWT] $
		;BRANCH IF PI SYS NOT ON.
	MASK[7] D[2] ROT[R] DEST[Q] NORM $
		;MASK OF CHN AND ALL HIGHER CHNS.
	D[15] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIGENWT] $
		;BRANCH IF THIS OR HIGHER CHN IN PROGRESS.
	D[AR] DEST[Q] NORM $ ;MOVE UNARY CHN # TO Q.
	D[14] ALU[D&Q] C550 COND[-OBUS=0] JUMP[PIINTGO] $
		;IF CHN ON, GO TAKE INTRPT.
PIGENWT:	  ;INTRPT CANNOT HAPPEN NOW, SO SET A WAITING RQ.
	D[MA] ROT[2] DEST[ROTR] NORM $
		;GET SHIFT AMT 4 TIMES LARGER, TO GET CNT FIELD
	D[CONST 1] ROT[R] DEST[Q] NORM $
		;A ONE ALIGNED WITH RQ CNT FIELD FOR THIS CHN.
	D[16] ALU[D+Q] DEST[Q HOLD] NORM $
		;INCREMENT OUR WAITING RQ COUNT.
	D[CONST 10] ROT[R] ALU[D&Q] COND[-OBUS=0] C550 JUMP[. + 2] $
	  ;DON'T LET COUNT GET HIGHER THAN 7.
	D[MEM] DEST[6] DEST-A-MEM NORM $
		;PUT BACK WORD OF RQ COUNTS.
	D[15] DEST[Q] NORM $
		;GET STATUS B.
	D[AR] ROT[18.] ALU[DORQ] DEST[5] DEST-A-MEM
	   NORM JUMP[UINT-DISMISS] $ ;SET WAITING RQ BIT.
			;NOTE THAT WE CAN BE HERE FROM CONO PI ALSO, SO THAT
			;MICROINTERRUPTDISMISS ISN'T EXACTLY RIGHT, BUT
			; IN THAT CASE NO TRAP FLAGS ARE SET
PI-DISMISS:
	D[15] SPEC[A-MEM-APR] MASK[7] DEST[AR]
	  C550 COND[-OBUS=0] PUSHJ[PI-GET-CHN] $
	D[15] SPEC[A-MEM-APR] DEST[Q] NORM $
	D[AR] ALU[-D&Q] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM]
		NORM JUMP[PI-CHECK-RQS] $



PICONO:  ;Here from any CONO PI,
	D[MA] MASK[7]  DEST[AR] NORM $
	ALU[0] DEST[DEV-ADR] NORM $
	D[14]  DEST[Q] NORM $ ;GET STATUS A
.REPEAT 1 - KL [;ONLY KA STYLE HAS APR STUFF IN CONO PI
	D[MA] ROT[21.]  C550 COND[-OBUS<0] JUMP[PIL7] $
	D[CONST 1] ROT[35. - 20.] ALU[DORQ] DEST[Q] NORM $ 
	 ; TURN ON PAR ERR INTRPT ENB.
PIL7:	D[MA] ROT[20.]  C550 COND[-OBUS<0] JUMP[PIL8] $
	D[CONST 1] ROT[35. - 20.] ALU[-D&Q] DEST[Q] NORM $ 
	 ;TURN OFF PAR ERR INT ENB
PIL8:	D[MA] ROT[19.] C550 COND[-OBUS<0] JUMP[PIL9] $
	D[CONST 1] ROT[35. - 19.] ALU[-D&Q] DEST[Q] NORM $ 
	 ;CLEAR MEM PAR ERR FLAG
];.REPEAT 1 - KL
PIL9:	D[MA] ROT[5]  C550 COND[OBUS18] PUSHJ[PI-RESET] $
	D[MA] ROT[12]  C550 COND[-OBUS18] JUMP[PIL3] $
	D[CONST 1] ROT[7] ALU[DORQ] DEST[Q] NORM $ ; PI ON
PIL3:	D[MA] ROT[11]  C550 COND[-OBUS18] JUMP[PIL4] $
	D[CONST 1] ROT[7] ALU[-D&Q] DEST[Q] NORM $ ; PI OFF
PIL4:	D[MA] ROT[7]  C550 COND[-OBUS18] JUMP[PIL5] $
	D[AR] ALU[DORQ] DEST[Q] NORM $ ; CHNS ON
PIL5:	D[MA] ROT[10]  C550 COND[-OBUS18] JUMP[PIL6] $
	D[AR] ALU[-D&Q] DEST[Q] NORM $ ; CHNS OFF
PIL6:	ALU[Q] DEST[4] DEST-A-MEM NORM $
	D[MA] ROT[6]  C550 COND[-OBUS18] JUMP[PI-CHECK-RQS] $
	D[AR] MASK[7] ALU[0-D] DEST[Q] NORM $
		;GENERATED INTRPTS REQUESTED. CHECK TO
		; MAKE SURE ONLY ONE CHN IS SPECIFIED.
	D[AR] MASK[7] ALU[D&Q] DEST[Q] NORM $
	D[AR] MASK[7] ALU[D-Q] C600
	  COND[-OBUS=0] JUMP[.] $ ;HANG HERE IF MORE THAN ONE.
	D[AR] MASK[7]  DEST[AR] NORM PUSHJ[PI-GET-CHN] $
		;GET BINARY CHN. NUMBER AND UNARY MASK.
	NORM JUMP[PIGEN1] $ ;GO GENERATE REQUEST.


PICONISUB:
	D[14] SPEC[A-MEM-APR] MASK[18.] DEST[Q] NORM $
	  ;GET SYS ON AND CHN ON BITS.
	D[15] SPEC[A-MEM-APR] MASK[10] DEST[AR] NORM $
	  ;GET PI IN PROG BITS
	D[AR] ROT[10] ALU[DORQ] DEST[AR Q] NORM $
	D[15] SPEC[A-MEM-APR] ROT[18.] MASK[10] DEST[AR] NORM $
	  ;GET WAITING RQ BITS, AND RETURN IN LEFT HALF.
	D[AR] ROT[18.] ALU[DORQ] DEST[AR Q] NORM POPJ $

PI-RESET:
	ALU[0] DEST[4] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	ALU[0] DEST[5] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	ALU[0] DEST[6 Q] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $

;;;	ALU[0] DEST[1] SPEC[A-MEM-APR&DEST-A-MEM] NORM POPJ $
;;; This is an obsolete bug trap -- DWP 9/80

END-OF-PI-CODE:



;; MBOOT MOVED TO PAGE WITH REST OF TAPE STUFF




;MAPIOT MAPIO1 MAPCO0 MAPCOB MAPCOC MFT1 MFT1A MFT1D MFRD MFOTH MBLT3 SETHLF QORCRY SETHFU BWRTA1 MBLT2 MAPCWT MAPCW1 MAPCW2
.REPEAT 1 - KL [
;------------------------------------------------------------------------------
;
; 	BBN Pager - Map CONO Dispatch Table
;
;*** What these things do should documented here.  It's hard enough to find it
;*** elsewhere!  TVR-Apr80
;
;	This code is all BBN dependent.  It will be replaced for other pagers.
;
;------------------------------------------------------------------------------

	.ORG[BBNMAPIOTDISP-ORG]	;$*$*$ This should be fixed

	JUMP[MAPCO0] NORM $		  ;CONO 0
	DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 1 -- START MAP CLEARING
	UAOP1 $				  ;CONO 2 -- Ill. Instruction
	DEST[CLR-MAP] JUMP[MAPCO1] NORM $ ;CONO 3 -- START MAP CLR
	D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 4
	D[CONST 1] DEST[DEV-ADR] JUMP[MAPCO4] NORM $; CONO 5
	JUMP[MAPCO6] NORM $		  ;CONO 6
	DEST[CLR-MAP] JUMP[MAPCO7] NORM $ ;CONO 7

	.USE[AREA51]
			;$*$*$	This is truely silly.  The CTY code appears
			;	after the map dispatch and the map code
			;	after the CTY dispatch!
	.PAIR
	UIOTRP[MUUO] $
MAPIOT:	D[IR] ROT[9.] COND[-OBUS<0] JUMP[MAIN] C550 $ ;NOP IF DEV. 20
	D[CONST 14] ALU[D#Q] COND[OBUS=0] JUMP[MAPIO1] C550 $; IS IT CONO ?
	D[CONST 13] ALU[D#Q] COND[OBUS=0] JUMP[MAPDO] C550 $; NO IS IT DATAO?
	ILGIOT $   ;ELSE ILLEGAL
MAPIO1:	D[IR] MASK[3] DEST[Q] NORM $
	D[BBNMAPIOTDISP-ORG / 100] ROT[6] ALU[DORQ] SDISP C600 $
MAPCO0:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $
	D[12] DEST[Q] NORM $; GET SIGN BIT = ENBL FOR EXEC 0-77777
	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] CYLEN[IOB-OUT] DEST[CLR-MAP] D[CONST 20] LLOAD $; TURN OFF MAPPING & START CLEARING MAP
	LOOP [.] C550 $  ;WAIT FOR MAP CLR TO FINISH -- OTHERWISE THE
	  	; READS OF 71 AND 72 BELOW DON'T HAPPEN (ON F2 #1).
	D[CONST 71] DEST[MA] SHORT $; FETCH MAGIC LOC
	D[CONST 1] DEST[DEV-ADR] CYLEN[FIXM]  $; WAIT FOR DATA
	D[MEM] MASK[13] DEST[AR] SHORT $
	D[AR] ROT[11] DEST-A-MEM DEST[4] NORM $; MBR
	D[MEM] ROT[18.] MASK[13] DEST[AR] SHORT $
	D[AR] ROT[11] DEST-A-MEM DEST[1] NORM $; UBR
.REPEAT 1 - WAITS [
	D[MEM] ROT[27] MASK[5] DEST[AR] SHORT $
	D[AR] ROT[4] DEST-A-MEM DEST[3] NORM $; AC BASE REG
];.REPEAT 1 - WAITS
	D[MEM] ROT[7] MASK[3] ALU[0-D] DEST[AR] COND[OBUS=0] JUMP[MAPCOB] C600 $; ADDRS LIMIT, J IF 0
	D[AR] MASK[3] DEST[AR] SHORT $
	D[AR] ROT[16] DEST[AR] JUMP[MAPCOC] NORM $; FORM SMALLEST ILLEGAL ADDRESS
MAPCOB:	D[CONST 20] ROT[16] DEST[AR] SHORT $
MAPCOC:	D[CONST 1] ROT[43] ALU[D&Q] DEST[Q] SHORT $; GET SIGN BIT = ENBL FOR EXEC 0-77777
	D[AR] ALU[DORQ] DEST-A-MEM DEST[AR 2] NORM $; ADDRS LIMIT
.REPEAT WAITS [
	D[11] DEST[HI-ABS-MA MA] SHORT $
		;Fetch first location of user page table
	D[MEM] MASK[13] DEST[3] DEST-A-MEM LONG $
		;Wait for memory to finish, then save page table entry.
];.REPEAT WAITS
	D[CONST 72] DEST[MA] SHORT $; GET NEXT WORD
	D[MEM] DEST[Q] LONG $	;LONG to wait for data to arrive.
	D[CONST 1] ROT[32] ALU[-D&Q] DEST-A-MEM DEST[5] JUMP[MAPCOE] NORM $; AGE & PROCESS BITS
];.REPEAT 1 - KL



.REPEAT KL [
;------------------------------------------------------------------------------
;
; 	KL Pager - Map IOTS
;						-PG
;
;	This code is all KL dependent.  It will be replaced for other pagers.
;
;------------------------------------------------------------------------------
	.USE[AREA51]
			;$*$*$	This is truely silly.  The CTY code appears
			;	after the map dispatch and the map code
			;	after the CTY dispatch!
;AMEM USAGE FOR KL PAGER:
;	0	SWITCH INTERRUPT ADDRESS (MAP CODE CANT USE)
;	1	FREE
;	2	FREE
;	3,4,5	TEMP STORAGE
;	6	DATAO PAG WORD
;	7	CONO PAG WORD

	.PAIR
	UIOTRP[MUUO] $		;DEC DEV 10 (FOONLY DEV 1)
MAPIOT:	D[CONST 4] ALU[D#Q] COND[OBUS=0] JUMP[MAPCO] C550 $;CONO ?
	D[CONST 5] ALU[D#Q] COND[OBUS=0] JUMP[MAPCI] C550 $;CONI ?
	D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[MAPDO] C550 $;DATAO?
	D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[MAPDI] C550 $;DATAI?
	D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[CLRPT] C550 $;CLRPT?
	ILGIOT $   ;ELSE ILLEGAL
MAPCO:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[IR] MASK[18.] DEST-A-MEM DEST[7 AR] NORM $
	DEST[CLR-MAP] D[CONST 20] LLOAD NORM $
	LOOP[.] C550 $			;WAIT FOR MAP CLEAR TO FINISH
	D[AR] ROT[22.] COND[OBUS<0] PUSHJ[MAPUP] C550$ ;MAP ON IF ENABLED
	D[AR] ROT[22.] COND[-OBUS<0] PUSHJ[MAPDN] C550$ ;MAP OFF IF NOT
	JUMP[MAIN] $
MAPCI:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[17] DEST[HOLD] NORM $		;A-MEM 7
	ALU[0] DEST[DEV-ADR] NORM $
	STRT-WRT MEMST $
MAPDO:	FIXM1 $ ;WAIT FOR MEMORY, HANDLE PAGE FAULTS, AND FIXUP AC REFERENCES
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[MEM] DEST-A-MEM DEST[5] NORM $ ;SAVE DATAO'S (E) IN A-MEM 5
	D[15] COND[OBUS<0] PUSHJ[MAPDO1] C550 $ ;SELECT AC BLOCKS?
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[15] ROT[2] COND[OBUS<0] PUSHJ[MAPDO2] C550 $ ;LOAD USER BASE ADDRESS?
	ALU[0] DEST[DEV-ADR] JUMP[MAIN] NORM $ ;DONE
MAPDI:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[16] DEST[HOLD] NORM $		;A-MEM 6
	ALU[0] DEST[DEV-ADR] NORM $
	STRT-WRT MEMST $
CLRPT:
.REPEAT 1 - NEWMAP [
	D[CONST 1] ROT[35. - 9.] DEST[STO-MAP] JUMP[MAIN] NORM $
		;Set mapping to zero, Invalid
];.REPEAT 1 - NEWMAP
.REPEAT NEWMAP [
	START-OUT $
		;Set mapping to zero, Invalid
	MAPF[2] D[CONST 1] ROT[35. - 9.] JUMP[MAIN] C800 $
];.REPEAT NEWMAP
];.REPEAT KL




;------------------------------------------------------------------------------
;
;	MAP FAULT DISPATCHES COME HERE (6100 + MAPF*4 )
;
;	MAP traps happen on next micro instruction after a MEMSTO or STRT-WRT.
;	They also happen after micro instruction containing a DEST[FIXMAC...],
;	as in FIXM1 for example.  The trap happens by forcing an unconditional
;	jump to an address determined by MAP-DISP register and the MAPF of
;	field of the failing micro instruction.  Otherwise, that micro
;	instruction is executed normally.
;	
;	This code should be the same for all kinds of maps.  However, it will
;	be necessary to define symbolically the trap code, i.e. the thing that
;	is usually being loaded left half of Q.  After doing that, and updating
;	necessary state of PC and flags, the code leave by jumping to MFT1B,
;	the map dependent page fault/page fill code, with fault code in Q and
;	failing address in the MA.
;
; ***	As you will notice, there are NO spare trap codes.  If you need one,
; ***	talk to me about a scheme for fixing this and improving page fault
; ***	recovery.  TVR-Apr80
;
;------------------------------------------------------------------------------
	.MAPORG[0]	;Fixed by hardware to xx100
	JUMP[.] $  	;ILLEGAL MAP FAULT -- MICROCODE BUG IF YOU GET HERE
.REPEAT XUCODE [
.XMAPORG[0]		;COPY FOR HIGH MEM
	JUMP[MAPTRAP-ORG] $
];.REPEAT XUCODE
	;**** Consider looking at STOP switch in the future.	TVR - Mar80
	;
	;To find out non-destructively how you lost, start at 2003 (on an F2)
	;you will be stopped at PC+1, assuming you lose trying to display
	;that instruction in the lights (i.e. (PC) not mapped in)
	;
	;You can get here by examining/depositing a location in the
	;hardware map (i.e. it may only be asking for a page-fill cycle).
.MAPORG[1]	;EXECUTE (&INDIRECT) FAULTS HERE
MFT1:	D[CONST 2] ROT[18.] DEST[Q] NORM $; CODE FOR EXECUTE
MFT1A:	D[CONST 1] DEST[DEV-ADR] NORM $
MFT1D:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD] MASK[3] DEST[AR IR-ADR] JUMP[MFT1B] MAPF[4] CYLEN[IOB-IN] $
.MAPORG[2]	;NORMAL READ FAULT
MFRD:	D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
MFOTH:	D[PC] ALU[D-1] DEST[PC] JUMP[MFT1A] NORM $
.REPEAT XUCODE [
.XMAPORG[2]	;NORMAL READ FAULT -HIGH MEM DUPLICATE INSTR.
	D[CONST 10] ROT[18.] DEST[Q] NORM $;CODE FOR RD
];.REPEAT XUCODE
.MAPORG[3]	;RMW HERE, DECREMENTS PC
MFWRT:	D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
.REPEAT XUCODE [
.XMAPORG[3]	;RMW -HIGH MEM DUPLICATE INSTR.
	D[CONST 14] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $
];.REPEAT XUCODE
.MAPORG[4]		;WRITES (NORMAL) HERE (BBN: NO DECREMENT PC)
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $
.REPEAT 1 - KL [
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST-A-MEM DEST[7] NORM $;SAVE STORE DATA
	D[IR] MASK[18.] DEST[MA] NORM JUMP[MFT1D] $; RESTORE MA
];.REPEAT 1 - KL
.REPEAT KL [
	D[IR] MASK[18.] DEST[MA] NORM JUMP[MFOTH] $; RESTORE MA
];.REPEAT KL
.REPEAT XUCODE * VID [
.XMAPORG[5]	; 5-- BLT-RD IN HIGH MEM (DPY-RD)
;;;	JUMP[DPYRD] NORM $
];XUCODE * VID
.MAPORG[5]		; 5-- BLT-RD
	D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC] NORM $; RESTORE PC & DEST ADR
	D[CONST 10] ROT[18.] DEST[Q] SHORT $; CODE FOR RD
MBLT3:	D[AR] ROT[18.] SPEC[LEFT] ALU[DORAC] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; GET SRC ADR
.REPEAT XUCODE * VID [
.XMAPORG[6]	; 6-- BLT-WRT IN HIGH MEM (DPY-WRT)
;;;	JUMP[DPYWRT] NORM $
];XUCODE * VID
.MAPORG[6]	;6-- BLT-WRT
	D[PC] MASK[18.] ACSEL[AC] DEST[O_AC PC MA] SPEC[MA_PC] NORM $; RESTORE PC, GET DEST ADR
	ALU[Q-1] DEST[AR] NORM $;  ADJUST SRC ADR
	D[CONST 4] ROT[18.] DEST[Q] JUMP[MBLT3] NORM $; CODE FOR WRT
.MAPORG[7]	;7-- BLT-RDA
	ACSEL[AC] D[AR] DEST[AC] NORM $; NEW DEST ADR
	D[CONST 10] ROT[18.] DEST[Q] JUMP[MFOTH] NORM $; CODE FOR RD
.MAPORG[10]	; 10-- BLT-WRTA
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
	D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
	D[AR] MASK[18.] ALU[D#Q] COND[OBUS=0] JUMP[MBLT2] C550 $
	ALU[Q-1] DEST[Q MA] JUMP[MBLT2] NORM $; CORRECT MA
.MAPORG[11]	;11-- BYTE-ILD
	PUSHJ[SETFPD] NORM $; SET HALF
	JUMP[6110] NORM $; NORMAL READ
;Page fault in the middle of a interruptable instruction.  Set HALF (BIS)
;flag as part of page fault processing so that instruction gets restarts in
;the proper way.
.REPEAT 1 - KL [;IF NOT KL, SETFPD SHOULD JUST BE SETHLF
SETFPD:
];.REPEAT 1 - KL
SETHLF:	D[CONST 2] ROT[36] DEST[Q] COND[USER] JUMP[SETHFU] NORM $;BIT 4--HALF
		;Get ready to set HALF (BIS) flag.
		;Watch for special case of User page fault from Exec. TVR-May80
QORCRY:	D[PC] ALU[DORQ] DEST[CRYOV] POPJ NORM $;SET HALF
.MAPORG[12]	;12 -- BYTE-IDP
	PUSHJ[SETFPD] NORM $; SET HALF
	JUMP[6114] NORM $;NORMAL RMW
;When a DEST[CRYOV] is done, the EXEC shift register is cleared (set) to
;whatever the user bit in the new CRYOV is.  This destroys the information
;about which space a page fault came from on XCTR (XCT mapped) instruction.
;We turn it on explicitly here.  Note that since a user cannot do a XCTR,
;we only have to worry about the case of being in EXEC mode and getting a
;user mode page fault.	TVR-May80
SETHFU:	D[PC] ALU[DORQ] DEST[CRYOV] NORM $
		;Set the half flag.
		;Don't return yet, we need to reset EXEC-SR
	SET-TEMP-USER POPJ $
		;Remember that the page fault was from a user page!!
.MAPORG[13]	;13 -- BYTE-IND
	PUSHJ[SETFPD] NORM $; SET HALF
	JUMP[6104] NORM $; NORMAL INDIRECT
.MAPORG[14]	;BLT-WRTB -- XCT MAPPED BLT STORES
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; CODE FOR WRT
	D[MA] MASK[18.] DEST[Q] PUSHJ[BWRTA1] NORM $; GET MA, SAVE STORE DAT
	D[CONST 4] ROT[18.] DEST[Q] NORM $
	D[AR] ACSEL[AC] DEST[AC] JUMP[MFOTH] NORM $; RESTORE AC


.REPEAT 1 - KL [
.MAPORG[15]	;-- MAPFTR -- TRAP WHILE FETCHING JSYS TARGET
	D[CONST 50] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] NORM $; PI CODE
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST-A-MEM DEST[7] JUMP[MFOTH] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
.MAPORG[15]	;-- KLIFETCH -- NEXT INSTRUCTION FETCH IN KL PAGING

	D[PC] COND[OBUS<0] C550 JUMP[SOEDOV] $
		;IF REAL OVERFLOW BIT IS SET,
		;CAUSE A TRAP 1 TO HAPPEN, FORGET THE PAGE FAIL.
		;BECAUSE WHAT HAPPENED WAS LAST INSTRUCTION CAUSED OVERFLOW,
		;BUT INSTRUCTION FETCH FOR NEXT INST PAGE FAILED BEFORE
		;DISPATCH AT MAIN2 COULD LET SOEDOV DO THE TRAPS.
	D[12] SPEC[A-MEM-APR] MASK[36. - 3.] DEST[AR] COND[-HALF] JUMP[MFT1] $
		;IF HALF FLAG OFF, DON'T NEED TO CLEAR ANYTHING
	D[AR] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] JUMP[KLIFT1] NORM $
		;STORE BITS BACK (JRSTT, TI1 AND TI2 CLEARED NOW)
	.USE[NORMAL]
KLIFT1:	D[AR] ROT[3] COND[OBUS<0] C550 JUMP[MFT1] $
		;IF FPD ON IN AMEM, LEAVE HALF FLAG SET.
	SPEC[CLR-HALF] JUMP[MFT1] SHORT $
		;ITS NOT, HALF WAS ONLY ON FOR OTHER FLAGS, CLEAR IT AND DO
		; WHAT IS NORMALLY DONE FOR INSTRUCTION FETCH FAULT OR INDIRECT.

];.REPEAT KL
.REPEAT 1 - KL [
.MAPORG[16]	;PPOP-- 16 -- POP & POPJ FETCH- RE-INCR PDL PNTR -- THEN LIKE READ FAULT
	D[CONST 1,,1] ACSEL[AC] ALU[D+AC] DEST[AC] JUMP[MFRD] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
.MAPORG[16]		;PPOP-- 16 -- ALL STACK OPERATIONS
	D[IR] ROT[9 - 2] COND[OBUS<0] JUMP[MFPP1] C550 $
	D[CONST 1,,1] ALU[AC-D] DEST[AC] JUMP[MFWRT] NORM $	;PUSH, PUSHJ WRT
MFPP1:	D[IR] ROT[9 - 1] COND[OBUS<0] JUMP[MFPP2] C550 $
	D[IR] MASK[18.] DEST[Q] JUMP[MFPP3] NORM $
];.REPEAT KL
.MAPORG[17]	;17-- WRITES WITH RELEVANT ADRS IN MA (BBN: NO DECR PC)
.REPEAT 1 - KL [
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] JUMP[MFNPC1] NORM $
	.USE[OTHER]
MFNPC1:	D[CONST 1] DEST[DEV-ADR] SHORT $
	D[MEM] DEST-A-MEM DEST[7] JUMP[MFT1D] NORM $;SAVE STORE DATA
];.REPEAT 1 - KL
.REPEAT KL [
	D[CONST 4] ROT[18.] DEST[Q CLR-DEV-FROM-INTR] JUMP[MFOTH] NORM $
	.USE[AREA53]
];.REPEAT KL
MFPP3:	D[MA] ALU[D#Q] COND[-OBUS=0] JUMP[MFPP2] C550 $
	D[CONST 1,,1] ALU[AC+D] DEST[AC] JUMP[MFWRT] NORM $	;POP WRT
MFPP2:	D[CONST 1,,1] ALU[AC+D] DEST[AC] JUMP[MFRD] NORM $	;POP, POPJ RD
BWRTA1:
.REPEAT 1 - KL [
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[MEM] DEST-A-MEM DEST[7] POPJ NORM $
];.REPEAT 1 - KL
.REPEAT KL [
	D[CONST 1,,1] ACSEL[AC] ALU[AC-D] DEST[AC] POPJ NORM $
];.REPEAT KL
MBLT2:	D[AR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $; COUNT HOW MANY WORDS MOVED
	D[AR] ROT[18.] ALU[Q+D] DEST[AR] SHORT $;FORM NEW SRC
	ACSEL[AC] D[MA] MASK[18.] DEST[AC] SHORT $;NEW DEST
	D[CONST 4] ROT[18.] DEST[Q] NORM $
	D[AR] ACSEL[AC] ROT[18.] SPEC[LEFT] ALU[DORAC] DEST[AC] JUMP[MFOTH] NORM $; OR IN NEW SRC



.REPEAT 1 - KL [
	.USE[AREA53]

MAPCWT:	ALU[Q] LLOAD NORM $
	LOOP[.] CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
	MAPF[10] D[AR] COND[OBUS<0] JUMP[MAPCW9] CYLEN[MAX,IOB-OUT,C550] $; J IF WHOLE MAP ON (INCLUDING EXEC 0-77777)- DONE
MAPCW1:	D[CONST 77]  MAPF[10] LLOAD NORM $
MAPCW2:	D[PC]  DEST[AR] SHORT $;SAVE FLAGS
	ALU[0] DEST[MA CRYOV] SHORT $;INIT MA, SET EXEC
	D[CONST 10] ROT[6]  DEST[Q] SHORT $

 .REPEAT NEWMAP [
	D[CONST 1] DEST[DEV-ADR] NORM $	; -- FOR WRITING MAP
	SPEC[IOB-OUT] SHORT $ 	;SET FIRST PART OF 
	  	; EXEC MAP TO POINT TO "NULL MAP" LOCS(UNMAPPED)
 	MAPF[2] D[MA] MASK[18.] C800 $	;MAP DATA COMES FROM OBUS.
	D[MA] ALU[D+Q] DEST[MA] LOOP[. - 2] NORM $;LOOP
   ]	; NEWMAP

 .REPEAT 1 - NEWMAP [
	D[MA] MASK[18.] DEST[STO-MAP] NORM $
	;SET FIRST PART OF EXEC MAP TO POINT TO "NULL MAP" LOCS(UNMAPPED)
	D[MA] ALU[D+Q] DEST[MA] LOOP[. - 1] NORM $;LOOP
  ]	; 1 - NEWMAP

	D[IR] MASK[3]  DEST[IOD] SPEC[IOB-OUT] SHORT $; RESTORE MAP
	D[AR]  DEST[CRYOV] JUMP[MAIN] MAPF[10] CYLEN[IOB-OUT] $; RESTORE FLAGS, DONE
];.REPEAT 1 - KL
;------------------------------------------------------------------------------
;	End map trap code which is common to all maps.
;------------------------------------------------------------------------------



;MAPCOA MAPCOE MAPCO1 MAPCOG MAPCO4 MPOFF1 MAPOFF MAPCO6 MAPCO7 MAPCW9 MAPDO MFUS MFA3 MFA7 MFA6 MFA4 MFT1B MFHIEX MFA1 MFA2 MFB3 MFTYP1 MFTYP0
.REPEAT 1 - KL [
;------------------------------------------------------------------------------
;	BBN MAP CONO, continued
;
;	This code will need to be rewritten for another kind of map.
;
;------------------------------------------------------------------------------
MAPCOA:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD]  MASK[3] DEST[IR-ADR] MAPF[4] POPJ CYLEN[IOB-IN] $;GET MAP, ECC & OV ENBL BITS
MAPCOE:	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE MAP STATE
	MAPF[10] D[CONST 1] DEST[Q] JUMP[MAPCWT] CYLEN[IOB-OUT] $
MAPCO1:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET ENABLE BITS IN IR
	D[12] DEST[AR] NORM $; GET SIGN BIT = ENBL EXEC 0-77777
	ALU[0] DEST[DEV-ADR] SHORT $
	D[CONST 5] DEST[Q] JUMP[MAPCWT] NORM $
MAPCOG:	D[CONST 1] DEST[DEV-ADR] NORM $
	D[12] MASK[43] DEST[Q] NORM $
	D[IR] MASK[1] DEST[AR] SHORT $;GET LOW BIT OF CONO
	D[AR] ROT[43] ALU[DORQ] DEST-A-MEM DEST[2] NORM $;GET SIGN BIT = EXEC 0-77777 MAP ENBL
	SPEC[IOB-IN] SHORT $
	MAPF[4] D[IOD] MASK[3] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[CONST 4] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] SHORT $
	D[CONST 4] ALU[DORQ] DEST[IR-ADR] MAPF[10] POPJ CYLEN[IOB-OUT] $;TURN ON MAP
MAPCO4:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
	MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $; DONE
];.REPEAT 1 - KL

MAPOFF:	D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM POPJ $
.REPEAT 1 - KL [

MAPCO6:	DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] NORM $
	JUMP[MAPCW1] NORM $
MAPCO7:	DEST[CLR-DEV-FROM-INTR] PUSHJ[MAPCOG] CYLEN[LONG] $
	CYLEN[LONG] $; WAIT FOR MAP TO CLEAR
	CYLEN[LONG] $
MAPCW9:	ALU[0] LLOAD NORM $; SET UP ONLY PAGE 0
	JUMP[MAPCW2] NORM $

;------------------------------------------------------------------------------
;DATAO CLEARS THE "ASSOCIATIVE" REGISTER MAPPING THE ADDRESS OF THE DATAO
; THIS REPLACES CONO 2.
;------------------------------------------------------------------------------
MAPDO:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPCOA] NORM $;GET MAP BITS
 .REPEAT 1 - NEWMAP [ ALU[0] DEST[DEV-ADR] NORM $ ]
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $;TURN ON MAP
	MAPF[10] CYLEN[IOB-OUT] $
 .REPEAT NEWMAP [
	SPEC[IOB-OUT] SHORT $  ;REQUEST MAP WRITE CYCLE.
	MAPF[2] D[CONST 1] ROT[32] C800 $ ]

 .REPEAT 1 - NEWMAP [
	D[CONST 1] ROT[32] DEST[STO-MAP] NORM $ ]
	  ;CLR MAP ENTRY ASSOCIATED WITH MA
	D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] C800 $; RESTORE ENABLES
	MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $
];.REPEAT 1 - KL




.REPEAT KL [
;------------------------------------------------------------------------------
;	KL PAGER - CONT
;	AC BLOCK SWITCHING, USER BASE REGISTER, AND MAP INSTRUCTION
;							-PG
;------------------------------------------------------------------------------
MAPDO3:	D[17] ROT[9.] MASK[9. + 13.] DEST[Q] PUSHJ[MAPOF] $ ;EXEC BASE ADDRESS
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[CONST 37] ALU[DORQ] DEST[MA HI-ABS-MA] NORM $	;+37=AC BLOCK PTR
	D[16] ROT[9.] MASK[3] DEST[AR] NORM $		;GET "CURRENT AC BLOCK"
	D[AR] ROT[4] DEST[Q] PUSHJ[MAPON] $		;*16.
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[MEM] MASK[18.] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $ ;+AC BLOCK PTR->MA
	D[CONST 20] DEST[AR] $				;LOOP COUNT
	ALU[0] DEST[AC-SEL] POPJ NORM $			;START AT AC 0
MAPDO1:	PUSHJ[MAPDO3] $ ;SET UP MA AND AC FOR BLT'ING AC BLOCKS
MAPDO4:	ACSEL[REG] ALU[AC] DEST[MEMSTO] NORM $	;AC->@OLD "CURRENT AC BLOCK"
	MAPF[NORM-WRT] D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] NORM $ ;INC MA AND AC-CTR
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[MAPDO4] C600$ ;LOOP
	D[15] SPEC[LEFT] DEST[Q] NORM $ 		;GET CURRENT AC BLOCK
	D[16] MASK[18.] ALU[DORQ] DEST[Q] NORM $	;MASK AND REPLACE
	ALU[Q] DEST-A-MEM DEST[6] PUSHJ[MAPDO3] NORM $	;SET UP MA AND AC
MAPDO5:	D[MEM] ACSEL[REG] DEST[AC] NORM $	;@NEW "CURRENT AC BLOCK"->AC
	D[MA] ALU[D+1] DEST[MA A-MEM-CNTR&INC] NORM $	;INC MA AND AC-CTR
	D[AR] ALU[D-1] DEST[AR] COND[-OBUS=0] JUMP[MAPDO5] C600$ ;LOOP
	POPJ NORM $
MAPDO2:	D[15] MASK[18.] DEST[Q] NORM $ ;LOAD USER BASE REGISTER
	D[16] SPEC[LEFT] ALU[DORQ] DEST[Q] NORM $
	ALU[Q] DEST-A-MEM DEST[6] NORM $
	DEST[CLR-MAP] D[CONST 20] LLOAD NORM $
	LOOP[.] C550 $			;WAIT FOR MAP TO CLEAR
	POPJ NORM $
MAP:	COND[MA-AC] JUMP[MAP2] $
	D[CONST 1] DEST[DEV-ADR] $
	SPEC[IOB-IN] NORM $
	MAPF[4] D[IOD] ROT[33.] COND[OBUS<0] JUMP[MAP1] C600 $
	ALU[0] DEST[DEV-ADR] $
MAP2:	D[MA] MASK[18.] DEST[AC] JUMP[MAIN] $		;MAP OFF
MAP1:	PUSHJ[MFPHYS] $					;PHYSICAL PAGE & BITS
	ALU[Q] DEST[AC] JUMP[MAIN] $			;DONE
;------------------------------------------------------------------------------
;	KL MAP - Handle map trap and page fill cycles.
;	This code will need to be rewritten for another kind of map. -PG
;------------------------------------------------------------------------------
MFPHYS:	D[MA] DEST[AR] PUSHJ[MAPOF] NORM $	;SAVE MA IN AR
	D[CONST 1] DEST[DEV-ADR] $
	D[AR] ROT[36. - 10.] MASK[8] DEST[Q] $	;PAGE/2
	COND[-USER] JUMP[MFPHEX] NORM $
	D[16] MASK[13.] DEST[MA] NORM $
		;GET EPT PAGE NUMBER
	D[MA] ROT[9.] ALU[DORQ] DEST[HI-ABS-MA MA] JUMP[MFPH1] NORM $
		;EPT ADDRESS + OFFSET
MFPHEX:	D[CONST 1] ROT[7] ALU[Q-D] COND[-OBUS<0] JUMP[MFPHE1] C600 $
	D[CONST 34] ROT[2] ALU[Q-D] COND[OBUS<0] JUMP[MFPHE2] C600 $
	SET-TEMP-USER $				;EXEC 340-377 (@ USER 400)
	D[CONST 34] ROT[2] ALU[Q-D] DEST[Q] $
	D[CONST 4] ROT[6] ALU[Q+D] DEST[Q] $
	D[16] MASK[13.] DEST[MA] NORM $
		;GET EPT PAGE NUMBER
	D[MA] ROT[9.] ALU[DORQ] DEST[HI-ABS-MA MA] NORM $
		;EPT ADDRESS + OFFSET
	SET-TEMP-EXEC JUMP[MFPH1] $		;DONE EXEC 340-377
MFPHE2:	D[CONST 6] ROT[6] ALU[Q+D] DEST[Q] $	;EXEC 000-337 (@ EXEC 600)
MFPHE1:	D[17] ROT[9] MASK[9 + 13.] ALU[DORQ] DEST[MA HI-ABS-MA] $
MFPH1:	D[AR] ROT[36. - 9] MASK[1] COND[-OBUS=0] JUMP[. + 2] C600 $
	D[MEM] ROT[18.] MASK[18.] DEST[HOLD] JUMP[. + 2] $	;EVEN
	D[MEM] MASK[18.] DEST[HOLD] $				;ODD
	D[MEM] ROT[9] DEST[Q] $
	D[AR] MASK[9] ALU[DORQ] DEST[HOLD] NORM $	;PHYS ADDR (BITS ROT 9)
	D[MEM] MASK[22.] DEST[Q] NORM $			;START FILLING Q
	D[MEM] ROT[9] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 2] ALU[DORQ] DEST[Q] $	;A
	D[MEM] ROT[1] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 6] ALU[DORQ] DEST[Q] $	;P
	D[MEM] ROT[1] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 3] ALU[DORQ] DEST[Q] $	;W
	D[MEM] ROT[1] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 4] ALU[DORQ] DEST[Q] $	;S
	D[MEM] ROT[1] COND[-OBUS<0] DEST[HOLD] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[Q] $	;C
	COND[-USER] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 0] ALU[DORQ] DEST[Q] $	;U
	D[CONST 1] ROT[35. - 8] ALU[DORQ] DEST[Q] $	;V ALWAYS
	ALU[0] DEST[HI-ABS-MA] PUSHJ[MAPON] $		;RESTORE STATE
	D[AR] DEST[MA] POPJ $				;RESTORE MA, RETURN



;------------------------------------------------------------------------------
; Enter here with fault code in Q and address in MA to handle page fault or
; page fill cycle.  MAP-EXEC-SR (i.e. USER condition) is still undisturbed.
;------------------------------------------------------------------------------
MFT1B:	D[CONST 1] DEST[DEV-ADR] $
	ALU[Q] DEST-A-MEM DEST[5] PUSHJ[MFPHYS] $	;GET PHYS ADDR IN Q
	D[CONST 1] DEST[DEV-ADR] NORM $
	SPEC[IOB-IN] NORM $
	MAPF[4] D[IOD] ROT[9] COND[OBUS<0] JUMP[MFI] CYLEN[IOB-IN] $ ;INVALID?
	ALU[Q] DEST[HOLD] $				;MAP FILL
	D[MEM] ROT[2] COND[OBUS<0] JUMP[. + 2] C600 $
	D[CONST 7] ROT[35. - 12.] ALU[DORQ] DEST[Q HOLD] $	;READ & XCT PREVENT
	D[MEM] ROT[3] COND[OBUS<0] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 12.] ALU[DORQ] DEST[HOLD] $;WRITE PREVENT
.REPEAT 1 - NEWMAP [
	D[MEM] MASK[36. - 9] DEST[STO-MAP] NORM $
];.REPEAT 1 - NEWMAP
.REPEAT NEWMAP [
	START-OUT  NORM $
	MAPF[2] D[MEM] MASK[36. - 9] C800 $
];.REPEAT NEWMAP
	ALU[0] DEST[DEV-ADR] COND[-HALF] JUMP[MAIN] C800 $	;DONE
		;IF HALF FLAG NOT ON
	D[12] ROT[2] MASK[2] SPEC[A-MEM-APR] DEST[AR] COND[OBUS=0] C550 JUMP[MAIN] $
		;IF ANY TRAP FLAGS ON IN PC, MUST REEXECUTE THE TRAP INSTRUCTION, NOT THE INSTRUCTION THAT CAUSED THE TRAP
		; AR WILL HAVE THE TRAP CODE
	D[PC] ALU[D+1] DEST[PC] JUMP[DOTRPX] NORM $
		;TRAP IS IN PROGRESS, MUST INCREMENT PC, AS WE DECREMENTED
		; IT ON THE WAY HERE ASSUMING INSTRUCTION AT PC+1
		; CAUSED FAULT. MUST INCREMENT PC HERE, BECAUSE DOTRPX
		; DECREMENTS PC, AND IF TRAP INSTRUCTION PAGE FAULTS,
		; WILL GET DECREMENTED AGAIN, AND PC WILL POINT TO THE COMPLETED INSTRUCTION THAT CAUSED THE TRAP
MFI:	D[15] ROT[15.] COND[-OBUS<0] JUMP[. + 2] C600 $
	D[CONST 1] ROT[35. - 5] ALU[DORQ] DEST[Q] SHORT $	;T
	ALU[Q] DEST[HOLD] NORM $
	D[MEM] ROT[9] MASK[9] DEST[HOLD] NORM $
	D[MEM] ROT[36. - 9] DEST[Q] NORM $
	D[AR] ALU[DORQ] DEST[AR] NORM $			;OR IN VIRTUAL ADDR
	D[CONST 5] ROT[6] DEST[Q] PUSHJ[MAPOF] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[16] MASK[13.] DEST[MA] NORM $
		;GET 13 BIT UPT PAGE NUMBER IN MA
	D[MA] ROT[9.] ALU[DORQ] DEST[HI-ABS-MA MA] NORM $
		;TURN INTO PHYS ADDRESS, PUT OFFSET INTO IT FROM Q
	D[AR] DEST[MEMSTO] NORM $				;PAGE FAIL WORD
	D[MA] ALU[D+1] DEST[MA] NORM $
	D[PC] DEST[AR] COND[HALF] PUSHJ[TPCFIX] NORM $
		;GET PC INTO AR, CALL TPCFIX TO SET PROPER PC IF HALF IS ON
	D[12] SPEC[A-MEM-APR] ROT[4] COND[-OBUS<0] C550 JUMP[MFI1] $
		;JUMP IF FAKE PC BIT IN AMEM IS NOT SET
	D[CONST 1] ROT[35. - 0] DEST[Q] SHORT $
		;OVERFLOW SHOULD BE SEEN AS ON BY USER, SET IT IN STORED OLD PC
	D[AR] ALU[DORQ] DEST[MEMSTO] JUMP[MFI2] NORM $
MFI1:	D[AR] DEST[MEMSTO] NORM $				;OLD FLAGS & AR
MFI2:	D[MA] ALU[D+1] DEST[MA] NORM $
	NOP $						;WAIT FOR MEMORY
	D[MEM] DEST[CRYOV] NORM $				;NEW FLAGS
	D[MEM] DEST[PC] PUSHJ[MAPON] NORM $			;NEW PC
	ALU[0] DEST[HI-ABS-MA] JUMP[MAIN] NORM $		;DONE
];.REPEAT KL



.REPEAT 1 - KL [
;------------------------------------------------------------------------------
;
;	BBN MAP - Handle map trap and page fill cycles.
;
;	This code will need to be rewritten for another kind of map.
;
;------------------------------------------------------------------------------
MFUS:	D[12] MASK[40] DEST[Q] NORM $;GET LIMIT REG
	D[MA] ALU[D-Q] COND[-OBUS<0] JUMP[MTRPAL] C600 $;J IF MA PAST ADDRS LIMIT
	D[11] DEST[Q] JUMP[MFA1] NORM $;GET USER BASE REG.

MFA3:	D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFA4] C550 $ ;J IF MODIF. BIT ON
MFA7:	D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[CONST 1] ROT[27] ALU[DORQ] DEST[AR] SHORT $; TURN ON WRT-PREVENT, SAVE NEW MAP WORD
MFA6:	D[MEM] MASK[33] DEST[Q] JUMP[MFA5] NORM $; GET CST ENTRY, GO DO
MFA4:	D[IR] ROT[26] MASK[1] COND[OBUS=0] JUMP[MFA7] C550 $; J IF NO WRT-PERMIT
	D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] JUMP[MFA6] NORM $; CLEAR WRT-PREVENT
;------------------------------------------------------------------------------
; Enter here with fault code in Q and address in MA to handle page fault or
; page fill cycle.  MAP-EXEC-SR (i.e. USER condition) is still undisturbed.
;------------------------------------------------------------------------------
MFT1B:	D[MA] MASK[18.] ALU[DORQ] DEST[AR] COND[USER] JUMP[MFUS] NORM $;GET FAILED ADDRS, J IF USER
	D[MA] ROT[24] MASK[2] DEST[Q] NORM $; HIGH ORDER 2 BITS
	D[CONST 3] ALU[D-Q] COND[OBUS=0] JUMP[MFHIEX] C600 $; J IF PRIVATELY MAPPED PART
	D[CONST 30] ROT[6] DEST[Q] JUMP[MFA1] NORM $; PAGE TAB @ 3000
MFHIEX:	D[14] DEST[Q] NORM $
MFA1:	ALU[0] DEST[DEV-ADR] NORM $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $ ;CLEAR MAPPING
	D[IR] MASK[3] DEST-A-MEM DEST[APRENB] MAPF[10] CYLEN[IOB-OUT] $
		;SAVE AR, ECC INT
	D[MA] ROT[33] MASK[11] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE ENTRY
	D[CONST 16] ROT[14] DEST[IR-ADR] NORM $; PREPARE INITIAL PERMIT BITS
	D[CONST 1] DEST[DEV-ADR] NORM $
MFA2:	D[CONST 3] DEST[Q] CYLEN[FIXM] $; DON'T CLEAR IND PNTR. COUNT, WAIT FOR FETCH
	D[MEM] ROT[18.] ALU[DORQ] DEST[Q] CYLEN[FIXM+1] $;GET PERMIT BITS
	D[IR] ALU[D&Q] DEST[IR-ADR] SHORT $; AND THEM IN
	D[MEM] ROT[13] MASK[3] COND[-OBUS=0] JUMP[MFTR1] C550 $; CHECK FOR TRAP BITS
MFB3:	D[MEM] ROT[15] MASK[1] COND[OBUS=0] JUMP[MFTR2] C550 $; J IF NO ACCESS PERMIT
	D[MEM] ROT[2] MASK[2] DEST[Q] COND[OBUS=0] JUMP[MFTYP0] C550 $; GET TYPE CODE, J IF 0
	ALU[Q-1] DEST[Q] COND[OBUS=0] JUMP[MFTYP1] C550 $; J IF 1
	ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[MFTR3] C550 $; J IF NOT 2
	D[IR] ROT[43] MASK[1] COND[-OBUS=0] JUMP[MFTR41] C550 $; TYPE 2, J IF >2 INDR. PNTRS
	D[IR] ALU[D+1] DEST[IR-ADR] SHORT $; COUNT IND. PNTRS
	D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET PAGE TABLE #
	D[MEM] DEST-A-MEM DEST[6] NORM $; SAVE PNTR
	D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE PNTR
	D[16] MASK[11] DEST[Q] CYLEN[FIXM] $; GET PAGE #, WAIT FOR MEM
	D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR4] C550 $; PAGE OUT-OF-CORE?
	D[MEM] MASK[13] DEST[HOLD] NORM $
	D[MEM] ROT[11] ALU[DORQ] DEST[MA HI-ABS-MA] JUMP[MFA2] NORM $; LOOP
MFTYP1:	D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET SHARED PAGE #
	D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH SHARED PNTR
MFTYP0:	D[CONST 12] ROT[14] DEST[Q] CYLEN[FIXM] $; GET R-X MASK
	D[IR] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C600 $; J IF NEITHER R NOR X
	D[IR] ALU[DORQ] DEST[IR-ADR] NORM $; TURN ON R AND X
	D[IR] ROT[27] MASK[3] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX ENBL BITS, INVERTED
	D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR5] CYLEN [C550] $; J IF OUT-OF-CORE
	D[AR] ROT[21] MASK[3] ALU[D&Q] DEST[Q] COND[-OBUS=0] JUMP[MFTR6] C550 $; J IF ILLEGAL ACCESS TYPE (RWX)



;MFA5 JSMFR MFTR1 MFTR10 MFB5 MFB4 MFC1 MFTR2 MTRPAL MFTR3 MFTR4 MFTR5 MFTR6 MFTR7 MFTR9 MFTR41 MAPRST MAPRSS MAPRSL
	D[MEM] MASK[13] DEST[Q] SHORT $; GET ABS PAGE #
	D[CONST 40] ROT[6] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; GET CORE STATUS ENTRY
	D[IR] ROT[12] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX DISABLES
	D[CONST 24] ROT[25] ALU[D&Q] DEST[Q] SHORT $; GET ONLY R & X
	D[CONST 4] ROT[25] ALU[D+Q] DEST[Q] SHORT $; MOVE X BIT LEFT 1
	D[MA] ROT[11] MASK[24] ALU[DORQ] DEST[Q] SHORT $; OR IN PAGE ADDRS
	D[MEM] ROT[3] MASK[3] COND[OBUS=0] JUMP[MFTR7] C550 $; J IF CST AGE SAYS TRAP
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFA3] C550 $;J IF NO WRT RQ
	D[AR] DEST[IR-ADR] SHORT $; SAVE ORRIGINAL MA
	D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
	D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] SHORT $; TURN OFF WRT PREVENT, SAVE NEW MAP WORD
	D[CONST 1] ROT[32] DEST[Q] SHORT $; GET MODIFICATION BIT
	D[MEM] MASK[32] ALU[DORQ] DEST[Q] SHORT $; OR INTO CST WORD
MFA5:	D[15] ALU[DORQ] DEST[HOLD] NORM $;OR IN AGE, ETC
	D[MA] DEST[Q] SHORT $; SAVE CST ADDRS

	D[IR] MASK[18.] DEST[MA HI-ABS-MA] NORM $; GET ORIGINAL MA

 .REPEAT NEWMAP [
	D[CONST 1] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	MAPF[2] D[AR] C800$; LOAD MAP
  NOP $ ;%%%%%%% FOR DEBUGGING $$$$$$$$
  ] ; NEWMAP

 .REPEAT 1 - NEWMAP [
	ALU[0] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
	D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
	MAPF[10] CYLEN[IOB-OUT] $
	D[AR] DEST[STO-MAP] NORM $; LOAD MAP
  ] ; 1-NEWMAP

	ALU[0] DEST[IOD] SPEC[IOB-OUT] C800 $ ;MAP OFF
	MAPF[10] CYLEN[IOB-OUT] COND[-USER] JUMP[. + 2] $

	D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
	ALU[Q] DEST[MA STRT-WRT] NORM $; STORE CST

.REPEAT 1 - WAITS [;Damnit. TENEX isn't the only operating system for a PDP-10!
   ;Now add 1 to abs. loc. 30 of main mem (for statistics keeping)
	D[CONST 30] DEST[MA] NORM $
	NORM $
	D[MEM] ALU[D+1] DEST[MEMSTO] NORM $
];.REPEAT 1 - WAITS

	D[CONST 1] DEST[DEV-ADR] NORM $
	D[16] DEST[AR] NORM $
	ALU[0] DEST[DEV-ADR] NORM $
	D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN MAP BACK ON, ETC.
	MAPF[10] CYLEN[MAX,IOB-OUT,C550]
			D[AR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JSMFR] $
		; DO SPECIAL JSYS STUFF IF APPROPRIATE
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MAIN]  C550 $; DONE IF NO WRT
	D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MAIN] C550 $; DONE IF READ
	D[AR] MASK[18.] DEST[MA] SHORT $;GET ORRIG. MA
	D[CONST 1] DEST[DEV-ADR] SHORT $
	D[17] DEST[MEMSTO] JUMP[MSMAIN1] NORM $; STORE THE STORE DATA, & PROCEDE
JSMFR:	D[AR] MASK[18.] DEST[MA] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[17] DEST[AR] JUMP[MUJSM1] NORM $; RESTORE STORE DATA

MFTR1:	D[MEM] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MFTR9] C550 $; J IF TRAP TO USER
	D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFTR10] C550 $;J IF WRT TRAP
	D[MEM] JUMP[MFTR2] NORM $; TREAT BOTH "TRAP-TO-MON" CODES AS IMMEDIATE
MFTR10:	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFB3] C550 $; WRT RQ? J IF NO
	D[CONST 44] ROT[36] DEST[Q] SHORT $; GET ERROR CODE BITS -- WRT TRAP
MFB5:
MFB4:	D[AR] ALU[DORQ] DEST[AR Q] COND[USER] JUMP[. + 2] NORM $; OR ERROR BITS IN, J IF USER MODE
	D[CONST 1] ROT[18.] ALU[DORQ] DEST[AR] NORM $; TURN ON EXEC BIT
	D[CONST 5] ROT[6] DEST[Q] SHORT $
	D[CONST 71] ALU[DORQ] DEST[Q] SHORT $; FORM 571
	D[14] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; ADD PSB (MON BASE TAB)
	D[AR] DEST[MEMSTO] CYLEN[FIXM] $; STORE ERROR BITS THERE
	D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFC1] C550 $; J IF NO WRT RQ
	D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MFC1] C550 $; J IF RD RQ
	D[MA] ALU[D+1] DEST[MA] SHORT $; GO TO 572
	D[17] DEST[MEMSTO] NORM $; SAVE STORE DATA
MFC1:	ALU[0] DEST[DEV-ADR] CYLEN[MEMSTO] $
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN OFF MAP
	MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $
	D[CONST 70] DEST[MA] SHORT $; FETCH TRAP INSTR
	ALU[0] DEST[DEV-ADR] CYLEN[FIXM] $
	D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] SHORT $; TURN ON MAP
	D[PC] DEST[Q AR] MAPF[10] CYLEN[IOB-OUT] $
	D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $;CLR USER
	D[CONST 55] ROT[2] DEST[Q] JUMP[MUUO44] NORM $
MFTR2:	D[CONST 41] ROT[36] DEST[Q] JUMP[MFB5] NORM $; ASCCESS PERMISSION TRAP
MTRPAL:
MFTR3:	D[CONST 40] ROT[36] DEST[Q] SHORT $
	D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB5] NORM $; ILLEGAL PT ENTRY TYPE, ADDRESS LIMIT
MFTR4:	;ALL THESE ARE NOT-IN-CORE
MFTR5:	D[CONST 22] ROT[36] DEST[Q] JUMP[MFB5] NORM $; NOT-IN-CORE
MFTR6:	D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[. + 3] C550 $; J IF NO R OR X ERROR
	D[CONST 4] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN "R OR X ERROR" BIT
	D[CONST 2] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C550 $; J IF NO W ERROR
	D[CONST 2] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN W ERROR BIT
	D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
	D[CONST 40] ROT[36] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; GROUP 2
MFTR7:	D[CONST 10] ROT[36] DEST[Q] JUMP[MFB4] NORM $; AGE ERR -- GROUP 0
MFTR9:	D[CONST 42] ROT[36] DEST[Q] JUMP[MFB4] NORM $; USER TRAP
MFTR41:	D[CONST 20] ROT[36] DEST[Q] NORM $; GROUP 1
	D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; TOO MANY INDR. PNTRS
];.REPEAT 1 - KL



;------------------------------------------------------------------------------
;Reset map.  Clear entire map to zero.  This is because even though the map
;will stop stores from happening, fetches still happen irregardless of state
;of map and if map points at non-existent memory (on for example, an immediate
;mode instruction), the machine will get a spurious ECC interrupt.
;
;It is assumed that the device address is set to 1 when this thing is called.
;ALSO FOR KL MAP -PG
;------------------------------------------------------------------------------
MAPRST:	SET-TEMP-EXEC $
		;Begin at the beginning of EXEC space.
	D[CONST 1] ROT[9.] DEST[Q] SHORT $
		;Increment for MA
MAPRSS:	D[CONST 1] ROT[18.] ALU[D-Q] DEST[MA] NORM $
		;Start at the top and work down.
MAPRSL:
.REPEAT 1 - NEWMAP [
	D[CONST 1] ROT[35. - 9.] DEST[STO-MAP] NORM $
		;Set mapping to zero, Invalid
	D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 1] C550 $
		;Repeat for each page in this space.
];.REPEAT 1 - NEWMAP
.REPEAT NEWMAP [
	START-OUT SHORT $
	MAPF[2] D[CONST 1] ROT[35. - 9.] C800 $
		;Set mapping to zero, Invalid
	START-OUT D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 1] C800 $
		;Repeat for each page in this space
];.REPEAT NEWMAP
	SET-TEMP-USER COND[-USER] JUMP[MAPRSS] $
		;Repeat once more if currently doing EXEC space. This
		;time for USER space.  We can do this because EXEC-SR is
		;latched at the end of the cycle.
.REPEAT 1 - KL [
	ALU[0] DEST[DEV-ADR] NORM $
	D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[14] CYLEN[IOB-OUT] D[CONST [MAPTRAP-ORG / 2000]] DEST[MAP-DISP] $
	DEST[CLR-MI-ERR] POPJ $	;Done

];.REPEAT 1 - KL
.REPEAT KL [
	D[CONST [MAPTRAP-ORG / 2000]] DEST[MAP-DISP] NORM $
		;PAGE MICRO TRAPS HAPPEN AT 6000+OFFSET.
	ALU[0] DEST-A-MEM DEST[6] NORM $
	ALU[0] DEST-A-MEM DEST[7] NORM $
	ALU[0] DEST[DEV-ADR] POPJ NORM $	;DONE
];.REPEAT KL

;------------------------------------------------------------------------------
;MAP ON AND MAP OFF FOR THE KL PAGER. (THIS IS NOT THE SAME MAPOFF AS FOR BBN)
;NOTE THESE USE THE RIGHT HALF OF IR. -PG
;------------------------------------------------------------------------------
.REPEAT KL [
MAPON:	ALU[0] DEST[DEV-ADR]  $
	D[IR] DEST[IOD] SPEC[IOB-OUT]  $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
MAPOF:	D[CONST 1] DEST[DEV-ADR] $
	SPEC[IOB-IN] NORM $
	D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR]  $
	D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
MAPUP:	D[CONST 1] DEST[DEV-ADR] $
	SPEC[IOB-IN] NORM $
	D[IOD] MASK[1] DEST[Q] MAPF[4] CYLEN[IOB-IN] $
	D[CONST 6] ALU[DORQ] DEST[IR-ADR] $
	  ;TURN ON MAP AND ARITH OVERFLOW (ON AND OFF TOGETHER ON KL PAGER)
	ALU[0] DEST[DEV-ADR]  $
	D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
MAPDN:	D[CONST 1] DEST[DEV-ADR] $
	SPEC[IOB-IN] NORM $
	D[IOD] MASK[1] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
	  ;TURN OFF BOTH PAGING AND ARITH TRAPS.
	ALU[0] DEST[DEV-ADR]  $
	D[IR] MASK[1] DEST[IOD] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] POPJ $
];.REPEAT KL



;JSYS1 JSYS2 UMOVX XCT1 XCTUMV XCT5 XCT4 XCT6 XCT3 XCT13 XCT18 XCT12 XCT11 XDISP XCT2 XCTAC XCTSTK
; XCTS1 XCTS2 XCT10 XCTBLG XCTBYT XBY1 XBY4 XBY15 XBY14 XBY13 XBY3
;------------------------------------------------------------------------------
;
;	BBN added instructions.  Sometimes used by other than TENEX
;
;	LEAVE FOR KL PAGER. -PG
;------------------------------------------------------------------------------
.REPEAT 1 - KL [
JSYS1:	FIXM1 $
	D[PC] DEST[AR] NORM $	;SAVE PC & FLAGS
	D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
	D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $
	D[AR] DEST[MEMSTO] MEMSTMA $
JSYS2:	C550 D[CONST 1] ROT[36] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] $; J IF EXEC MODE
	ALU[0] DEST[MAP-EXEC-SR]  NORM $; TEMP TURN OFF USER
	D[CONST 10] ROT[6] DEST[Q] SHORT $
	D[MA] ALU[DORQ] DEST[MA] SHORT $; FETCH POINTER WORD
	FIXM1  $
	D[MEM] MASK[18.] DEST[PC] NORM $; J TO RIGHT HALF
	D[PC] DEST[Q] SHORT $
	D[AR] ROT[5] C550 COND[OBUS<0] JUMP[. + 2] $
		;If we came from exec mode, then we...
	D[CONST 1] ROT[34] ALU[DORQ] DEST[Q] SHORT $
		; ...TURN ON FLAG BIT 7
	D[CONST 1] ROT[36] ALU[-D&Q] DEST[CRYOV] SHORT $; TURN OFF USER
	D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; LEFT HALF
	D[AR] DEST[MEMSTO] MEMSTMA $; STORE PC
];.REPEAT 1 - KL

.REPEAT 1 - KL [
  .DEFINE JCFM [JAD]
[	D[PC] ROT[10] MASK[1] COND[-OBUS=0] JUMP[JAD] C550 $;J IF CALL FM MON]
  .DEFINE JCNFM [JAD]
[	D[PC] ROT[10] MASK[1] COND[OBUS=0] JUMP[JAD] C550 $;J IF CALL NOT FM MON]
];.REPEAT 1 - KL

.REPEAT KL [
  .DEFINE JCFM [JAD]
[	D[PC] ROT[7] MASK[1] COND[OBUS=0] JUMP[JAD] C550 $;J IF CALL FM MON]
  .DEFINE JCNFM [JAD]
[	D[PC] ROT[7] MASK[1] COND[-OBUS=0] JUMP[JAD] C550 $;J IF CALL NOT FM MON]
];.REPEAT KL

UMOVX:	COND[USER] JUMP[MUUO] NORM $
	D[MEM] DEST[Q] NORM $
	D[CONST 1] ROT[41] ALU[D+Q] DEST[HOLD] NORM $
	D[CONST 5] DEST[Q] JUMP[XCTUMV] NORM $




;------------------------------------------------------------------------------
;
;	XCTR - Execute Relocated
;
;	If in Exec mode and the AC field of the XCT instruction is non-zero,
;	it means do some of the references from User mode if PC bit (?),
;	meaning JSYS from Moniter, is not set.
;
;	This code is not map dependent, although other maps (like ITS) may code
;	the bits in the AC field differently, requiring some rewriting.
;
;	Warning:  This code is complex and prone to bugs.  Many probably lurk
;		  in the cracks.  If you find one, please document it even if
;		  no solution seems to appear.
;
;	FOR NOW, THIS CODE WILL BE USED FOR THE KL PAGER. I'M NOT SURE
;	THIS WILL REALLY WORK. -PG
;
;	Note on the MAP-EXEC-SR
;
;	This is a four bit shift register whose contents get
;	shifted right on every MEMSTO. The COND[USER] actually
;	checks the rightmost bit of this register. When the register
;	is shifted, the value of the user mode bit gets shifted into
;	the left side of the register. The entire register gets
;	set to the state of the user mode bit on DEST[CRYOV] and
;	SPEC[MA_PC] (signal Fetch Next Inst). The rightmost bit
;	of this register is used by the map logic to determine
;	which address space's map to use.  EVS 14 Aug 80
;------------------------------------------------------------------------------
XCT1:	D[PC] ALU[D-1] DEST[PC] JPOP[. + 1] NORM $
	COND[USER] JUMP[XCT2] NORM $
	D[IR] ROT[15] MASK[4] DEST[Q] SHORT $; SAVE XCT AC FLD
XCTUMV:	D[MEM] DEST[AR IR-ALL MA] COND[-MEM-IDX-IND] JUMP[XCT3] NORM $
XCT5:	D[IR] ROT[18.] MASK[4] COND[OBUS=0] JUMP[XCT4] C550 MAPF[2] $; J IF NO IDX FLD
.REPEAT KL [
	D[CONST 10] ALU[D&Q] COND[OBUS=0] JUMP[XCTIX1] C550 $
				;IF E NOT IN PREVIOUS CONTEXT, JUMP
	D[CONST 1] DEST[DEV-ADR] NORM $
	ALU[Q] DEST-A-MEM DEST[5] NORM $	;SAVE Q
	D[16] ROT[9] MASK[3] DEST[Q] NORM $	;CURRENT AC BLOCK
	D[16] ROT[12.] MASK[3] ALU[D#Q] COND[OBUS=0] JUMP[XCTQF1] NORM $
			;PREVIOUS AC BLOCK
	PUSHJ[XCTACP] NORM $	;GET ADDRESS OF PREVIOUS AC 0 IN Q
	D[IR] ROT[18.] MASK[4] ALU[D+Q] DEST[MA] NORM $	;+X
	D[IR] MASK[18.] DEST[Q] NORM $			;WAIT
	D[MEM] ALU[D+Q] DEST[MA IR-ADR AR] NORM $ ;DO INDEX
	D[15] DEST[Q] NORM $				;RESTORE Q
	ALU[0] DEST[DEV-ADR] JUMP[XCT4] NORM $
XCTQF1:	D[15] DEST[Q] NORM $				;RESTORE Q
	ALU[0] DEST[DEV-ADR] NORM $
];.REPEAT KL
XCTIX1:	D[IR] MASK[18.] ALU[IX+D] DEST[MA IR-ADR AR] $	;DO INDEX
XCT4:	D[IR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XCT3] C550 MAPF[2] $; J IF NO INDR
	D[CONST 10] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF ADDR CALC USER
XCT6:
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-IND] CYLEN[FIXM] $
;;;	FIXM1 $
;;;		;It was overdecrementing PC  TVR-Mar80
	SET-TEMP-EXEC $
	D[MEM] DEST[AR IR-23 MA] COND[MEM-IDX-IND] JUMP[XCT5] NORM $
XCT3:	ALU[Q] DEST[IR-ADR] SHORT  MAPF[2] $; SAVE XCT AC FLD
	D[IR] ROT[7] MASK[7] DEST[Q] SHORT $; GET HO 7 BITS OF OPCODE
	D[CONST 54] ALU[D#Q] COND[OBUS=0] JUMP[XCTSTK] C550 $; J IF STACK GROUP
	D[CONST 27] ALU[D#Q] COND[OBUS=0] JUMP[XCTBYT] C550 $; J IF BYTE GROUP
	D[CONST 52] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLG] C550 $; J IF GROUP WITH BLT IN IT
XCT13:	D[IR] MASK[4] DEST[Q] SHORT $; GET XCT AC FLD
.REPEAT 1 - KL [
XCT18:	D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NEITHER RELEVANT BIT
	COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
	JCFM[XDISP] ;J IF CALL FM MON
	D[CONST 1] ALU[D&Q] COND[OBUS=0] JUMP[XCT11] C550 $;J IF BIT OFF
	D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XCT12] C550 $; J IF OTHER BIT OFF
	D[CONST 03] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
XCT12:	D[CONST 02] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET DEST TO USER
XCT11:	D[CONST 01] ROT[11] DEST[MAP-EXEC-SR] NORM $; SET SRC TO USER
];.REPEAT 1 - KL
.REPEAT KL [
XCT18:	D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NO RELEVANT BIT
	D[IR] COND[OBUS<0] C550 JUMP[XIOINST] $; MUST FILTER OUT CLRPT
XNOTPT:	COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
XISPT:	JCFM[XDISP] ;J IF CALL FM MON
	D[CONST 07] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
		;OTHER BIT IS IN CASE ITS A DMOV?M
];.REPEAT KL
XDISP:	D[MA] DEST[MA IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
XCT2:	D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $
.REPEAT KL [
;THIS RETURNS THE ADDRESS OF AC0 IN THE PREVIOUS AC BLOCK IN Q.
;THIS SAVES IR IN AR FOR MAPON/OFF. IT SETS DEVICE 1.
XCTACP:	D[IR] MASK[18.] DEST[AR] PUSHJ[MAPOF] NORM $	;SAVE IR FOR MAPON/OFF
	D[CONST 1] DEST[DEV-ADR] NORM$
	D[17] ROT[9.] MASK[9. + 13.] DEST[Q] NORM $	;EXEC BASE ADDRESS
	D[CONST 37] ALU[DORQ] DEST[MA HI-ABS-MA] NORM $	;+37=AC BLOCK PTR
	D[16] ROT[16.] MASK[7] DEST[Q] NORM $	;GET PREVIOUS AC BLOCK
	D[MASK 4] ALU[-D&Q] DEST[Q] NORM $		;*16.
	D[MEM] ALU[D+Q] DEST[Q] NORM $			;+AC BLOCK PTR 
	ALU[0] DEST[HI-ABS-MA] PUSHJ[MAPON] NORM $	;RESTORE STATE
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST[IR-ADR] POPJ NORM $			;AND RETURN
];.REPEAT KL
XCTAC:
.REPEAT KL [
	D[CONST 1] DEST[DEV-ADR] NORM $
	D[AR] DEST-A-MEM DEST[1] NORM $			;SAVE AR
	D[MA] DEST-A-MEM DEST[4] NORM $			;SAVE MA
	ALU[Q] DEST-A-MEM DEST[5] NORM $		;SAVE Q
	D[16] ROT[9] MASK[3] DEST[Q] NORM $		;CURRENT AC BLOCK
	D[16] ROT[12.] MASK[3] ALU[D#Q] COND[OBUS=0] JUMP[XCTQF2] NORM $
			;PREVIOUS AC BLOCK
	PUSHJ[XCTACP] NORM $ 	;GET ADDRESS OF PREVIOUS AC 0 IN Q
	D[14] ALU[D+Q] DEST[Q] NORM $			;+AC
	ALU[Q] DEST-A-MEM DEST[4] NORM $
XCTQF2:	D[15] DEST[Q] NORM $				;RESTORE Q
	D[14] DEST[MA] NORM $				;RESTORE MA
	D[11] DEST[AR] NORM $				;RESTORE AR
	SET-TEMP-EXEC $;SINCE RETURNING ADDRESS IN EXEC SPACE, MAKE
			; SURE THATS WHERE THE MEMORY REFERENCE COMES FROM.
	ALU[0] DEST[DEV-ADR] POPJ NORM $
];.REPEAT KL
.REPEAT 1 - KL [
.REPEAT 1 - WAITS [
	ACSEL[AC] ALU[AC] DEST[HOLD]  SHORT $; SAVE AC
	ACSEL[AC] DEST[CLR-DEV-FROM-INTR AC] D[MA] SHORT $; GET AC ADDRS
	D[CONST 1] DEST[DEV-ADR] SHORT $
	ACSEL[AC] D[13] ALU[D+AC] DEST[AC] SHORT $; ADD IN AC BASE REG.
	ACSEL[AC] D[CONST 75] ROT[11] ALU[D+AC] DEST[AC] SHORT $
	ACSEL[AC] D[CONST 7] ROT[17] ALU[D+AC] DEST[AC] NORM $
	D[MEM] ACSEL[AC] DEST[O_AC MA] POPJ NORM $
];.REPEAT 1 - WAITS
.REPEAT WAITS [
	D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $; LEAVE IF CALL FM MON
	ACSEL[AC] D[MA] DEST[O_AC HOLD] $
		;Get address of AC, we need to mung it
		;Save AC, we can't use Q for some reason [???]
	ACSEL[AC] D[CONST 77] ROT[9. + 3.] ALU[D+AC] DEST[AC] NORM $
		;Add page number of window
		;Use 770xxx for window into user ACs
	D[MEM] ACSEL[AC] DEST[O_AC MA CLR-DEV-FROM-INTR] NORM $
		;Restore AC and set MA from AC to start read
.REPEAT 1 - NEWMAP [
	D[CONST 1] DEST[DEV-ADR] NORM $
		;Select appropriate A-MEM
	D[13] ROT[9.] MASK[36. - 13.] DEST[STO-MAP] COND[OBUS=0] JUMP[.] NORM $
		;Extract address and position for map
		;Not R,W,X excluded.  Not NO ENTRY AT ALL
		;Hang if attempt to reference user ACs with no shadow
		;memory defined at time of CONO PAG,
];.REPEAT 1 - NEWMAP
.REPEAT NEWMAP [
 	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
		;Select appropriate A-MEM
		;Set place in map to write it and start map write
	MAPF[2] ROT[9.] MASK[36. - 13.] COND[OBUS=0] JUMP[.] NORM $
		;Finish map write.
		;Not R,W,X excluded.  Not NOT ENTRY AT ALL
		;Hang if attempt to reference user ACs with no shadow
		;memory defined at time of CONO PAG,
];.REPEAT NEWMAP
	D[MA] DEST[MA] POPJ NORM $
];.REPEAT WAITS
];.REPEAT 1 - KL
XCTSTK:
;;;	COND[-MA-AC] JUMP[XCT13] NORM $; J IF EF ADR NOT AC (TREAT NORMALLY)
	D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LOW ORDER BITS OF OP CODE, J IF PUSHJ
	D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF POPJ
.repeat 0[
	D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XCTS1] C550 $; J IF POP
	D[CONST 4] DEST[Q] JUMP[XCTS2] NORM $
XCTS1:	D[CONST 1] DEST[Q] SHORT $
XCTS2:	D[IR] ALU[D&Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF AC REF NOT USER
	D[IR] ALU[D-Q] DEST[IR-ADR] PUSHJ[XCTAC] NORM $; FIX EF ADR.
	MAPF[2] JUMP[XCT13] NORM $
];.repeat 0
	D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XPOP1] C550 $; J IF POP
	JUMP[XPUSH1] NORM $
		;Someday, move code over here (when we have space)
XCT10:	PUSHJ[XCTAC] NORM $; FIX EF ADR
	MAPF[2] D[MA] DEST[IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
XCTBLG:	D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LO BITS OF OPCODE, J IF EXCH
	D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLT] C550 $; J IF BLT
	D[IR] MASK[4] DEST[Q] JUMP[XCT18] NORM $; GET XCT AC FLD, PROCEDE

	.USE[OTHER]

XCTBYT:	D[IR] ROT[42] MASK[1] SPEC[PC+1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF B.P. FETCH IS NOT EXEC
XBY1:	D[IR] ROT[11] MASK[1] COND[OBUS=0] JUMP[XBY3] C550 MAPF[2] $;J IF BP WILL BE INCR
	FIXM1 $
	D[MEM] DEST[AR Q] NORM $; GET BP
XBY4:	SET-TEMP-EXEC $
	D[AR] MASK[18.] DEST[MA] COND[-MEM-IDX-IND] JUMP[XBY13] NORM $; J IF BP HAS NO IDX OR INDR
XBY15:	D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[XBY14] C550 MAPF[2] $; J IF NO IX FLD
	D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] NORM $
	D[AR] MASK[18.] ACSEL[REG] ALU[D+AC] DEST[AR] SHORT $
	D[AR] MASK[18.] ALU[DORQ] DEST[Q AR MA] SHORT $
XBY14:	D[AR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XBY13] C550 MAPF[2] $; J IF NO INDR
	D[IR] ROT[43] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF BP ADR CALC IS USER
	FIXM1 $
	SET-TEMP-EXEC $
	D[AR] ROT[14] MASK[14] DEST[AR] SHORT $
	D[AR] ROT[30] DEST[Q] SHORT $
	D[MEM] MASK[27] ALU[DORQ] DEST[Q AR MA] COND[MEM-IDX-IND] JUMP[XBY15] NORM $
XBY13:	D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] MAPF[2] $; MAKE MA OK
	D[IR] ROT[10] MASK[1] COND[OBUS=0] JUMP[LDB5] C550 MAPF[2] $; DISTINGUISH LOADS FROM DEPOSITS, J IF LOAD
	JUMP[DPB5] NORM $

XBY3:	FIXM2 $
.REPEAT 1 - KL [
	D[MEM] DEST[AR Q] COND[HALF] JUMP[XBY4] NORM $;GET BP, J IF NO INCR
];.REPEAT 1 - KL
.REPEAT KL [
	D[MEM] DEST[AR Q] COND[HALF] JUMP[XBYH] NORM $;GET BP, J IF MAYBE NO INCR
XBY3A:];.REPEAT KL
	D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $; GET S FLD, HANDLE OVERFLOW
	D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $; SUB S FROM P
	ACSEL[MA] D[MEM] DEST[AC] NORM $
	PUSHJ[SETFPD] NORM $; SET HALF
	JUMP[XBY4] NORM $; (IN CASE OF MAP FAULTS)
.REPEAT KL [
XBYH:	D[12] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[XBY4] $
		;IF KL, AND AMEM FPD SET, THEN DON'T INCREMENT
	JUMP[XBY3A] NORM $;ELSE FORGET HALF WAS ON.
];.REPEAT KL
XFIXMA:	COND[MA-AC] JUMP[XCTAC] NORM $; J IF ADDRS IS AC
.REPEAT 1 - KL [
	D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $;LEAVE IF CALL FROM MONITOR
];.REPEAT 1 - KL
.REPEAT KL [
	D[PC] ROT[7] MASK[1] COND[OBUS=0] POPJ C550 MAPF[2] $; RETURN IF CALL IS FROM MONITOR
];.REPEAT KL
	SET-TEMP-USER $
	D[MA] DEST[MA] POPJ NORM $

XCTBLT:	D[MA] SPEC[PC+1] DEST[O_AC AR] NORM $; END ADR IN AC, AC IN AR
XBLTL:	D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET WORD
.REPEAT 1 - KL [
	D[IR] ROT[42] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; FIX IF USER ADDRS
];.REPEAT 1 - KL
.REPEAT KL [
	D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX IF SOURCE IS FROM USR SPACE
];.REPEAT KL
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
	D[MEM] DEST[Q] SHORT $; GET DATA WORD
	D[AR] MASK[18.] DEST[MA] SHORT $; GET DEST ADR
.REPEAT 1 - KL [
	D[IR] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX MA ADDRS
];.REPEAT 1 - KL
.REPEAT KL [
	D[IR] ROT[33. + 1.] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $ ;FIX SR IF DEST IS USER SPACE
];.REPEAT KL
	ALU[Q] DEST[MEMSTO] SHORT $
	D[AR] MASK[18.] ALU[D-AC] MAPF[BLT-WRTB] COND[-OBUS<0] JUMP[BLTA12] C600 $
	D[CONST 1,,1] DEST[Q MAP-EXEC-SR] COND[-MA-AC] JUMP[. + 2] NORM $
	D[MEM] ACSEL[MA] DEST[AC] SHORT $
	D[AR] ALU[D+Q] DEST[AR] JUMP[XBLTL] NORM $; TEST FOR INTERPT HERE ? *****
;Special case for PUSH.  Check for AC reference from stack pointer
XPUSH1:	D[IR] MASK[1] COND[OBUS=0] JUMP[XPUSH2] C550 $
		;If not mapping stack references, it's simple
	D[IR] ROT[36. - 2] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] SPEC[PC+1] C550$
		;Make sure we're referring to the right place here.
		;Also, we're now executing the instruction (PC+1)
	FIXM1 $	;Check page faults for effective address part.
	D[MEM] DEST[AR] NORM $
		;Copy away the thing that we want to push
	D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[XPDLO2] C550 $
		;Advance frame pointer and check for overflow
	PUSHJ[XFIXMA] NORM $
		;Decide whether to map destination.
.REPEAT 1 - KL [;BBN PAGER CAN USE NORMAL STORE, SINCE MACRO CODE NEEDS TO FINISH THE WRITE AFTER A PAGE FAIL.
	D[AR] DEST[MEMSTO] MEMST $
];.REPEAT 1 - KL
.REPEAT KL [
	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PMSMAIN] NORM $
		;KL PAGER NEEDS TO GO TO PLACE WITH SPECIAL MAPF FIELD
		; THAT WILL MAKE THE POINTER BACKUP
];.REPEAT KL
		;Finish instruction. We're done
XPDLO2:	PUSHJ[XFIXMA] NORM $
		;Fixup AC references
	JUMP[PDLO2] NORM $
		;Done.  Take stack overflow trap

;HERE IF ONLY THE 4 BIT IS ON IN XCT AC FIELD. ALMOST LIKE
; A REGULAR INSTRUCTION, EXCEPT CANNOT SET THE MAP-EXEC-SR TO 3,
; LIKE XCT18 DOES EVENTUALLY BECAUSE SOURCE COMES FROM EXEC MODE.
; XPUSH1 USED TO GO TO XCT13, BUT WHILE DEBUGGING KL MAP
; FOUND THIS PROBLEM OF XCT 4,[PUSH AC,FOO] FAULTING ON USER
; ADDRESS CORRESPONDING TO STACK. I ASSUME THIS DIDN'T WORK FOR
; BBN MAP EITHER, BUT I PUT THIS COMMENT HERE JUST IN CASE. EVS 7/30/80

XPUSH2:	D[IR] ROT[33.] COND[-OBUS<0] JUMP[XDISP] C550 $
		;IF 4 BIT ISN'T ON, THEN DO INSTRUCTION AS USUAL.
	COND[MA-AC] JUMP[XCT10] NORM $
		;IF PUSHING AN AC, MUST DO IT FROM ANOTHER AC BLOCK PERHAPS.
	JCFM[XDISP]	;IF MONITOR IS PREVIOUS ADDRESS SPACE,, LEAVE SR SET TO ZERO
	D[CONST 1] ROT[9.] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $
		;SOURCE COMES FROM USER, BUT STACK IS IN EXEC.

;Special case for POP.  Check for AC reference from stack pointer
XPOP1:	D[IR] ROT[11] DEST[Q] NORM SPEC[PC+1] $
		;Save bit meaning 'source from user' in format that can
		;be fed easily to EXEC-SR
		;Now we're executing the PUSH (implied by PC+1)
.REPEAT KL [
		;THIS STUFF SWAPS THE 1 AND 4 BIT
	D[CONST 1] ROT[11] ALU[-D&Q] DEST[Q] NORM $
	D[CONST 4] ROT[11] ALU[-D&Q] DEST[Q] NORM $
	D[IR] ROT[35.] COND[-OBUS<0] JUMP[. + 2] C550 $
	D[CONST 4] ROT[11] ALU[DORQ] DEST[Q] NORM $
	D[IR] ROT[33.] COND[-OBUS<0] JUMP[. + 2] C550 $
	D[CONST 1] ROT[11] ALU[DORQ] DEST[Q] NORM $
];.REPEAT KL
	D[MA] DEST[IR-ADR] NORM $
		;Restore normal effective address 
	ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC] NORM $
		;Update AC and MA for stack reference
	D[CONST 4] ROT[11] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $
		;Fixup stack addressing if user AC
	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
		;Check for page faults
	D[MEM] DEST[AR] NORM $
		;Find somewhere safer for thing to push
	D[IR] MASK[22] DEST[MA] NORM $
		;GET ADDRESS INTO MA FOR XCTAC
	D[CONST 1] ROT[11] ALU[D&Q] COND[OBUS=0] JUMP[XPOP3] C550 $
		;JUMP IF NOT STORING INTO PREVIOUS CONTEXT ADDRESS SPACE
	COND[MA-AC] JUMP[XPOPAC] NORM $;JUMP IF POPPING TO AN AC
		;Fixup AC addressing if needed.  (We can't combine this and
		;previous instruction because MA is strobed at end of cycle.
		;We can't call XFIXMA because it uses SET-TEMP-USER which
		;would affect the next instruction fetch. Sigh...)
XPOP2:	JCFM[XPOP3] ;JUMP IF CALL FROM MONITOR, LEAVE EXEC-SR CLEARED
	D[CONST 2] ROT[9.] DEST[MAP-EXEC-SR] JUMP[XPOP3] NORM $;WILL GET SHIFTED ONCE BEFORE THE STORE, THEN STORE WILL HAPPEN TO USER SPACE
XPOPAC:	PUSHJ[XCTAC] NORM $ ;FIXUP MA TO POINT TO AREA WHERE PREVIOUS ACS ARE KEPT
XPOP3:	D[CONST 1,,1] ALU[D+AC] COND[CRY0] JUMP[PDLO5] C550 $
		;Try for overflow again.  Take it if you need it.
.REPEAT 1 - KL [
	D[AR] DEST[MEMSTO] MEMST $
];.REPEAT 1 - KL
.REPEAT KL [
	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PMSMAIN] NORM $
];.REPEAT KL
		;Write out thing we POP'ped

.REPEAT KL [
	.USE[OTHER]
;HERE IF HI ORDER BIT IN OPCODE IS ON. IF ITS CLRPT, MUST
; AVOID CHECKING FOR EFFECTIVE ADDRESS EQUAL TO AC, SO THAT
; WE CLEAR PAGE TABLE EVEN IF ADDRESS IS GIVEN IN ACS (TO BE
; COMPATIBLE WITH KL10)

XIOINST:
	D[IR] ROT[6. + 1.] MASK[6] DEST[Q] SHORT $ ;GET HI ORDER 6 BITS
	D[CONST 60] ALU[D#Q] COND[-OBUS=0] JUMP[XNOTPT] C550 $
		;FIRST 6 BITS 1-6 ARE 60, JUMP IF NOT THAT
	D[IR] ROT[12. + 1.] MASK[6] DEST[Q] SHORT $;GET NEXT 6 BITS, 7-12
	D[CONST 22] ALU[D#Q] COND[-OBUS=0] JUMP[XNOTPT] C550 $
		;SECOND 6 BITS, 7-12, ARE 22, JUMP IF NOT THAT
	JUMP[XISPT] SHORT $;IS CLRPT, SKIP OVER THE CHECK FOR AC ADDRESS.
];.REPEAT KL



;APRDSP PIDSP AREA53 APRCO APRCO2 APRCO3 APRIEN APRC1 APRC2 APRCHK APRCK1 APDINT APRCI APRCII APRDI APIOT
;------------------------------------------------------------------------------
;
;	APR and PI instructions
;
;------------------------------------------------------------------------------
	.ORG[5300]	 ;APR & PI IOT DISP TABLE
APRDSP:	ILGIOT $; BLKI APR
	NOP $
	ALU[0] DEST[DEV-ADR] NORM $; DATAI -- RD SW
	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] JUMP[APRDI] NORM $
	ILGIOT $ ;BLKO APR
	NOP $
	JUMP[MAIN] $; DATAO
	NOP $
.REPEAT 1 - KL [
	D[IR] MASK[13] DEST[Q] NORM $; GET CONO BITS
	D[CONST 33] ROT[5] ALU[-D&Q] DEST[Q] JUMP[APRCO] NORM $
];.REPEAT 1 - KL
.REPEAT KL [
	JUMP [APRCO] NORM $
	NOP $
];.REPEAT KL
	PUSHJ[APRCI] NORM $; CONI -- GET BITS IN AR & Q
.REPEAT KL [
	D[AR] DEST[MEMSTO] MEMST $
		;IF KL, WHOLE WORD GETS RETURNED
];.REPEAT KL
.REPEAT 1 - KL [
	D[AR] MASK[18.] DEST[MEMSTO] MEMST $
];.REPEAT 1 - KL
	PUSHJ[APRCI] NORM $; CONSZ -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	PUSHJ[APRCI] NORM $; CONSO -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
PIDSP:	.REPEAT 3[ ILGIOT $
	NOP $
]
	;DATAO PI -- Set lights
	D[CONST 0] DEST[DEV-ADR] PUSHJ[SETLTS] NORM $	;Just like examine...?
	JUMP[MAIN] SHORT $
	JUMP[PICONO] NORM $; PI CONO
	NOP $
	PUSHJ[PICONISUB] NORM $; CONI -- GET BITS IN AR & Q
	D[AR] DEST[MEMSTO] MEMST $
	PUSHJ[PICONISUB] NORM $; CONSZ -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
	PUSHJ[PICONISUB] NORM $; CONSO -- GET BITS IN AR & Q
	D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $


   .USE[NORMAL]

.REPEAT 1 - KL [
APRCO:	D[CONST 1] ROT[3] ALU[-D&Q] DEST[AR] SHORT $
	D[IR] ROT[43] MASK[21] ALU[NOTD] DEST[Q] SHORT $
		; GET CLR BITS
	D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
		; Remove PI assignment
	D[10 + APRSTS] SPEC[A-MEM-APR] ALU[D&Q] DEST[Q CLR-DEV-FROM-INTR] SHORT $
		; CLEAR INDICATED BITS
	D[AR] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS AR] NORM $
		; SET INDICATED BITS & CHAN
	D[IR] ROT[41] MASK[1] COND[OBUS=0] JUMP[APRCO2] C550 $
		; J IF NO CLR OVERFLOW BIT
	D[PC] MASK[43] DEST[CRYOV] SHORT $; CLR OV
		; Remove overflow bit from current PC flags
APRCO2:	D[IR] ROT[36] MASK[1] COND[OBUS=0] JUMP[APRCO3] C550 $
		; J IF NO CLR FLT OV
	D[MASK 43] ROT[41] DEST[Q] SHORT $
		; Remove bit from current PC flags
	D[PC] ALU[D&Q] DEST[CRYOV] SHORT $
		; CLR FLT OV
APRCO3:	D[IR] ROT[33] MASK[1] COND[-OBUS=0] PUSHJ[CLKCLR] C550 $
		; CLR CLOCK FLAG IF INDICATED
;	---

; TEMP **** APRCI:
APRIEN:	PUSHJ[APRCII] DEST[CLR-DEV-FROM-INTR] NORM $
		; GET APR CONI BITS
	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
		; Select and read MAP and ECC enablings
	D[IOD] MAPF[4] MASK[3] DEST[Q] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
		; For some pecular reason, the thing we read from device 1 is
		; written in device 0???
	D[AR] MASK[3] COND[OBUS=0] JUMP[APRC1] C550 $
		; Jump if no PI channel.  We don't want to enable arithmetic
		; micro-interrupts in that case.
	D[AR] ROT[40] MASK[1] COND[OBUS=0] JUMP[APRC1] C550 $
		; J IF NO OV INT ENBL
		; *** Don't both enables need to be checked???
	D[CONST 2] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] JUMP[APRC2] NORM $; ENABLE OV INT
		; Turn on arithmetic interrupts
APRC1:	D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
		; Turn off arithmetic interrupts
APRC2:	MAPF[10] CYLEN[IOB-OUT] D[AR] DEST[Q] JUMP[APRCK1] $
		; Finish turning arithmetic interrupts off or on, and we're done

];.REPEAT 1 - KL
.REPEAT KL [
APRCO:	D[10 + APRSTS] A-MEM-APR DEST[Q CLR-DEV-FROM-INTR] SHORT $
	 ;GET CONI WORD
	D[CONST 7] ALU[-D&Q] DEST[Q] NORM $
		;CLEAR OUT OLD PI ASSIGNMENT
	D[IR] MASK[3] ALU[DORQ] DEST[Q] NORM $
	 ;PUT IN NEW PI ASSIGNMENT
	D[IR] ROT[36. - 4.] MASK[8.] DEST[AR] NORM$
	 ;GET BITS WE WILL SET/CLEAR/ENABLE/DISABLE
	D[IR] ROT[20.] -OBUS<0 C550 JUMP[APRCO1] $
	 ;JUMP IF NOT ENABLING SELECTED BITS
	D[AR] ROT[18. + 4.] ALU[DORQ] DEST[Q] NORM $
	 ;SET ENABLE BITS (IN LH OF CONI WORD)
APRCO1:	D[IR] ROT[21.] -OBUS<0 C550 JUMP[APRCO2] $
	 ;JUMP IF NOT DISABLING SELECTED BITS
	D[AR] ROT[18. + 4.] ALU[-D&Q] DEST[Q] NORM $
	 ;CLEAR INDICATED ENABLE FLAGS (DISABLE)
APRCO2:	D[IR] ROT[23.] -OBUS<0 C550 JUMP[APRCO3] $
	 ;JUMP IF NOT SETTING FLAGS THEMSELVES
	D[AR] ROT[4.] ALU[DORQ] DEST[Q] NORM $
	 ;SET BITS HE WANTS SET
APRCO3:	D[IR] ROT[22.] -OBUS<0 C550 JUMP[APRCO4] $
	 ;JUMP IF NOT CLEARING SELECTED FLAGS
	D[AR] ROT[4.] ALU[-D&Q] DEST[Q APRSTS] A-MEM-APR&DEST-A-MEM NORM $
	 ;CLEAR THEM AND STORE RESULT INTO AMEM IN CASE HAVE TO CALL CLKCLR
	D[AR] ROT[4. + 13. + 18.] OBUS<0 C550 PUSHJ[CLKCLR] $
	JUMP[APRCHK] SHORT $
APRCO4:	ALU[Q] A-MEM-APR&DEST-A-MEM DEST[APRSTS] JUMP[APRCHK] NORM $
	 ;STORE FINAL RESULT INTO AMEM[2]
	 ;AND GO TO APRCHK TO SEE IF NEED TO INTERRUPT NOW
];.REPEAT KL
;Check for clock interrupts (and other things)
APRCHK:	PUSHJ[APRCI] NORM $; GET CONI BITS IN AR & Q

APRCK1:
.REPEAT 1 - WAITS [
	D[AR] MASK[3] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF PI=0
.REPEAT 1 - KL [
	D[AR] ROT[20] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF PDLOV INT
	D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $; AND MASK WITH FLAG
	D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF OV INT
	D[CONST 10] ROT[6] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF NO CLOCK INT
];.REPEAT 1 - KL
.REPEAT KL [
	D[AR] ROT[32.] -OBUS<0 JUMP[UINT-DISMISS] C550 $	;DONE IF INTERRUPT REQUEST FLAG NOT SET
];.REPEAT KL
;	\ /
];.REPEAT 1 - WAITS
.REPEAT WAITS [
	D[AR] ROT[27.] COND[OBUS<0] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
		;If no APR interrupt is not requested, don't interrupt.
		;Otherwise, fall thru
];.REPEAT WAITS

;	\ /	(Falls thru from APRCK1)
APDINT:	D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; GET CHAN #, CAUSE INTERRUPT

.REPEAT 1 - KL [
APRCI:	;TEMP -- LATER WE FIX OV
APRCII:	PUSHJ[CLKRDFLG] NORM $
	 ;Get CLOCK FLAG in AR 35, rest of AR = 0
	.DEFINE APRGBT [R1 R2]
[	D[PC] ROT[R1] MASK[1] DEST[Q] SHORT $
	D[AR] ROT[R2] ALU[DORQ] DEST[AR] SHORT $
]
	APRGBT[1 6]
	APRGBT[4 41]
	APRGBT[7 33]
	D[AR] ROT[17] DEST[Q] SHORT $; SET FLAGS
.REPEAT 1 - WAITS [
	D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM POPJ $
];.REPEAT 1 - WAITS

.REPEAT WAITS [
;SAIL's KA-10 has a processor modification which sets bit 27 (400 bit) if the
;APR is NOT interrupting.  This feature is used in a CONSZ chain and would
;consume many instructions to simulate in a critical path in the system.
	D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM $
		;Construct full status
	D[AR] MASK[3] COND[OBUS=0] JUMP[APRCIN] NORM $
		;Set 400 bit if interrupts disabled 
		;(This may not be the same as SAIL)
	D[AR] ROT[20] MASK[1] COND[-OBUS=0] POPJ C550 $
		;If pushdown overflow, we will interrupt.
	D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $
		;Combine flag with enable to see which interrupts
	D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APRCIY] C550 $
		;Jump if overflow is causing an interrupt.
	D[CONST 10] ROT[6] ALU[D&Q] COND[-OBUS=0] JUMP[APRCIY] C550 $
		;Jump if clock is causing an interrupt.
APRCIN:	D[CONST 4] ROT[6] DEST[Q] SHORT $
		;Not interrupting, set 400 bit in APR status
APRCIY:	D[AR] ALU[DORQ] DEST[AR Q] POPJ NORM $
		;Turn on 400 bit if needed.
		;Note, that since we ANDed something with Q, ORing in Q is
		;a NO-OP if we didn't go thru APRCIN.
];.REPEAT WAITS
];.REPEAT 1 - KL
.REPEAT KL [;IF KL FORMAT APR CONI WORD

APRCII:
APRCI:	PUSHJ[CLKRDFLG] NORM 		$;GET CLK FLG IN AR35, REST IS 0
	D[10 + APRSTS] A-MEM-APR DEST[Q] NORM $	;GET APR CONI WORD IN Q
	D[AR] ROT[35. - 31.] ALU[DORQ] DEST[Q AR] NORM $
	 ;OR CLOCK FLAG (1B31) INTO APR CONI WORD
	D[AR] ROT[18.] MASK[18.] ALU[D&Q] OBUS=0 C550 POPJ $
	 ;IF NOT ENABLED FOR ANY FLAGS THAT ARE TRYING TO INTERRUPT, DON'T SET IRP REQUEST
	D[CONST 1] ROT[35. - 32.] ALU[DORQ] DEST[Q AR] POPJ NORM $
	 ;A FLAG CURRENTLY ENABLED IS SET, SET IRP REQUEST.
];.REPEAT KL

APRDI:	MAPF[2] D[IOD] DEST[MEMSTO] COND[-MA-AC] LBJUMP[MSMAIN] CYLEN[IOB-IN] $

	.PAIR
	UIOTRP[MUUO] $			;Trap if not IOT-USER Mode
APIOT:	IOTDIS[APRIOTDISP-ORGARG]




;PDLO1 PDLO2 PDLO5 PDLO3 PDLO4 PDLO6 PDLMEM PDLOE PDLO SOED STOPS SOVRS SECCS SOEDOV

.REPEAT 1 - KL [
PDLO1:	PUSHJ[PDLO] NORM $ ;SET PDLO BIT
	D[PC] DEST[AR MEMSTO] NORM $
	MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
PDLO2:	PUSHJ[PDLO] NORM $; SET FLAG
PDLO5:	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
PDLO3:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	D[MEM] DEST[AR] PUSHJ[PDLO] NORM $
	D[IR] MASK[18.] DEST[MA] JUMP[PDLO5] NORM $
PDLO4:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	PUSHJ[PDLO] NORM $
	D[MEM] MASK[18.] DEST[PC] JUMP[PDLOE] NORM $
;PDLOV from ADJSP
PDLO6:	PUSHJ[PDLO] NORM $
	JUMP[PDLOE] NORM $

	.PAIR
PDLMEM:	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] MAPF[MASTO] $
PDLOE:	MAPF[MASTO] D[10 + APRSTS] MASK[3] DEST[AR] SPEC[A-MEM-APR]
	JUMP[PIGEN] NORM $; CHAN # IN AR, TRY INTERRUPT

PDLO:	D[10 + APRSTS] SPEC[A-MEM-APR] DEST[Q] NORM $; APR CONI WORD
	D[CONST 1] ROT[20] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS]
			NORM POPJ $
		;SET PDLOV BIT
];.REPEAT 1 - KL
.REPEAT KL [
;PDLOV FROM PUSHJ GETS HERE
PDLO1:	D[PC] DEST[AR Q MEMSTO] COND[HALF] JUMP[PDLO1H] NORM $
		;STORE PC ON STACK, JUMP IF HALF FLAG ON
PDLO1A:	MAPF[PPOP] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
PDLO1H:	MAPF[PPOP] D[10 + APRSTS] SPEC[A-MEM-APR] ROT[3] COND[OBUS<0] C550 JUMP[PDLO1A] $
		;JUST SET PC IF FPD ON IN AMEM.
	D[CONST 1] ROT[35. - 4.] ALU[-D&Q] DEST[MEMSTO] JUMP[PDLO1A] NORM $
		;STORE PC WITH FPD OFF.


;PDLOV FROM POP GETS HERE
PDLO3:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	D[MEM] DEST[AR] NORM $
	D[IR] MASK[18.] DEST[MA] NORM $

;PDLOV ON PUSH
PDLO5:
PDLO2:	D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PDLMEM] NORM $

;PDLOV FROM POPJ GETS HERE
PDLO4:	ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
	D[MEM] MASK[18.] DEST[PC] JUMP[PDLOE] NORM $

;PDLOV from ADJSP

	.PAIR
PDLMEM:	ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] MAPF[PPOP] $

PDLO6:	;PDLOV FROM ADJSP
PDLOE:	MAPF[PPOP] D[CONST 2] DEST[AR] JUMP[DOTRPX] NORM $
		;DO A TRAP 2 (PDL OVERFLOW)

];.REPEAT KL

	.USE[AREA53]

.REPEAT F3SW [

SOED:	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
	D[CONST 1] ROT[25] ALU[D&Q] COND[OBUS=0] JUMP[DOHALT] C600 $
	D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] C550 $; J IF NO OV
	D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
	D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN

	D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
.REPEAT 1 - XUCODE [
	D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
];.REPEAT 1 - XUCODE
.REPEAT XUCODE [
	D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
];.REPEAT XUCODE
  	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
	D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $

	ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
	D[MEM] DEST[Q] NORM $
	D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
	D[AR] ALU[D+1] DEST[ECCSVP] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	SPEC[IOB-IN] D[CONST 1] DEST[DEV-ADR] NORM $
	 ;NOW READ STATE OF MAP ON, OV ENBL, ETC.
	D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
	 ;PRESERVE IN IR.
	ALU[0] DEST[DEV-ADR] SHORT $
;;;  	D[IR] ROT[31.] COND[OBUS<0] PUSHJ[ECC-UNC] C550 $
	 ;IF ERROR WAS UNCORRECTABLE, GO SEE ABOUT INTERRUPTING.
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
	MAPF[2] D[MEM] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
	MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
	D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
	CYLEN[C500] $;WAIT
	D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
	NORM $; WAIT -- FOR LUCK
	D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
	 MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
	DEST[CLR-MI-ERR] JUMP[UINT-DISMISS] $  ;CLEAR THE ERROR FLIPFLOP

  ]  ;; END OF .REPEAT F3SW

;(ECC-UNC moved to bottom of page)

 .REPEAT F2SW [ 

STOPS:	D[CONST 1] DEST[DEV-ADR] JUMP[DOHALT] NORM $

SOVRS:	D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] DEST[CLR-DEV-FROM-INTR] C550 $
		; J IF NO OV
	D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
	D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
	JUMP[.] $ ; HOW COULD WE GET HERE?

SECCS:	D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
	D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
	D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
.REPEAT 1 - XUCODE [
	D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
];.REPEAT 1 - XUCODE
.REPEAT XUCODE [
	D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
	  NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
];.REPEAT XUCODE
  	MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
 ;;;;;	D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $

	ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
	D[MEM] DEST[Q] NORM $
	D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
	D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
	D[CONST 1] DEST[DEV-ADR] NORM $
	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
	D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
	ALU[0] DEST[DEV-ADR] SHORT $
;NOTE:	This conflicts with the use of the lights by diagnostics.
	ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
	MAPF[2] ALU[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
	MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
	ALU[Q] DEST[A-MEM-ECC-DATA] DEST-A-MEM NORM $
	  ;Save info for reading via opcode 750.  
	D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
	CYLEN[C500] $;WAIT
	D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
	NORM $; WAIT -- FOR LUCK
	D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
	 MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
	DEST[CLR-MI-ERR] JUMP[UINT-DISMISS] NORM $

  ] ;; END OF .REPEAT F2SW

;$*$*$*$ No space left in AREA53  by now...
	.USE[OTHER]

SOEDOV:	ALU[0] DEST[DEV-ADR] NORM $
.REPEAT 1 - KL [
	D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
	MAPF[10] CYLEN[IOB-OUT] PUSHJ[APRCII] $; GET CONI BITS
	D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; DO INTR.
];.REPEAT 1 - KL
.REPEAT KL [
	D[PC] MASK[35.] DEST[CRYOV] NORM $
		;TURN OFF OVERFLOW BIT IN REAL PC WORD SO WE DONT TRAP AGAIN.
	D[12] SPEC[A-MEM-APR] DEST[Q] NORM $
		;GET AMEM LOC WITH FAKE OVERFLOW BIT IN IT
	D[CONST 1] ROT[35. - 4] ALU[DORQ] DEST[2] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
		;SET FAKE OVERFLOW IN AMEM.
	 D[CONST 1] DEST[AR] JUMP[DOTRPX] SHORT $
		;OVERFLOW, MUST DO TRAP INSTRUCTION
];.REPEAT KL



ECC-UNC:  ;SEE IF WE SHOULD GIVE INTERRUPT FOR HARD ECC ERR
	  ;RETURN TO CALLER IF NOT, BUT STILL SET PAR ERR FLAG.
.REPEAT 1 - KL [
	D[14] DEST[Q] NORM $
	 ;FIRST, SET PAR ERR FLAG IN PI CONI BITS.
	D[CONST 1] ROT[35. - 19.] ALU[DORQ] 
		DEST[AR 4] DEST-A-MEM NORM $
	D[AR] ROT[35. - 20.] C550 COND[-OBUS<0] POPJ $
	 ;IF PAR ERR INTRPT ENABLE OFF, DO NO MORE.
	D[10 + APRSTS] MASK[3] DEST[Q AR] C550 COND[OBUS=0] POPJ $
	 ;IF APR PI CHAN IS 0, DON'T GIVE INTRPT.
];.REPEAT 1 - KL
.REPEAT KL [;MUST CHECK APR CONI WORD ON KL STYLE MACHINE
	D[10 + APRSTS] DEST[Q] NORM $
	D[CONST 4] ROT[6] ALU[DORQ] DEST[AR Q 4] DEST-A-MEM PUSHJ[APRCI]NORM$
	 ;SET PARITY ERROR 1B27, AND GET CONI IN AR AND Q
	D[AR] MASK[3] C550 OBUS=0 POPJ $	;IF NO PI ASSIGNMENT, FINISHED.
	D[AR] ROT[32.] -OBUS<0 C550 POPJ $
	 ;IF IRP REQUEST NOT ON, JUST RETURN.
];.REPEAT KL
	DEST[CLR-MI-ERR] NORM JPOP[PIGEN] $ 
	 ;CLEAR ERR FF AND GIVE INTERRUPT ON APR CHANNEL.




;; 60 HZ CLOCK READING AND INTERRUPT ROUTINES

 .REPEAT OTP [
  .ORG[2134]		;INTRPT LOC. FOR DEV. 5
CLKINT:	NORM PUSHJ[CLRDEVINT] $ ;Enable addressing of other devices.
	D[CONST 1] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
		;Clear hdwr int. enable for 60HZ clk.
    ]  ;OTP


 .REPEAT NTP [ ;We branch here from CTYINT if intrpt. is really 60HZ CLK.

CLKINT:	START-OUT ALU[0] DEST[IOD] NORM $
	  ;Clear hardware int. enb. for 60HZ CLK.
	MAPF[6] C600 $
  ] ;NTP

.REPEAT TYMNET [
	DEST[CLR-DEV-FROM-INTR] PUSHJ[TYMCLK] C600 $
	  ;Start up TYMNET interface if needed.
];TYMNET
	DEST[CLR-DEV-FROM-INTR] JUMP[APRCHK] C600 $ 	
	  ;Cause PI on APR channel if enabled, and exit.

CLKRDFLG:  ;Put hardware 60HZ CLK FLAG into AR35.
	START-IN D[CONST 6] DEST[DEV-ADR] NORM $
	  ;Select device 6.
	MAPF[5] D[IOD] ROT[34. + 1] MASK[1] DEST[AR] CYLEN[IOB-IN] POPJ $
	  ;Get bit and return.




.REPEAT NTP [ ;Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
.REPEAT 1 - TAPE [
.INSERT CFKNYD.SLO
];.REPEAT 1 - TAPE
.REPEAT TAPE [ ;NEW (DMA TAPE CONTROLLER, PERTEC COMPATIBLE FMTR )
.INSERT TAPE.SLO
];.REPEAT TAPE
  ] ;NTP



.REPEAT KNYTAPE [ ;KENNEDY TAPE CONTROL UCODE
.INSERT CFKNYP.SLO
 ] ;ENDX OF KENNEDY TAPE CODE



.REPEAT TLXTAPE [ ;TELEX TAPE CONTROL UCODE
.INSERT CFTLX.SLO
] ;ENDX OF TELEX TAPE CODE



.REPEAT SLOWTAPE [ ;UCODE FOR BARE 800 BPI TAPE DRIVE
.INSERT CFBARE.SLO
   ] ;END OF SLOW TAPE CODE



.REPEAT 125TAPE [ ;UCODE FOR BARE 800 BPI, 125 IPS TAPE DRIVE
.INSERT CFB125.SLO
] ;END OF SLOW 125 IPS TAPE CODE



;TAPE DISPATCH

 .REPEAT 1 - XUCODE [ ;If we have extended ucode memory, these are different.

.OPCODE[725]	;TAPE IOTS

;725 - Obsolete version of read (no word count, E = core address.)
	D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPERD] $
	 NOP $
;726 - MTAPE
	D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPEMT] $	
	 NOP $
;727 - READ STATUS
	D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPERS] $	
	 NOP $
;730 - READ 1 RECORD, STORE UP TO (AC) WORDS STARTING E.
	D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPENR] $
	 NOP $
;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
	D[CONST 7] DEST[DEV-ADR] NORM COND[USER] JUMP[UTAPWR] $
	 NORM JUMP[TAPEWR] $
;732 - READ 1 record, store up to E words starting at (AC).
	D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPERX] $
	 NOP $
  ] ;1 - XUCODE


 .REPEAT XUCODE [ ;If we don't have extended ucode memory, these are different.

.OPCODE[725]	;TAPE IOTS

;725 - Obsolete version of read (no word count, E = core address.)
	GETADR[TAPERD] JUMP[TAPDSP] $
;726 - MTAPE
	GETADR[TAPEMT] JUMP[TAPDSP] $
;727 - READ STATUS
	GETADR[TAPERS] JUMP[TAPDSP] $
;730 - OBSOLETE ! --read 1 record, store up to (AC) words starting at E.
	GETADR[TAPENR] JUMP[TAPDSP] $
;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
	GETADR[TAPEWR] JUMP[TAPDSP] $
;732 - READ 1 record, store up to E words starting at (AC).
	GETADR[TAPERX] JUMP[TAPDSP] $

  ] ;XUCODE

.RELOC

TAPDSP:	D[CONST 7] DEST[DEV-ADR] COND[-USER] JUMP[GOHIGH] $
	 ;Load device code for tape, test for user mode.
	UIOTRP[MUUO] $
	 ;In user mode-- trap unless IOT USER

GOHIGH:	 ;Jump into high part of umemory, using 12-bit addr. in Q
	D[CONST (XUCODE * 10) + 2] ROT[9.] ALU[D+1] C600 SDISP $
	  ;This takes us to loc. 2001 and pre-sets the 10000 bit.
 .ORG[2001]
	D[CONST XUCODE] ROT[12.] ALU[DORQ] SDISP $
	  ;This finally takes us to loc. 10000+[Q] 

 .RELOC

  .REPEAT XUCODE [
.USE[HIGHMEM] $
     ]

 .PAIR
HIGHSMAIN:
	D[MEM] ACSEL[MA] DEST[AC] NORM JUMP[GOMAIN] $
	NORM JUMP[GOMAIN] $

GOMAIN:	GETADR[MAIN]  $	;Do extended mode jump to MAIN.

GOLOW:	 ;Jump to loc. in lower 4K indicated by contents of Q.

   .REPEAT XUCODE [
	ALU[0] C600 SDISP $
	 ;This goes to loc. 10000 and pre-clears the 10000 bit.
 .ORG[10000]
   ] ;XUCODE

	C600 ALU[Q] SDISP $
	 ;Now we actually go to low u-mem.

.USE[OTHER]






;------------------------------------------------------------------------------
;
;	FooVision
;
;------------------------------------------------------------------------------
.REPEAT VID [
.INSERT VID.SLO
];VID
	.OPCODE[766]
.REPEAT ((1 - VID) * (773 - 766 + 1)) [
	ILGIOT $			;OPS 766:773
	NOP $
];1-VID
.REPEAT VID [
	ILGIOT $			;OP 766 = illegal (reserved)
	NOP $
	GETADR[VIDDPA] JUMP[GOHIGH]$	;OP 767 = DPYADD
					;Note: GETADR expands to 2 words
	FIXM2$				;OP 770 = VIDIN
	D[CONST 36] DEST[DEV-ADR] JUMP[VIDIN]$
	FIXM1$				;OP 771 = VIDOUT
	D[CONST 36] DEST[DEV-ADR] JUMP[VIDOUT]$
	GETADR[VIDDPI] JUMP[GOHIGH]$	;OP 772 = DPYINI
					;Note: GETADR expands to 2 words
	GETADR[VIDDPO] JUMP[GOHIGH]$	;OP 773 = DPYOUT
					;Note: GETADR expands to 2 words
];VID
	.RELOC





;FLOATING POINT, KA10 STYLE.
;NONDISPATCH CODE.
.DEFINE CFPLOW[] [D[AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]
.DEFINE JINSEXP[] [D[AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]
.DEFINE CINSEXP[] [D[AR] ROT[27.] DEST[Q] PUSHJ[INSEX1] NORM ]
.DEFINE CFDS[] [D[MEM] ALU[D#AC] DEST[AR] PUSHJ[FDS1] NORM]

;***** DON'T USE A-MEM 0 FOR ANYTHING BESIDES DISPATCHES!!!	TVR-Sep80  *****
;***** This must be fixed!!!!					TVR-Sep80  *****
UFA1:	ALU[AC] DEST[0 AR] DEST-A-MEM PUSHJ[FADSUB] NORM $
	D[10] DEST[AR O_AC] SHORT $
	D[AR] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] $

	.PAIR	;: 6460		;.PAIR
DFN1:	ALU[NOTAC] DEST[AC] JUMP[. + 2] NORM $
	ALU[0-AC] DEST[AC] SHORT $
	D[MEM] DEST[Q] SHORT $
	D[MASK 9] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
	D[AR] MASK[27.] ALU[DORQ] DEST[MEMSTO] MEMSTMA $

FSCZAP:	ALU[0] DEST[MA AC] SPEC[MA_PC] JUMP[MAIN1] NORM $
FSC1:	D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
	D[MASK 8] ROT[27.] ALU[-D&AC] DEST[AC] COND[-OBUS<0] JUMP[FSC2] C550 $
	D[MASK 9] ALU[D#Q] DEST[Q AR] SHORT $
	D[MASK 8] ROT[27.] ALU[DORAC] DEST[AC] SHORT $
FSC2:	D[MA] MASK[18.] ALU[D+Q] DEST[IR-ADR] SHORT $
	ALU[0] DEST[Q] PUSHJ[NRMLIZ] NORM $
	CINSEXP $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

FAOS1:
FAOS5:
	ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
FAOS2:	ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	CFPLOW $
FAOS3:	ALU[AC] DEST[AR] NORM $
	D[CONST 11] DEST[DEV-ADR] SHORT $
	ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FADSUB] NORM $
	D[10] DEST[MEMSTO O_AC] MEMST $
FAOS4:	ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
	ALU[AC] DEST[MEMSTO] MEMST $

FMP1:
FMP5:
	ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
FMP2:	ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	CFPLOW $
FMP3:	ALU[AC] DEST[AR] NORM $
	D[CONST 11] DEST[DEV-ADR] SHORT $
	ALU[AC] DEST-A-MEM PUSHJ[FM] DEST[0] NORM $
	D[10] DEST[MEMSTO O_AC] MEMST $
FMP4:	ALU[AC] DEST[AR] PUSHJ[FM] NORM $
	ALU[AC] DEST[MEMSTO] MEMST $

;Macro to test for divide by zero
.DEFINE DIVTST[] [D[MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]

;;;FD5:	D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $	;Not needed.  TVR-Apr80

;FDV,FDVR
FD1:	DIVTST $	;Check for divide by zero
	CFDS $
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

;------------------------------------------------------------------------------
;LONG MODE FLOATING DIVIDE.
;------------------------------------------------------------------------------
FD2:	DIVTST $
 ;AR.0,IR.35:=XOR(DIVIDEND SIGN,DIVISOR SIGN).
	D[MEM] ALU[D#AC] DEST[AR] SHORT $
	D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
 ;Flush sign & exponent from Dividend Low
	D[MASK 27.] ALU[D&AC] ACSEL[AC+1] DEST[AR] SHORT $
	D[AR] ROT[9] DEST[AC] ACSEL[AC+1] SHORT $
 ;Positive form of Dividend to AC, AR; original form to AMEM[1]
	ALU[AC] DEST[AR 1] DEST-A-MEM COND[-OBUS<0] JUMP[FD2A] CYLEN[C450] $
	ALU[0-AC] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[. + 2] C550 $
	ALU[NOTAC] DEST[AC AR] JUMP[. + 2] SHORT $
	ALU[0-AC] DEST[AC AR] NORM $
FD2A:	D[CONST 1] ROT[27.] ALU[AC+D] DEST[AR] NORM $
	 ;Add 1 to exp. of dividend, since we will do only a 27-bit divide.
	ALU[AC] ACSEL[AC+1] DEST[6] DEST-A-MEM NORM $
	 ;Put low-order mantissa in AMEM[6] for FD.
	D[CONST 27.] LLOAD NORM $ 
	 ;Do only a 27-bit divide, so remainder will come out right.
	PUSHJ[FD] NORM $	
	 ;Perform the divide (returns: AC=quotient, AMEM[6]=remainder)
 ;AC+1 gets 0 if remainder = 0.
	D[16] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[FD2D] C550 $
 ;Calculate exponent of remainder.
	D[11]  DEST[Q] C550 -OBUS<0 JUMP[. + 3] $
	 ;Check sign of dividend, jump if positive.
	 ALU[0-Q] DEST[1] DEST-A-MEM NORM $
	  ;Negate the dividend (so the exponent will be in pos. form)
	 ACSEL[AC+1] ALU[0-AC] DEST[AC] NORM $
	  ;Negate the remainder.
	D[11] ROT[9.] MASK[8] DEST[Q] NORM $
	 ;Recover exp. of dividend.
 ;A-MEM[7] has (dividend HOW)-(divisor).
	D[17] COND[-OBUS<0] JUMP[. + 2] C550 $
	 D[CONST 1] ALU[Q-D] DEST[Q] SHORT $
	D[CONST 26.] ALU[Q-D] DEST[Q] COND[OBUS18] JUMP[FD2C] C600 $
	 ;Jump if exponent underflow.
.DEFINE SWAPAC[] [ ;Interchange (AC) and (AC+1)
	ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
	D[AR] DEST[AR O_AC] SHORT $
	D[AR] ACSEL[AC+1] DEST[AC] SHORT $
  ]

 ;SWAP QUOTIENT (AC) AND REMAINDER (AC+1)
	SWAPAC
 ;INSERT EXPONENT INTO REMAINDER.
	ALU[Q] DEST[AR] PUSHJ[INSEXP] NORM $
	SWAPAC
FD2D:	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

FD2C:	ALU[0] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $

FD3:	DIVTST $
	ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FDS] NORM $
	D[10] DEST[MEMSTO O_AC] MEMST $
FD4:	DIVTST $
	CFDS $
	ALU[AC] DEST[MEMSTO] MEMST $

;HERE ON DIVISOR=0.  SET NO DIVIDE, OVF,FLOV,RETURN.
FPNDIV:	D[PC] DEST[Q] SHORT $
	D[CONST 1] ROT[23.] ALU[DORQ] DEST[Q] PUSHJ[SETFOV] NORM $
	DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

;------------------------------------------------------------------------------
;NORMALIZE DOUBLE PRECISION NUMBER IN AC,Q WHOSE EXPONENT
; IS IN IR-ADR.  LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.
; IF NUMBER IS 0, LEAVE 0 IN AR,AC, AND Q.
;------------------------------------------------------------------------------
.DEFINE CNORM[] [D[AR] DEST[AC] PUSHJ[NRMLIZ] NORM]

;A. Return immediately if 0.
NRMLIZ:	ALU[QORAC] DEST[AR] COND[OBUS=0] POPJ C550 $
;B. Check for mantissa overflow, move exponent to AR.
	ALU[AC] DEST[AR] PUSHJ[NORMOV] NORM $
		;Check mantissa and shift right if necessary
	D[IR] MASK[18.] COND[-OBUS=0] POPJ C550 $
		;If we adjusted right, then we definitely don't have to
		;shift left.  We're done here.
;C. Left shift until normalized.
	ALU[AC] COND[OBUS<0] JUMP[NEGNOR] CYLEN[C450] $
		;Separate into two cases, positive and negative
POSNOR:	D[CONST 1] ROT[26.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
		;If high order bit of mantissa is one, we're done
	D[AR] ALU[D-1] DEST[AR] SHORT $
		;Decrement the exponent
	ALU[SH-AC] MASK[2] DEST[D6] JUMP[POSNOR] NORM $
		;Shift left and try again.
NEGNOR:	D[CONST 1] ROT[26.] ALU[D&AC] COND[OBUS=0] JUMP[NN1] C550 $
		;If high order bit of mantissa is zero, we're done
	D[AR] ALU[D-1] DEST[AR] SHORT $
		;Decrement the exponent
	ALU[SH-AC] MASK[2] DEST[D6] JUMP[NEGNOR] NORM $
		;Shift left and try again.
NN1:	D[MASK 27.] ALU[D&AC] COND[-OBUS=0] POPJ C550 $
		;Check for case of exactly -(2^n).  If it isn't, we're done
	D[CONST 1] ROT[26.] ALU[DORAC] DEST[AC] SHORT $
		;We went one too far, backup by simply OR'ing in the relevant
		;bit in the same manner as shifting would. 
		;(*** What about Q??  TVR-Jul80)
	D[AR] ALU[D+1] DEST[AR] POPJ NORM $
		;Increment exponent to account for simulated left shift.

;------------------------------------------------------------------------------
;CHECK FOR MANTISSA OVERFLOW INTO EXPONENT FIELD.  CALL WITH
; AR&AC,Q: # TO NORMALIZE, IR-ADR: ITS EXPONENT.
; LEAVE EXPONENT IN AR.  SET IR-ADR=0 IF NO OVERFLOW.  SET IR-ADR<>0
; IF OVERFLOW, AND NORMALIZE.
;
;M.O. <=> [AR0<>AR8] OR [(AR8=1) AND (AR9-35=0)]
;------------------------------------------------------------------------------
NORMOV:	D[AR] ROT[8] ALU[D#AC] COND[OBUS<0] JUMP[NOVYES] C550 $
		;Check to make sure AR<0>=AR<8>.  If they don't, the mantissa
		;clearly overlaps the exponent field.
	D[MASK 27.] ALU[D&AC] COND[-OBUS=0] JUMP[NOVNO] C550 $
		;Check for AR<9:35> for zero.  If not zero, we're OK
	D[CONST 1] ROT[27.] ALU[D&AC] COND[OBUS=0] JUMP[NOVNO] C550 $
		;Check AR<8>.  If zero, we're OK
;	\ /
;Mantissa has overflowed, adjust it.  Right by one should be enough.
NOVYES:	ALU[SH-AC] MASK[1] DEST[D4] SHORT $
		;Shift mantissa right (i think?)
	D[IR] MASK[18.] ALU[D+1] DEST[AR IR-ADR] POPJ NORM $
		;Increment mantissa and flag that we changed it by setting
		;IR<18:35> to be non-zero.

;Mantissa has not overflowed.
NOVNO:	D[IR] MASK[18.] DEST[AR] SHORT $
		;Save exponent in AR
	ALU[0] DEST[IR-ADR] POPJ NORM $
		;Zero IR<18:35> to signify success

;------------------------------------------------------------------------------
;INSERT EXPONENT IN AR INTO WORD IN AC.
;SET FLOV,FLUN,OVF FLAGS AS REQUIRED.
;PRESERVES AR, CLOBBERS Q.
;------------------------------------------------------------------------------
INSEXP:	D[AR] ROT[27.] DEST[Q] NORM $
		;Move exponent into position
INSEX1:	D[MASK 8.] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
		;Flush stuff in mantissa area
	ALU[Q#AC] DEST[AC] SHORT $
		;Fill in exponent (complementing it if (AC) is negative !)
	D[AR] COND[OBUS18] JUMP[EXPUF] C550 $
		;Check for underflow (i.e. below range of exponent offset)
	D[AR] MASK[10.] ROT[28.] COND[OBUS=0] POPJ C550 $
		;Check for overflow (i.e. above range of exponent offset)
	D[PC] DEST[Q] SHORT $
		;Setup to set floating overflow
SETFOV:	D[CONST 11] ROT[32.] ALU[DORQ] DEST[CRYOV] POPJ NORM $
		;Turn on overflow and floating overflow
EXPUF:	D[PC] DEST[Q] SHORT $
		;Setup to set no divide and floating overflow
	D[CONST 1] ROT[24.] ALU[DORQ] DEST[Q] JUMP[SETFOV] NORM$
		;Turn on no divide, then do overflows

;------------------------------------------------------------------------------
;FLOATING ADD AC&AR TO MEM.  RESULT, NORMALIZED AND ROUNDED
; IF REQUIRED IN AC,Q.
;------------------------------------------------------------------------------
.DEFINE BLEXPS[DES1 TIME DES2] [
	D[MASK 8] ROT[27.] ALU[DORAC] DEST[DES2] COND[OBUS<0] JUMP[. + 2] C550 $
	D[MASK 8] ROT[27.] ALU[-D&AC] DEST[DES2] SHORT $
	D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
	D[MASK 8] ROT[27.] ALU[-D&Q] DEST[DES1] JUMP[. + 2] NORM $
	D[MASK 8] ROT[27.] ALU[DORQ] DEST[DES1] CYLEN[TIME] $
];BLEXPS
	;A. + FORM EXPONENT OF AC,MEM RTO AR,Q RESP.
FADSUB:	D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
FADSU1:	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS1] C550 $
	D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
FS1:	D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS2] C550 $
	D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
	;B. COMPUTE DIFFERENCE, SWAP OPRANDS IF AC HAS LARGER EXP.
	;   LEAVE + DIFFERENCE IN Q, DIFF -1 IN LOOP CTR.
	;   LEAVE LARGER EXPONENT IN IR-ADR.
FS2:	ALU[Q] DEST[IR-ADR] SHORT $
	D[AR] ALU[Q-D] DEST[Q] COND[-OBUS<0] JUMP[FS3] C600 $
	D[AR] DEST[IR-ADR] SHORT $
	D[MEM] DEST[HOLD O_AC] NORM $
	ALU[0-Q] DEST[Q] NORM $
FS3:	ALU[Q-1] DEST[AR] LLOAD NORM $
	;C. BLANK EXPONENTS.
	BLEXPS[HOLD NORM AC]
	;D. IF DELTA EXPONENTS >62., AC GOES TO OBLIVION.
	D[AR] ALU[D+1] DEST[Q] COND[OBUS=0] JUMP[FS5] C600 $
	D[CONST 63.] ALU[Q-D] COND[OBUS<0] JUMP[FS4] C600 $
	ALU[0] DEST[AC] SHORT $
	ALU[0] DEST[Q] JUMP[FS5] NORM $
FS4:	ALU[0] DEST[Q] SHORT $
	ALU[SH-AC] DEST[D4] MASK[1] LOOP [.] NORM $
	;E. ADD.
FS5:	D[MEM] ALU[D+AC] DEST[AR] SHORT $
	;F. NORMALIZE RESULT.
	D[IR] DEST[AC] SHORT $	;CHECK FOR UFA
	D[CONST 1] ROT[40] ALU[D&AC] COND[OBUS=0] JUMP[UFANOR] C550 $

;------------------------------------------------------------------------------
;ENTER HERE WITH RESULT IN AR,Q, EXP IN IR-ADR.
;------------------------------------------------------------------------------
FPNAR:	CNORM $				;NOPE, NORMALIZE
;(Calls NRMLIZ which changes register usage from above and adjusts various
;things.  "LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.")
;G. ROUND IF NECESSARY, INSERT EXPONENT INTO HIGH ORDER WORD OF RESULT.
	ALU[Q] COND[-OBUS<0] DEST[HOLD] JUMP[NORND] CYLEN[C450] $
		;Save Q in HOLD (i.e. MEM)
		;If Q<0> is zero, don't round
	D[IR] DEST[Q] NORM $
		;Get Q so we check bit meaning rounding (??? Can't this be
		;done with D[IR] ROT[7] COND[OBUS<0]... ???)
	D[CONST 1] ROT[35] ALU[D&Q] COND[OBUS=0] JUMP[NORND] C550 $
		;Check opcode to see if rounding is requested.
		;If not, we're done
	D[MEM] DEST[Q] SHORT $
		;Restore Q
	D[MASK 43] ALU[D&Q] COND[-OBUS=0] JUMP[YESRND] C550 $
		;Round if Q<1:35> is non-zero (? what does this signify???)
	ALU[AC] COND[OBUS<0] JUMP[INSEXP] CYLEN[C450] $
		;If mantissa is negative, we don't round (???)
;	\ /
YESRND:	D[AR] DEST[IR-ADR] SHORT $
		;Setup IR for NRMLIZ
	ALU[AC+1] DEST[AC] PUSHJ[NRMLIZ] NORM $
		;Increment high order word and normalize once more (???)
	JINSEXP $
		;Now stick in exponent
;	---
NORND:	D[MEM] DEST[Q] JUMP[INSEXP] NORM $
		;Restore Q and insert exponent(?)

;UFA NORMALIZATION -- ONLY ON MANTISSA OVERFLOW.
UFANOR:	D[AR] ALU[DORQ] DEST[AC] COND[OBUS=0] POPJ C600 $
	D[AR] DEST[AC] PUSHJ[NORMOV] NORM $
	JINSEXP $
;	---

;------------------------------------------------------------------------------
;SETUP LOW ORDER FP RESULT, STORE BOTH IN AC,AC+1
;ENTER WITH LOW WORD IN MEM, HIGH WORD IN AC, HIGH
;WORD'S EXPONENT IN AR&AC+1.
;------------------------------------------------------------------------------
FPLOW:	D[CONST 27.] ACSEL[AC+1] ALU[AC-D] DEST[AC AR] SHORT $
	D[CONST 1] ROT[7] ACSEL[AC+1] ALU[D&AC] COND[-OBUS=0] JUMP[ZLOW] C550 $
	D[MEM] ROT[27.] MASK[27.] DEST[Q] COND[OBUS=0] JUMP[ZLOW] C550 $
	D[AR] ROT[27.] ACSEL[AC+1] DEST[AC] SHORT $
	D[MASK 8] ROT[27.] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
	ACSEL[AC+1] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
ZLOW:	ACSEL[AC+1] ALU[0] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $

;------------------------------------------------------------------------------
;
;	FLOATING MULTIPLY.  AC&AR BY MEM.
;
;*** This code produces non-zero results if MEM=-1.0 and AC=0  !!!    TVR-Jun80
;------------------------------------------------------------------------------
;A. SUM OF + FORM EXPONENTS -128.+1 TO IR-ADR.  +1 BECAUSE 28
; STEPS ARE USED TO PROVIDE ONE GUARD DIGIT.
FM:	D[AR] MASK[9] ROT[9] DEST[Q AR] NORM$
		;Extract the exponent from AC (which was copied into AR)
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM1] C550 $
		;Check sign bit of number.  Nothing special if positive
	D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
		;Sign is negative, we want the one-complement of the exponent
		;field to get the actual exponent.
FM1:	D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
		;Extract the exponent from MEM
	D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM2] C550 $
		;Check sign bit of number.  Nothing special if positive
	D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
		;Sign is negative, we want the one-complement of the exponent
		;field to get the actual exponent.
FM2:	D[AR] ALU[D+Q] CARRY DEST[Q] SHORT $
		;Add the two exponents
		;+1. FOR GUARD DIGIT.
	D[CONST 1] ROT[7] ALU[Q-D] DEST[IR-ADR] SHORT $
		;Account for exponent bias.  Put exponent in a safe place.
;B. BLANK EXPONENTS.
	BLEXPS[Q SHORT AR]
		;Extend the sign to blank out the exponent field.  We will
		;now have perfectly good integers here, of 27 bit magnitude
		;(assuming that the numbers were normalized to begin with).
	ALU[0] DEST[AC] PUSHJ[TESMUL] NORM $ ;28. STEPS.
;;;	ALU[Q] DEST[AR] SHORT $	;FLUSH SIGN IN LO WD.
	D[MASK 7] ALU[-D&Q] DEST[Q AR] SHORT $	;FLUSH SIGN IN LO WD.
		;Flush remenants of multiplier in low order part of
		;word.  MASK field determined empirically (35-28???)
	D[AR] ALU[D+Q] DEST[Q] SHORT $
		;Make low order word unsigned.
	ALU[AC] DEST[AR] JUMP[FPNAR] NORM $

;28. STEP INTEGER MULTIPLY FOR USE BY FM.
TESMUL:	D[CONST 27.] LLOAD NORM $	;LOOP 28 TIMES
	JUMP[DOMUL1] NORM $	;TEST.

;------------------------------------------------------------------------------
;SHORT STYLE FLOATING DIVIDE AC BY MEM.
; XOR OF DIVISOR&DIVIDEND SIGNS IN AR BIT 0.
;------------------------------------------------------------------------------
FDS:	D[MEM] ALU[D#AC] DEST[AR] SHORT $
FDS1:	D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
	ALU[AC] DEST[AR] COND[-OBUS<0] JUMP[. + 2] C550 $
	ALU[0-AC] DEST[AC AR] SHORT $
	ALU[0] DEST[6] DEST-A-MEM NORM $
	D[CONST 28.] LLOAD NORM $ 
		;Do only a 28-bit divide.

;------------------------------------------------------------------------------
;	Floating Divide
;
; DIVIDEND HIGH ORDER WORD IN AR, LOW IN A-MEM[6]. DIVISOR IN MEM.
; BOTH IN POSITIVE FORM.  IR.35=XOR(DIVIDEND SIGN,DIVISOR SIGN).
;------------------------------------------------------------------------------
FD:
;A. PUT DIVISOR IN + FORM, GET DIVISOR EXPONENT.
;.1 Shuffle IR.35 into A-MEM[4].
	D[IR] MASK[18.] DEST[4] DEST-A-MEM NORM $
		;Save IR-ADR in A-MEM
	D[MEM] DEST[Q] COND[-OBUS<0] JUMP[. + 2] C550 $
		;Check for negative divisor
	D[MEM] ALU[0-D] DEST[Q HOLD] NORM $
		;Negate divisor
	D[MEM] ROT[9] MASK[8] DEST[IR-ADR] NORM $
		;Extract exponent from divisor, store in IR<18:35>
	D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] NORM $
		;Extract mantissa from divisor
;B. Fetch and blank HOW Dividend exponent.
	D[AR] ROT[9] MASK[8] DEST[Q] NORM $
		;Extract dividend exponent.
	D[AR] MASK[27.] DEST[AC] SHORT $
		;Extract mantissa from dividend
;C. Compute resultant exponent.
	D[IR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $
		;Subtract divisor exponent from dividend exponent
	D[CONST 1] ROT[7] ALU[D+Q] DEST[IR-ADR] NORM $
		;Include exponent offset
;D. Move LOW Dividend to Q.
	D[16] DEST[Q] SHORT $
;E. If divisor<=dividend,  shift dividend right, increment the
	; resultant exponent.  save diff. in A-MEM[7] for long mode.
	D[MEM] ALU[AC-D] DEST[7] DEST-A-MEM COND[-OBUS<0] JUMP[FDAD] C600 $
;F. Save exp in A-MEM[5]
FDSHFT:	D[IR] DEST[5] DEST-A-MEM NORM $
	PUSHJ[DODIV4] NORM $	
	 ;Do the divide. Result DOES NOT have signs adjusted.
;G. Save remainder in A-MEM[6], put quotient in AC, AR; put 0 in Q.
	ALU[AC] DEST[6] DEST-A-MEM NORM $
	ALU[Q] DEST[AC AR] SHORT $
	ALU[0] DEST[Q] SHORT $
;H. Prepare to round 28. bit result.
	ALU[SH-AC] MASK[1] DEST[D4] SHORT $
	 ;Shift AC,Q rt 1 bit
	D[15] ALU[D-1] DEST[IR-ADR] NORM PUSHJ[FPNAR] $	
	 ;Move exp for FPNAR, normalize and insert exponent into quotient.
	D[14] MASK[1] C550 OBUS=0 POPJ $
	 ;Done if positive result.
	ALU[0-AC] DEST[AC] NORM POPJ $
	 ;Negate quotient.
;------------------------------------------------------------------------------
;HERE WHEN DIVIDEND IS >= DIVISOR.  SHIFT DIVIDEND RIGHT
; AND INCREMENT RESULTANT AC.  THIS WILL ALLOW DIVIDE TO
; SUCCEED IF BOTH DIVISOR & DIVIDEND WERE NORMALIZED
; AND DIVISOR <> 0.
;------------------------------------------------------------------------------
FDAD:	ALU[SH-AC] MASK[2] DEST[D4] SHORT $
	D[IR] MASK[18.] ALU[D+1] DEST[IR-ADR] JUMP[FDSHFT] NORM $




;ADJSP1 ADJSP2 DMOVE2 DMOVN2 DMOVM2 DMVNM2 DMVNM3 DMVNM4 DMVNM5 KAFIXP KAFIXN FIXR1 KIFIX1 FIXRN KIFIXN FIXER FIXER1 FIXER2 FIXER3
;
;Strays from KI instructions
;

.REPEAT XUCODE [
 .USE[AREA50]  ;Squeeze this stuff into the space vacated by MBOOT.
    ]

;(ADJSP continued)
;Left result is negative.  Check right side.
ADJSP1:	D[IR] MASK[22] ALU[D+AC] DEST[AR] NORM $
		;Add right half
	D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
		;Isolate left half
	D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] NORM $
		;Merge halves and store
	D[IR] COND[-OBUS18] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
		;If E was positive, it wasn't an overflow (just a bad idea)
		;Start fetching next instruction
	D[AR] COND[OBUS<0] JUMP[MAIN] C550 $
		;If original was negative, we're OK.  Start doing next
		;instruction if no sign changed in left half
	JUMP[PDLO6] NORM $
		;ADJSP got a PDLOV
;ADJSP left result positive
ADJSP2:	D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
		;Isolate left half
	D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] $
		;Merge halves and store
	D[IR] COND[OBUS18] SPEC[MA_PC] DEST[MA] C550 $
		;If E was negative, it wasn't an overflow (just a bad idea)
		;Start fetching next instruction
	D[AR] COND[-OBUS<0] JUMP[MAIN1] C550 $
		;If original was positive, we're OK.  Start doing next
		;instruction if no sign changed in left half
	JUMP[PDLO6] NORM $
		;ADJSP got a PDLOV

;(DMOVE continued)
DMOVE2:	D[MA] ALU[D+1] DEST[MA] NORM $	;Fetch second word
	FIXM1 $			;Complete fetch
	ACSEL[AC+1] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
		;Put it in the second AC and start next instruction

;(DMOVN continued)
DMOVN2:	D[MA] ALU[D+1] DEST[MA] NORM $	;Fetch second word
	FIXM1 $	;Complete fetch
	ACSEL[AC+1] D[MEM] ALU[0-D] DEST[AC MA] SPEC[MA_PC] CYLEN[FIXM+1] $
		;Negate low order word and put it in the second AC
		;Start next instruction fetch (Note that DEST[MA] is
		;really associated with SPEC[MA_PC])
		;*** Is FIXM+1 really the right thing???
	ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&AC] DEST[AC]
			COND[-OBUS=0] JUMP[MAIN1] NORM $
		;Clear stupid bit 0.
		;If the low order part is non-zero, we're done
	ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] JUMP[MAIN1] C550 $
		;Increment high order word and we're finally done.

;(DMOVEM continued)
	.PAIR
DMOVM2:	CYLEN[MEMSTO] ACSEL[AC] D[MEM] DEST[AC] NORM $
		;Write it also in the AC
	CYLEN[MEMSTO] D[MA] ALU[D+1] DEST[MA] $
		;Setup to write second word
	ACSEL[AC+1] ALU[AC] DEST[MEMSTO] MEMST $
		;Write secord word.

;(DMOVNM continued)
DMVNM2:	ACSEL[AC+1] ALU[0-AC] DEST[Q] SHORT $
		;Negate low order word.
	ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&Q] DEST[Q]
			COND[-OBUS=0] JUMP[DMVNM4] NORM $
		;Clear stupid bit 0.
		;If the low order part is non-zero, no change needed to
		;high order word.
	D[AR] ALU[AC+1] DEST[AR STRT-WRT] SPEC[CRYOV]
		COND[-MA-AC] JUMP[DMVNM5] NORM $
		;Increment high order word and start first store
DMVNM3:	ACSEL[MA] D[MEM] DEST[AC] JUMP[DMVNM5] $
		;Store is to an AC, write into 2901.
DMVNM4:	DEST[STRT-WRT] COND[MA-AC] JUMP[DMVNM3] $
		;Start first store.  Jump if to an AC
DMVNM5:	D[MA] ALU[D+1] DEST[MA] NORM $
		;Finish write.  Note that due to FIXM2, we don't have to
		;worry about map faults.
		;Prepare for secord write
	ALU[Q] DEST[MEMSTO] MEMST $
		;Do final write (low order word into (E+1))

;KAFIX (Opcode 247) continued
;Positive number to fix
KAFIXP:	D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
		;Extract exponent adjustment factor and do fixing
	ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Put result into AC and we're done
;Negative number to fix
KAFIXN:	D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
		;Extract exponent adjustment factor and do fixing
;;;	ACSEL[AC] D[MASK R] ALU[D/#Q] DEST[AC MA]	;*** Assembler loses!
	ACSEL[AC] D[2] MASK[R] ALU[D/#Q] DEST[AC MA]	;Sigh...
			SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Put sign extended result into AC and we're done

;(FIXR continued)
FIXR1:	D[MEM] COND[OBUS<0] JUMP[FIXRN] C550 $
		;Round different directions
	D[CONST 20] ROT[30.] ALU[D+Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
		;Positive. Finish making constant 0.5 and add it
	D[CONST 33] DEST[Q] SHORT $
		;Start making magic constant
	ALU[AC] DEST[AR HOLD] JUMP[FIXR2] NORM $
		;Setup for FIXER.  Rest is same as KIFIX
;	---
FIXRN:	D[CONST 60] ROT[30.] ALU[D-Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
		;Negative. Finish making constant -0.5 and add it
	D[CONST 33] DEST[Q] SHORT $
		;Start making magic constant
	D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
		;Finish making magic constant
	ALU[0-AC] DEST[AR HOLD] PUSHJ[FIXER] NORM $
		;Setup for FIXER
	ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Negate it back again and start next instruction
;	---
;(KIFIX continued)
KIFIX1:	D[MEM] DEST[AR] COND[OBUS<0] JUMP[KIFIXN] C550 $
		;Load up things for FIXER, check for positive mantissa
FIXR2:	D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] PUSHJ[FIXER] NORM $
		;Finish making magic constant and do fix.
	ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Put result into AC and we're done
;	---
;	---
KIFIXN:	D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
		;Finish making magic constant
	D[MEM] ALU[0-D] DEST[HOLD AR] PUSHJ[FIXER] NORM $
		;ABS to both MEM and AR.  Fix the number
	ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
		;Negate it back again and start next instruction


;Fix a number (without sign extension) in MEM, AR=ABS(MEM), Q=magic number
;(233 for normal fix)
FIXER:	D[AR] ROT[9] MASK[9] ALU[D-Q] DEST[ROTR Q]
			COND[OBUS<0] JUMP[FIXER2] C550 $
		;Calculate number of positions to move
		;Jump if we'll be shifting right (n<2^26)
	D[CONST 27.] ALU[D+Q] DEST[MASKR] NORM $
		;Construct appropriate mask
	D[MEM] MASK[27.] DEST[HOLD] NORM $
		;Flush exponent, our mask won't reach.
	D[CONST 9.] ALU[Q-D] COND[OBUS<0] JUMP[FIXER1] C550 $
		;Check for overflow
;;; Set overflow here.  What kind?  (We can live without it for KAFIX, since it
;;; never did check, but when KIFIX is done, this will have to be corrected.)
	D[CONST 1] ROT[35.] ALU[Q] PUSHJ[QORCRY] NORM $
		;Set overflow flag.
	D[CONST 44] DEST[MASKR] NORM $
		;For those losers who want to see some of the number...
;Now that we know how much to shift things, do it and return.
FIXER1:	D[MEM] ROT[R] MASK[R] DEST[Q] NORM POPJ $
		;Gee, that was fast.
;Negative, shift count, the easy case.
FIXER2:	D[CONST 27.] ALU[D+Q] DEST[MASKR] COND[OBUS<0] JUMP[FIXER3] $
		;Construct appropriate mask.  If !x!<1, return zero
	D[CONST 36.] ALU[D+Q] DEST[ROTR] JUMP[FIXER1] NORM $
		;Hardware doesn't believe in negative shift counts
;Number is fractional, i.e. shift would go off the end.  Return zero
FIXER3:	ALU[0] DEST[Q MASKR] SHORT POPJ $
		;Just return zero.  Set mask just in case

.REPEAT XUCODE [
  .USE[OTHER]
   ]
;FLTR, continued
FLTR1:	D[CONST 33] DEST[Q] SHORT $
	D[CONST 2] ROT[6] ALU[DORQ] DEST[IR-ADR] NORM $
		;Make magic constant for exponent
	ALU[0] DEST[Q] PUSHJ[FPNAR] $
		;Clear low order word
		;Normalize and round (happens to have same bit on as FxxR)
		;Result goes to AC
	SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
		;Start next instruction fetch






.REPEAT TYMNET [.DEFINE FOOLIST[] [ LIST ] ]
FOOLIST
;.USE[TNDISP] GETS BACK TO 64 WORD AREA WE CAN DISPATCH INTO

  .REPEAT OTP [
TNODIFS = 2	;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
TNIRIFS = 4	;INPUT READY INTERRUPT FF SUBSEL = REQ A.
TYM.LD = 1	;MAPF value for loading output register.
TYM.RD = 0	;MAPF value for reading input register.
  ] ;OTP

  .REPEAT NTP [
TNODIFS = 17	;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
TNIRIFS = 16	;INPUT READY INTERRUPT FF SUBSEL = REQ A.
TYM.LD = 15	;MAPF value for loading output register.
TYM.RD = 5	;MAPF value for reading input register.
  ] ;NTP

.REPEAT TYMNET [

;TYMNET INTERFACE.

;A-MEM USAGE.
; 0: STANDARD. 1: STATE OF OUTPUT FFS (SEE CFTNET)
; 2: OUTPUT COROUTINE ADR (LO 6 BITS)
; 3: INPUT COROUTINE ADR (LO 6 BITS)
; 4: CURRENT -10 WORD BEING OUTPUT (FOR STATE 1 ONLY)
; 5: CURRENT -10 WORD BEING ASSEMBLED ON INPUT (STATE 1)
; 6: IOWD FOR PACKET CURRENTLY BEING READ
; 7: B0-2, STATE OF MAP BEFORE INT; B3-35, INP REG AT INT START

;MAIN MEMORY LOCATIONS:
; 2000/	KEY:	0		;FLAGS
; 2001/ BIOREQ: 0		;USED BY MICROCODE TO INDICATE PENDING BLOCK OUTPUT REQUEST
; 2002/ BIOIOW: 0		;USED BY MICROCODE TO KEEP IOWD FOR CURRENT BLOCK OUTPUT IN PROGRESS
; 2200/	IRING: BLOCK 200	;INPUT (TO HOST) RING
; 2400/ ORING: BLOCK 400	;OUTPUT (FROM HOST) RING
; 2005/ HIRP:  0	;HOST IRING PTR (TAKER)
; 2006/ BIRP:  0	;BASE IRING PTR (PUTTER)
; 2011/ HORP:  0	;HOST ORING PTR (PUTTER)
; 2012/ BORP:  0	;BASE ORING PTR (TAKER)

;DR11C FLAG NAMES.  (FIELD VALUES).
;THE ACTUAL DEFINITIONS ARE IN CFDEF.SLO
;TNODIBN=2	;OUTPUT DONE ROTATE AMOUNT (INPUT) = REQ B.
;TNIRIBN=3	;INPUT READY ROTATE AMOUNT (INPUT) = REQ A.
;TNODOBN=6	;OUTPUT DONE ROTATE AMOUNT (OUTPUT) = CSR1.
;TNODOBNPO=7
;TNIROBN=7	;INPUT READY ROTATE AMOUNT (OUTPUT) = CSR0.
;TNIROBNPO=10
 

.DEFINE TNOCEC[] [ ;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
	D[14] ROT[34] MASK[20] DEST[Q] NORM $
	D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
	ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
	D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
]
.DEFINE GBORP[] [
	D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GHORP[] [
	D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GBIRP[] [
	D[CONST 6] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GHIRP[] [
	D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GBBORQ[] [
	D[CONST 1] DEST[Q] PUSHJ[TNRCW] NORM $
]
.DEFINE GBBOIO[] [
	D[CONST 2] DEST[Q] PUSHJ[TNRCW] NORM $
]


;HERE TO SERVICE INPUT READY OR OUTPUT DONE INTERRUPT BY
; TYMNET INTERFACE.
	;SAVE MAP STATE IN A-MEM[7].0-2 & TURN MAP OFF.
TNI:	DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
	D[IR] MASK[3] DEST[AR] MAPF[10] CYLEN[IOB-OUT] $	;MAPOFF NEEDS MAPF, CYLEN.
	D[AR] ROT[41] DEST[Q] NORM $
	D[CONST 6] DEST[DEV-ADR] SPEC[IOB-IN] NORM $ ;BACK TO 6 FOR TN

	;SAVE INPUT REG IN A-MEM[7].
	MAPF[TYM.RD] D[IOD] MASK[41] DEST[AR] CYLEN[IOB-IN] $
	D[AR] ALU[DORQ] DEST[Q 7] DEST-A-MEM NORM $
	D[CONST 1] ROT[TNODIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI1] C550 $
	D[CONST [TNDISP / 100]] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	D[12] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNODIFS] C550 $	;OUTPUT DONE.
	D[12] ALU[DORQ] SDISP C550 $	;OUTPUT DONE.
TNI0:	D[17] DEST[Q] NORM $	;RESTORE INP REG
TNI1:	D[CONST 1] ROT[TNIRIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI2] C550 $
	D[17] ROT[34] MASK[20] DEST[Q] PUSHJ[BITREV] NORM $
	D[CONST [TNDISP / 100]] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
	D[13] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNIRIFS] C550 $	;INPUT READY.
	D[13] ALU[DORQ] SDISP C550 $	;INPUT READY.
TNI2:	D[17] ROT[3] MASK[3] DEST[IOD] NORM $
	ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT]  NORM $
	MAPF[10] CYLEN[IOB-OUT] JUMP[UINT-DISMISS] $

;VARIOUS SUBROUTINES.
;Q LOADED WITH 16. BIT WORD TO SEND, SHIFTED LEFT BY 8.
TNSEND:	ALU[Q] DEST[AR] NORM $
	D[AR] ROT[34] DEST[Q] PUSHJ[BITREV] NORM $
	D[AR] ROT[8] DEST[Q] SHORT $
	D[MASK 16.] ROT[8] ALU[D&Q] DEST[AR] NORM $
	D[MASK 8] DEST[Q] PUSHJ[DEV6ST1] NORM $
	;CLEAR THEN SET INPUT READY FLAG TO DR11C.
	D[MASK 43] ROT[TNIROBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
	D[CONST 1] ROT[TNIROBN] DEST[AR] NORM JUMP[DEV6ST2] $
;NO OUTPUT TO DO.  DO NOT CHANGE TNIROBN, SET A-MEM FLAG FOR
; CLOCK ROUTINE.
TNORE:	GBBORQ	;NO MORE OUTPUT FOR NOW. SEE IF BLOCK OUTPUT REQ WAITING.
	D[MEM] DEST[AR] COND[-OBUS=0] C550 JUMP[TNBOST] $
		;IF SO, GO TAKE CARE OF IT.
	ALU[-1] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
;READ WORD FROM BASE-HOST COMMUNICATION AREA, LOCATION 20XX;
; Q HAS XX.
TNRCW:	D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] NORM $
	FIXM0 POPJ $

;HERE WHEN INPUT RING FULL.  SET CLOCK FLAG AND RETURN WITHOUT
; SETTING TNODOBN.
TNIRF:	ALU[-1] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
;CLEAR THEN SET TNODOBN.
TNCASODOF:
	D[MASK 43] ROT[TNODOBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
	D[CONST 1] ROT[TNODOBN] DEST[AR] NORM JUMP[DEV6ST2] $

.REPEAT SLOWTAPE [

;REVERSE RIGHTMOST 16. BITS IN Q.  LEAVES RESULT IN Q&AR.
; CLOBBERS IR, MEM.
BITREV:	ALU[Q] DEST[AR] SHORT $
	D[CONST 17] LLOAD NORM $
	D[AR] ROT[23] DEST[AR] SHORT $
	ALU[0] DEST[Q HOLD] NORM $
	D[CONST 1] DEST[IR-ALL] NORM $
BRLP:	D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[BRLP1] C550 $
	D[IR] ALU[QORD] DEST[Q] SHORT $
BRLP1:	D[IR] ROT[1] DEST[IR-ALL] LOOP[BRLP] NORM $
	ALU[Q] DEST[AR] POPJ NORM $

 ] ;SLOWTAPE

.REPEAT 1 - SLOWTAPE [

BITREV:	D[MASK 20] ALU[D&Q] DEST[Q AR] NORM POPJ $

 ]

;.USE [OTHER] GETS BACK TO NON-DISPATCH CODE AREA
	.USE[TNDISP]	;$*$*$* Dispatch mechanism is a real loser here.  We
			;	won't be able to flush this one until
			;	references are made relative.  Essentially,
			;	[xx & 77] gets replaced by [. - TNOC0] and
			;	TNOC0 is kept in a A-MEM for speed.  Then,
			;	instead of D[CONST 71] ROT[6] ALU[DORQ], one
			;	uses D[10 + x] ALU[D+Q] to do the dispatch.

;********** OUTPUT DONE CO-ROUTINE.
;A-MEM[4] = ROTATED -10 WORD WITH -11 WORD JUST SENT IN 12-27.
;STATE 0: FETCH NEXT -10 WORD OR QUIT IF RING EMPTY.
TNOC0:	GBORP
	D[MEM] DEST[AR] JUMP[TNOC0A] NORM $
	.USE[OTHER]
TNOC0A:	GHORP
	D[AR] DEST[Q] NORM $
	D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNORE] C600 $
	D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
	FIXM0 $
	D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
	D[CONST[TNDISP & 77]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
;CLOCK RESTARTS COROUTINE HERE.
	.USE[TNDISP]
TNOC2:	TNOCEC
;STATE 1: SEND LOW ORDER HALF OF -10 WORD.
	D[14] ROT[20] DEST[Q] NORM $
	ALU[Q] DEST[4] PUSHJ[TNSEND] DEST-A-MEM NORM $
	D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
	TNOCEC
	GBORP
	D[MEM] ALU[D+1] DEST[Q] NORM $
	D[MASK 8] ALU[D&Q] DEST[AR MEMSTO] JUMP[TNOC0A] CYLEN[MEMSTO] $

;********** INPUT READY CO-ROUTINE.
; A-MEM[5] HAS CURRENT INPUT WORD BEING ASSEMBLED.
;STATE 0: AWAITING START OF NEXT MESSAGE.

TNIC0:	D[CONST 2] ROT[9] DEST[MA] JUMP[TNIC0X] NORM $ ;ADDRESS OF KEY IN MAIN MEM.
	.USE[OTHER]
TNIC0X:	ALU[0] DEST[MEMSTO] NORM $ ;CLEAR KEY AT START OF EVERY MESSAGE
	D[AR] DEST[Q 5] DEST-A-MEM NORM $
	D[CONST 1] ROT[17] ALU[D&Q] COND[OBUS=0] JUMP[TNIC0A] C550 $
;DATA PACKET MESSAGE.
	D[AR] ROT[34] MASK[7] DEST[Q] SHORT $
	D[CONST 5] ALU[D+Q] DEST[AR] SHORT $
	D[AR] ROT[42] MASK[18.] DEST[6] DEST-A-MEM NORM $
	D[15] DEST[AR] SHORT $
;READ MSG.  A-MEM[6]:=# -10 WORDS IN MESSAGE.
; AR:=FIRST -11 WORD IN MESSAGE.
TNICRM:
	GBIRP
	D[16] ROT[18.] ALU[0-D] DEST[Q] NORM $
	D[MEM] MASK[18.] ALU[QORD] DEST[6] DEST-A-MEM JUMP[TNIC1] NORM $
;STATE 1: HO 16 BITS OF WORD ARRIVES.
	.USE[TNDISP]
TNIC1:	D[AR] ROT[24] DEST[5] DEST-A-MEM JUMP[TNIC1A] NORM $
	.USE[OTHER]
TNIC1A:	GHIRP
	D[16] ALU[D+1] DEST[Q] NORM $
	D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
	D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNIRF] C600 $
	PUSHJ[TNCASODOF] NORM $
	D[CONST[TNDISP & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
;STATE 2: LO 16 BITS OF WORD ARRIVES.
; ALSO STARTED HERE BY CLOCK ROUTINE.
	.USE[TNDISP]
TNIC2:	D[16] MASK[7] DEST[Q] JUMP[TNIC2A] NORM $
	.USE[OTHER]
TNIC2A:	D[CONST 22] ROT[6] ALU[D+Q] DEST[MA] NORM $
	D[15] DEST[Q] NORM $
	D[AR] ROT[4] ALU[DORQ] DEST[MEMSTO] NORM $
	PUSHJ[TNCASODOF] NORM $
	D[16] ALU[D+1] DEST[Q] CYLEN[MEMSTO] $
	D[CONST 1] ROT[18.] ALU[D+Q] DEST[6] DEST-A-MEM COND[-OBUS<0] JUMP[TNICDN] C600 $
	D[CONST[77 & TNIC1]] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
TNICDN:	D[CONST 6] DEST[Q] SHORT $
	D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] SHORT $
	D[16] MASK[7] DEST[MEMSTO] NORM $
TNBIDN:	D[CONST[TNIC0 & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] CYLEN[MEMSTO] $
;1 WD OR 2 WD OR ESCAPE MESSAGE.
TNIC0A:	D[CONST 1] ROT[16] ALU[D&Q] COND[-OBUS=0] JUMP[TNIC0B] C550 $
;ONE WORD PACKET.
	D[CONST 1] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
TNIC0B:	D[CONST 1] ROT[16] ALU[D#Q] DEST[Q AR] SHORT $
	D[MASK 6] ROT[8] ALU[D&Q] DEST[Q] SHORT $
	D[MASK 6] ROT[8] ALU[D#Q] COND[OBUS=0] JUMP[TNIESC] C550 $
;2 WORD PACKET.
	D[CONST 2] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
;ESCAPE SEQUENCE.

;HERE IF FIRST BYTE WAS 177, ESCAPE SEQUENCE. REST OF THE 8 BITS IS THE
; COUNT, IN Q, AR  AND AMEM[5].

TNIESC:	D[AR] MASK[8.] DEST[5] DEST-A-MEM PUSHJ[TNCASODOF] NORM $
		;STORE HI ORDER COUNT IN LO ORDER BITS OF AMEM[5].
		; AND TELL THE -11 WE HAVE TAKEN THE INPUT WORD.
	D[CONST[TNDISP & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
		;AND COME BACK WHEN COUNT BYTE COMES IN.

;HERE WHEN NEXT 16 BITS COMES IN. HI ORDER IS COUNT, LO ORDER IS HI ORDER ADDRESS
	.USE[TNDISP]
	D[15] ROT[8.] DEST[Q] JUMP[TNBIS0A] NORM $
		;PUT HI ORDER COUNT FROM LO ORDER 8 BITS OF AMEM[5] INTO HI ORDER BITS IN Q
	.USE[OTHER]
TNBIS0A:
	D[AR] ROT[36. - 8.] MASK[8.] ALU[DORQ] DEST[6] DEST-A-MEM NORM $
		;OR IN THE LOW ORDER COUNT BITS, STORE COMPLETED COUNT INTO AMEM[6].
	D[AR] MASK[2] DEST[5] DEST-A-MEM PUSHJ[TNCASODOF] NORM $
		;IGNORE HI ORDER 4 BITS, JUST GETTING AN 18 BIT ADDRESS
		; TELL THE -11 WE HAVE THE INPUT WORD.
	D[CONST [TNDISP & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $

;HERE WHEN GET MIDDLE AND LO ORDER ADDRESS BITS
	.USE[TNDISP]

	D[15] ROT[35. - 19.] DEST[Q] JUMP[TNBIS0C] NORM $	;GET HI ORDER 2 BITS
	.USE[OTHER]
TNBIS0C:
	D[AR] ALU[DORQ] DEST[5] DEST-A-MEM PUSHJ[TNCASODOF] NORM $
		;TELL 11 WE HAVE THE WORD, AND ADDRESS GOES INTO AMEM[5] FOR NOW.

;NOW HAVE 16 BITS OF + OR - COUNT IN AMEM[6], 18 BIT ADDRESS
; IN AMEM[5] AND AR. SEE IF ITS INPUT OR OUTPUT. IF OUTPUT, STORE
; AN IOWD IN THE OUTPUT REQUEST CELL. IF INPUT, START WORKING ON
; IT.

	D[16] ROT[20.] COND[-OBUS<0] C550 JUMP[TNBORQ] $
		;IF COUNT IS POSITIVE, ITS A BLOCK OUTPUT REQUST, SO JUMP.
	D[16] ROT[17.] SPEC[LEFT] DEST[Q] NORM $
		;GET COUNT/2 INTO LH Q
	D[15] MASK[18.] ALU[DORQ] DEST[Q] NORM $
		;PUT ADDRESS INTO RH OF Q
	D[CONST 7] ROT[36. - 3.] ALU[DORQ] DEST[6] DEST-A-MEM NORM $
		;WAS 16 BIT -VE COUNT SHIFTED RIGHT 1 PLACE, NEED 3 ONES TO MAKE IT REAL NEG NUMBER.
	D[CONST [TNDISP & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
		;NEXT STATE - GET 16 HI ORDER BITS

;HERE FOR HI ORDER BITS FOR BLOCK I/O
;IF BLOCK INPUT REQUEST, GUARANTEED TO RECEIVE A WHOLE NUMBER
; OF PDP10 WORDS, SO IOWD WE USE IS -# 10 WORDS LEFT,,ADDRESS
;IF BLOCK OUTPUT, COUNT IS NUMBER OF 16 BIT PDP11 WORDS,
; SO MUST KEEP -#11 WORDS,,ADDRESS.
	.USE[TNDISP]
TNBIS1:	D[AR] DEST[5] DEST-A-MEM PUSHJ[TNCASODOF] NORM $
		;SAVE THE HI ORDER DATA IN AMEM[5], TELL 11 WE HAVE THE WORD AND ARE READY FOR NEXT ONE.
	D[CONST [. & 77 + 1]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $

;HERE FOR LOW ORDER WORD.
TNBIS2:	D[16] MASK[18.] DEST[MA] JUMP[TNBIS2A] NORM $
		;SETUP MA FOR STORE INTO BLOCK I/O BUFFER
	.USE[OTHER]
TNBIS2A:
	D[15] ROT[20.] DEST[Q] NORM $
		;GET HI ORDER DATA FROM LAST STATE LEFT JUSTIFIED IN Q
	D[AR] ROT[4.] ALU[DORQ] DEST[MEMSTO] PUSHJ[TNCASODOF] NORM $
		;PUT THE WORD INTO THE INPUT BUFFER
		; AND TELL THE -11 WE CAN TAKE ANOTHER WORD
	D[16] DEST[Q] NORM $
		;GET -10 WORD COUNT,,ADDR IN Q
	D[CONST 1,,1] ALU[D+Q] DEST[6] DEST-A-MEM COND[-OBUS<0] C550 JUMP[TNBIDN] $
		;ADD TO IOWD, JUMP IF DONE.
	D[CONST [TNBIS1 & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
		;RESET TO GET ANOTHER HI ORDER WORD.

;HERE IF COUNT IS POSITIVE, IS A BLOCK OUTPUT REQUEST.
; COUNT IS IN AMEM[6].

TNBORQ:	GBBORQ		;SETUP ADDRESS OF  BLOCK OUTPUT REQUEST WORD IN MA
	D[16] ROT[18.] SPEC[LEFT] ALU[0-D] DEST[Q] NORM $
		;GET -11 WORD COUNT,,0 IN Q
	D[15] ALU[DORQ] DEST[MEMSTO] JUMP[TNBIDN] NORM $
		;WRITE BLOCK I/O REQUEST WORD INTO CURRENT BLOCK OUTPUT IOWD LOCATION
		; AND RETURN TO INITIAL INPUT STATE.

;PUSHJ HERE FROM CLOCK ROUTINE TO START UP BLOCK OUTPUT.
; -WORD COUNT,,ADDRESS IS IN AR.

TNBOS0:	GBBORQ		;GET BASE BLOCK OUTPUT REQUEST ADDRESS INTO MA
	ALU[0] DEST[MEMSTO] NORM $
	GBBOIO		;GET BASE BLOCK OUTPUT IOWD ADDRESS INTO MA
	D[AR] DEST[MEMSTO] NORM $ ;STORE IOWD INTO MEMORY.
	D[MASK 16.] ROT[8.] DEST[Q] PUSHJ[TNSEND] SHORT $
		;SEND ESCAPE WORD TO THE 11
	D[CONST [TNDISP & 77]] DEST[2] DEST-A-MEM POPJ NORM $
		;NEXT STATE WILL SEND A 1

	.USE[TNDISP]
	D[CONST 1] ROT[8.] DEST[Q] PUSHJ[TNSEND] SHORT $
		;SEND A 1
	D[CONST [. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
	.USE[OTHER]
		

;HERE FROM OUTPUT DONE AT MICRO INTERRUPT LEVEL WHEN SEE A BLOCK OUTPUT
; REQUEST IS PENDING, ITS IOWD IN AR.

TNBOST:	PUSHJ[TNBOS0] SHORT $ ;SEND AN ESCAPE, SET OUTPUT STATE
	JUMP[TNI0] SHORT $	;AND GO BACK TO INTERRUPT ROUTINE.

;HERE TO SEND FIRST DATA WORD, POINTER IS IN MEMORY
	.USE[TNDISP]

TNBOS1:	GBBOIO		;FETCH IOWD
	D[MEM] MASK[18.] DEST[MA] JUMP[TNBOS1A] NORM $ ;FETCH THE WORD
	.USE[OTHER]
TNBOS1A:
	FIXM0 $	;WAIT FOR IT
	D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
		;SEND IT, STORE INTO AMEM[4] FOR NEXT STATE
	D[CONST [TNDISP & 77]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
	.USE [TNDISP]
	GBBOIO
		;GET IOWD AGAIN
	D[MEM] DEST[Q] JUMP[TNBOS2] NORM $
		;GET IT INTO Q FOR ARITHMETIC
	.USE[OTHER]
TNBOS2:	D[CONST 1] ROT[18.] ALU[D+Q] DEST[MEMSTO] COND[-OBUS<0] C550 JUMP[TNORE] $
		;ADD 1,,0 TO IOWD, STORE BACK IN MEMORY, SEE IF IT HAS
		; EXPIRED YET. IF NOT, CONTINUE ON.

;SEND LOW ORDER WORD
	D[14] ROT[16.] DEST[Q] PUSHJ[TNSEND] NORM $
		;SHIFT LOW ORDER BYTE INTO PLACE, SEND IT
	D[CONST [TNDISP & 77]] DEST[2] DEST-A-MEM JUMP[TNI0] $
	.USE[TNDISP]
	GBBOIO	;GET IOWD
	D[MEM] DEST[Q] JUMP[TNBOS2A] SHORT $
	.USE[OTHER]
TNBOS2A:
	D[CONST 1,,1] ALU[D+Q] DEST[MEMSTO] COND[-OBUS<0] C550 JUMP[TNORE] $
		;ADVANCE ADDRESS AND COUNT, JUMP IF DONE.
	JUMP[TNBOS1] NORM $	;NOT DONE, GO SEND NEXT ONE.
;CLOCK ROUTINE, CALLED EVERY TICK OF 60HZ CLOCK.
TYMCLK:	D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPOFF] SPEC[IOB-IN] NORM $
	MAPF[10] CYLEN[IOB-OUT] D[CONST 6] DEST[DEV-ADR] $
	D[IR] DEST[7] DEST-A-MEM NORM $
	D[13] COND[OBUS<0] PUSHJ[TNSI] C550 $
	D[12] COND[OBUS<0] PUSHJ[TNSO] C550 $
	D[17] MASK[3] DEST[IOD] NORM $
	ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
	MAPF[10] CYLEN[IOB-OUT] $
	D[CONST 6] DEST[DEV-ADR] POPJ NORM $

TNSI:	GHIRP
	D[16] ALU[D+1] DEST[Q] NORM $
	D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
	D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
	D[CONST[TNIC2 & 77]] DEST[3] DEST-A-MEM JUMP[TNCASODOF] NORM $
TNSO:	GBBORQ		;GET BLOCK OUTPUT REQUEST WORD INTO MEM
	D[MEM] DEST[AR] COND[-OBUS=0] C550 JUMP[TNBOS0] $
		;IF ITS NON-ZERO, START A BLOCK OUTPUT REQUEST.
		; AND RETURN TO TYMCLK CALLER
	GBORP
	D[MEM] DEST[AR] NORM $
	GHORP
	D[AR] DEST[Q] NORM $
	D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
	D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
	FIXM0 $
	D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
	D[CONST[TNOC2 & 77]] DEST[2] POPJ DEST-A-MEM NORM $

;RESET TYMNET INTERFACE.  OUTPUT COROUTINE GOES INTO NULL STATE.
; INPUT COROUTINE GOES INTO STATE 0, INTRPTS GET ENABLED.
TYMRS1:	D[CONST 3] ROT[2] DEST[AR] CYLEN[IOB-OUT] SPEC[IOB-OUT] $
	 ;GET CONST TO ENB. INTRPTS; IOB-OUT CLEARS FLAGS.
TYMRS2:	MAPF[TNODIFS] START-OUT C600 $
	MAPF[TNIRIFS] D[MASK 2] ALU[NOTD] ROT[2] DEST[Q] PUSHJ[DEV6ST1] C600 $
	ALU[-1] DEST[2] DEST-A-MEM NORM $
	D[CONST[TNIC0 & 77]] DEST[3] POPJ DEST-A-MEM NORM $

TYMAREA = .	;SAVE LOCATION (DON'T USE :, ITS STICKY)

	.OPCODE[744]	  ;RESET TYMNET

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNRESET] $

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNOUT] $

	NOP $
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNIN] $

	NOP $	;AS NEAR AS I CAN TELL, THIS ONE (747) ISN'T USED. - PG
	D[CONST 6] DEST[DEV-ADR] NORM JUMP[F5DIAG] $

	.USE[TYMAREA]	;RETURN TO MAIN CODE

TYMNRESET:  SPEC[IOB-OUT] D[MA] ROT[2] DEST[AR] NORM PUSHJ[TYMRS2] $
		;RESET CO-ROUTINES, ENB. INTRPTS FROM EFF. ADDR. 34,35
	JUMP[MAIN] $

TYMNOUT: SPEC[IOB-OUT] NORM $  ;CLEAR "RDY FOR DATA" FROM PDP11
	MAPF[TNODIFS] D[MA] ROT[8.] DEST[Q] NORM PUSHJ[TNSEND] $
	  ;SEND EFF. ADDR. 20-35 TO PDP11.
	JUMP[MAIN] $

TYMNIN:	D[CONST 25.] LLOAD NORM $
	NORM LOOP[.] $  ;GIVE DMA DEVICES SOME MEMORY TIME.
	SPEC[IOB-IN] NORM $
	MAPF[TYM.RD] D[IOD] ROT[34] DEST[AR] C800 $
	   ;ALIGN INPUT WORD WITH 16 DATA BITS AT RIGHT END.
	D[AR] ROT[4] C550 COND[-OBUS<0] JUMP[. + 2] $
	   ;DON'T CLEAR "INPUT RDY" FLAG UNLESS IT'S ON.
	SPEC[IOB-OUT] SHORT $  ;IT'S ON.
	MAPF[TNIRIFS] D[AR] DEST[MEMSTO] MEMST $


F5DIAG: FIXM1 $
	D[IR] ALU[NOTD] DEST[AR] NORM $
		;AR=-IR
	D[AR] ROT[13.] MASK[2] DEST[AR] NORM $
		;AR=-AC MASK 2
	D[AR] ROT[6] DEST[Q] NORM $
		;Q=INVERTED 2 LSB'S OF AC SHIFTED INTO STROBES
	D[MEM] ROT[8.] ALU[DORQ] DEST[HOLD] NORM $
		;DATA SHIFTED WITH STROBES INSERTED
	D[MEM] DEST[AR] NORM $
		;DATA=(E) (LSH 8) (STB ACTIVE LOW)
	D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
		;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
	D[MASK 2] ROT[6] DEST[Q] NORM $
		;MASK TO FORCE STB'S HIGH
	D[MEM] ALU[DORQ] DEST[AR] NORM $
		;DATA=(E) (LSH 8) (STB'S FORCED INACTIVE HIGH)
	D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
		;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
	ALU[0] DEST[DEV-ADR] JUMP[MAIN] $


];TYMNET

list  ;matches the XLIST at top of page.


;$*$*$* Grrr...
	.ORG[2141]	;DISP HERE ON TYMNET INTERFACE INTERRUPT.
			; PREPARE TO CALL MAPOFF BY RE-LOADING DEV-ADR.
	D[CONST 1] DEST[DEV-ADR] NORM JUMP[TNI] $	

	.RELOC

.REPEAT 1 - TYMNET [
TNI:	DEST[CLR-DEV-FROM-INTR] JUMP[UINT-DISMISS] $		;"It can't happen here"
];1 - TYMNET


;What is 'device 6'?  Document!  TVR-Apr80 - This is TYMNET (Clear and Store)
DEV6CL:	  ;CLEAR SOME DEV 6 BITS (SEE COMMENT BELOW).
	ALU[0] DEST[AR] NORM JUMP[DEV6ST] $

DEV6ST:	   ;SET SOME OF THE BITS IN DEVICE 6'S OUTPUT REGISTER, A COPY
	   ;OF WHICH IS MAINTAINED IN A-MEM(1).
	   ;ENTER WITH MASK FOR UNCHANGED BITS IN IN Q, DATA IN AR.
	   ; $$$$ ON RETURN, Q HAS NEW VALUE OF AMEM(1) $$$$$
	D[CONST 6] DEST[DEV-ADR] NORM $
DEV6ST1:	;ENTER HERE IF YOU'VE ALREADY SET DEVADR:=6
	D[11] ALU[D&Q] DEST[Q] NORM $ ;GET AMEM(1), MASK IT.
DEV6ST2:	 D[AR] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ 
		;OR IN NEW DATA
	MAPF[TYM.LD] ALU[Q] DEST[1] DEST-A-MEM CYLEN[IOB-OUT] POPJ $




;INTERVAL TIMER CODE.

;a-mem useage:
;	0	dispatch addr for interrupts
;	1	pi chn (33: 35) and intrpt waiting flag (32)
;		(BITS 0,19 ARE ON FOR USE BY TAPE CODE)
;	2	CONSTANT W/ ONLY BIT 19 ON (USED BY TAPE CODE)
;	3	INTERVAL TIMER REGISTER.

  .REPEAT OTP [
	TIM.CLR.ROT = 35. - 6
	TIM.DO = 1
	TIM.DI = 1
	TIM.ENB = 1
	TIM.DEV = 7
	TIM.LOC = 2150
    ] ;OTP

  .REPEAT NTP [
	TIM.CLR.ROT = 0
	TIM.DO = 11
	TIM.DI = 1
	TIM.ENB = 10
	TIM.DEV = 5
	TIM.LOC = 2134
    ] ;NTP


	.ORG[TIM.LOC]		;$*$*$ INTRPTS FROM DEVICE COME HERE.
   .REPEAT 1 - TIMER [
	DEST[CLR-DEV-FROM-INTR] JUMP[UINT-DISMISS] $ ;FLUSH DEV INTERRUPTS 
     ]

   .REPEAT TIMER [
	NORM JUMP[TIMINT] $
     ]

	.RELOC

TIMINT:   ;ALL DEV 5 INTS COME FROM INTERVAL TIMER...
	START-OUT D[CONST 1] ROT[TIM.CLR.ROT] DEST[IOD] NORM $
	   ;Clear the TIMER OVERFLOW FLAG.
	MAPF[TIM.ENB] D[13] DEST[Q] C800 $
	   ;Get TIMER REGISTER.
	D[CONST 1] ROT[12.] ALU[D+Q] DEST[Q 3] DEST-A-MEM
	          C550 COND[-CRY0] JUMP[UINT-DISMISS] $
	   ;Increment the count by 2^12, exit if no overflow.
	D[11] MASK[3] DEST[AR] C550 COND[OBUS=0] JUMP[UINT-DISMISS] $
	   ;Timer overflowed. ignore if no PI CHANNEL assigned.
	D[11] DEST[Q] NORM $
	   ;Get full contents of A-MEM[1].
	D[CONST 10] ALU[DORQ] DEST[1] DEST-A-MEM NORM JUMP[PIGEN] $
	   ;Set the "interrupting" status bit and generate a PI.

   .OPCODE[760]	;TIMER PSEUDO-IOT DISPATCH TABLE ENTRIES.

; TCONO -- 760
	D[CONST TIM.DEV] DEST[DEV-ADR] SHORT $
	D[11] DEST[Q] NORM JUMP[TCNO1]$
; TCONI -- 761
	D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
	D[AR] DEST[MEMSTO] MEMST $ ;store them and return.
; TCONSO -- 762
	D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
	D[MASK 22] ALU[D&Q] C550 COND[-OBUS=0] LBJUMP[DSKP1] $ ;Skip if on.
; TCONSZ -- 763
	D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
	D[MASK 22] ALU[D&Q] C550 COND[OBUS=0] LBJUMP[DSKP1] $ ;Skip if off.
; TDATAO -- 764  LOAD THE 36-BIT TIMER
	D[CONST TIM.DEV] DEST[DEV-ADR] NORM $
	FIXM1 JUMP[TDATO] $
; TDATAI  --  765    READ TIMER REGISTER
	START-IN D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TDTI] $ ;get bits.
	D[AR] DEST[MEMSTO] MEMST $ ;Store them and return.

   .RELOC

TCNO1:	D[MASK 32.] ROT[4] ALU[D&Q] DEST[Q] NORM $
	D[IR] MASK[3] ALU[DORQ] DEST[1] DEST-A-MEM JUMP[MAIN] $
	   ;Put new PI CHAN. in bits 33-35 of A-MEM[1].

TCNI1:	D[11] MASK[4] DEST[Q AR] NORM $ ;get intrpt flag and pi chn
	D[IR] ALU[D&Q] DEST[Q] NORM POPJ $ ;this is for conso, z

TDATO:	D[MEM] MASK[12.] DEST[Q] NORM $
	   ;Get low 12 bits of new timer value...
	START-OUT D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
	   ;Place in hardware counter (the "TP TIMER").
	MAPF[TIM.DO] D[MASK 24.] ROT[12.] DEST[Q] C800 $
	D[MEM] ALU[D&Q] DEST[3] DEST-A-MEM NORM JUMP[MAIN] $
	   ;Put other 24 bits into A-MEM[3] (the "TIMER REGISTER").

TDTI:	MAPF[TIM.DI] START-IN D[IOD] ROT[12.] MASK[12.] DEST[AR] C600 $
	   ;Read hardware timer.
	MAPF[TIM.DI] D[IOD] ROT[12.] MASK[12.] DEST[Q] C600 $
	   ;Read it again.
	START-IN D[AR] ALU[D#Q] C550 COND[-OBUS=0] JUMP[TDTI] $
	   ;If it changed, try again (to ensure that we don't get a garbaged
	   ; value because of reading it while it is changing).
	D[13] ALU[DORQ] DEST[AR] NORM POPJ $
	   ;Combine high-order bits from A-MEM[3] with
	   ; low-order bits from hardware counter.




;	IMP,VID,PAN,GRN,DLS,LPT,VC etc.
;------------------------------------------------------------------------------
;
;	Packet Switching Network Interface (IMP)
;
;------------------------------------------------------------------------------
.REPEAT IMP [

;Insert main code body here
.INSERT IMP.SLO

];IMP

;------------------------------------------------------------------------------
;
;	Panofsky-Samson Interface
;
;------------------------------------------------------------------------------
.REPEAT STANSW [

.INSERT PAN.SLO
.INSERT TMPGRN.SLO	;Temporary Grinnell Interface

];.REPEAT STANSW

;------------------------------------------------------------------------------
;
;	Data Line Scanner (TTY scanner)
;
;------------------------------------------------------------------------------
.REPEAT DLS [

.DEFINE ASRC[ X ] [D[10 + X]]
.DEFINE ADEST[ X ] [DEST[X] DEST-A-MEM]

.REPEAT DLS2 [
.INSERT DLS.SLO

.REPEAT DLSDEB [
.INSERT DLSDEB.SLO
];DLSDEB
] ;DLS2
.REPEAT 1 - DLS2 [
.INSERT ODLS.SLO
.REPEAT DLSDEB [
.INSERT ODLSDE.SLO
] ;DLSDEB
] ;1 - DLS2

];DLS			9 JAN 80  BO

;------------------------------------------------------------------------------
;
;	Line Printer Interface (LPT)
;
;------------------------------------------------------------------------------
.REPEAT LPT [

.INSERT LPTX.SLO	

];LPT

;------------------------------------------------------------------------------
;
;	Versatec Interface (VC)
;
;------------------------------------------------------------------------------
.REPEAT VC [

.INSERT VC.SLO
] ;VC




; dsk stuff

;a-mem useage:
;	0	dispatch addr for interrupts
;	1	pi chn (33: 35) and intrpt waiting flag (32)
;	2	copy of last cmd sent to controller (by opcode 721)

	.OPCODE[740]	;disk pseudo-iot dispatch table entries.

 ; dcono -- 740
	d[const 10] dest[dev-adr] short $
	d[ir] mask[3] dest[1] DEST-A-MEM norm jump[dcno1]$
; dconi -- 741
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[ar] dest[memsto] memst $ ;store them and return.
; dconso -- 742
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[mask 22] alu[d&q] c550 cond[-obus=0] lbjump[dskp1] $
; dconsz -- 743
	d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
	d[mask 22] alu[d&q] c550 cond[obus=0] lbjump[dskp1] $

	.RELOC

dcno1:	d[ir] mask[3]  c500 cond[obus=0] jump[main] $
	 ; if assigned pi channel is not 0, then
	 ;  enable interrupt on "not active", by
	 ;  re-loading last cmd with 10 bit on.
	D[CONST 20] DEST[Q] NORM $
	D[IR] ALU[D&Q] C550 OBUS=0 JUMP[DCNO2] $
	D[CONST 40] DEST[Q] NORM JUMP[DCNO3] $
DCNO2:	d[const 10] dest[q] short $
DCNO3:	d[12] alu[dorq] dest[iod] spec[iob-out] norm $
	mapf[4] cylen[iob-out] jump[main] $

dcni1:	d[11] dest[q ar] norm $ ;get intrpt flag and pi chn
	d[ir] alu[d&q] dest[q] norm popj $ ;this is for conso, z

	.ORG[2156]	;$*$*$ 

	;interrupts from disk (dev 10) come here.
	d[const 50] alu[notd] dest[q] norm jump[dskint] $

	.RELOC
	.PAIR
;$*$*$ This exists elsewhere by another name.	TVR-Apr80
dskp1:	jump[main] norm $	;conso and consz lbjump to here.
	doskip $

dskint:	d[12] alu[d&q] dest[iod] spec[iob-out] norm $
	  ;clear interrupt enable bit (amem[2] has last cmd)
	mapf[4] d[11] dest[q ar] c550 cond[obus=0] jump[ddis] $
	d[const 10] alu[dorq] dest[1] DEST-A-MEM norm
		jump[pigen] $ ;set flag and request intrpt.
ddis:	dest[clr-dev-from-intr] norm jump[uint-dismiss] $

DSKWT1:	D[CONST 10] DEST[DEV-ADR AR] NORM JUMP[DSKWT4] $
DSKWT3:	D[MEM] ROT[31.] C550 COND[OBUS<0] JUMP[DSKWDN] $
	D[CONST 1] ROT[6] LLOAD NORM $
	C550 LOOP[.] $
DSKWT4:	START-IN NORM $
	MAPF[0] D[IOD] DEST[HOLD] C800  JUMP[DSKWT3] $
DSKWDN:	D[AR] ALU[D-1] DEST[AR] C550 COND[-OBUS=0] JUMP[DSKWT4] $
	JUMP[MAIN] $




;
;ECC logging area
;
.REPEAT 1 - XUCODE [
: 7760
];.REPEAT 1 - XUCODE
.REPEAT XUCODE [
: 17760
];.REPEAT XUCODE

 .REPEAT 20 [NOP $
]



;; this should be after everything else
: 0
	JUMP[MSTART] $		;Auto-load micro code tapes someday.

	 4