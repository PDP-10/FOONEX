SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

26m0141                               	 .REPEAT 1 - NEWMAP [
26m0141                               	        D[CONST 1] ROT[32] DEST[STO-MAP] NORM $ ]
26m0141                               	          ;CLR MAP ENTRY ASSOCIATED WITH MA
26m0141 05421 240702234571000033600000	        D[IR] MASK[3] DEST[IOD] SPEC[IOB-OUT] C800 $; RESTORE ENABLES
26m0141 05422 440140000571000440102026	        MAPF[10] CYLEN[IOB-OUT] JUMP[MAIN] $
26m0141                               	
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	;
26m0141                               	;       BBN MAP - Handle map trap and page fill cycles.
26m0141                               	;
26m0141                               	;       This code will need to be rewritten for another kind of map.
26m0141                               	;
26m0141                               	;------------------------------------------------------------------------------
26m0141 05423 640700050171000400000000	MFUS:   D[12] MASK[40] DEST[Q] NORM $;GET LIMIT REG
26m0141 05424 471140024537000440000000	        D[MA] ALU[D-Q] COND[-OBUS<0] JUMP[MTRPAL] C600 $;J IF MA PAST ADDRS LIMIT
26m0141 05425 640140044171000440000000	        D[11] DEST[Q] JUMP[MFA1] NORM $;GET USER BASE REG.
26m0141                               	
26m0141 05426 530140004571024010000000	MFA3:   D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFA4] C550 $ ;J IF MODIF. BIT ON
26m0141 05427 640700600571000440000000	MFA7:   D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
26m0141 05430 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
26m0141 05431 640710014575056010000000	        D[CONST 1] ROT[27] ALU[DORQ] DEST[AR] SHORT $; TURN ON WRT-PREVENT, SAVE NEW MAP
26m0141                               	 WORD
26m0141 05432 640140004171000330000000	MFA6:   D[MEM] MASK[33] DEST[Q] JUMP[MFA5] NORM $; GET CST ENTRY, GO DO
26m0141 05433 510140034571054010005427	MFA4:   D[IR] ROT[26] MASK[1] COND[OBUS=0] JUMP[MFA7] C550 $; J IF NO WRT-PERMIT
26m0141 05434 640700600571000440000000	        D[AR] DEST[IR-ALL] SHORT $; SAVE ORRIGINAL MA
26m0141 05435 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
26m0141 05436 640150010635060430005432	        D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] JUMP[MFA6] NORM $; CLEAR WRT-PREVENT
26m0141                               	;------------------------------------------------------------------------------
26m0141                               	; Enter here with fault code in Q and address in MA to handle page fault or
26m0141                               	; page fill cycle.  MAP-EXEC-SR (i.e. USER condition) is still undisturbed.
26m0141                               	;------------------------------------------------------------------------------
26m0141 05437 645150024575000220005423	MFT1B:  D[MA] MASK[18.] ALU[DORQ] DEST[AR] COND[USER] JUMP[MFUS] NORM $;GET FAILED ADDRS,
26m0141                               	 J IF USER
26m0141 05440 640700024171050020000000	        D[MA] ROT[24] MASK[2] DEST[Q] NORM $; HIGH ORDER 2 BITS
26m0141 05441 450140014537000030000000	        D[CONST 3] ALU[D-Q] COND[OBUS=0] JUMP[MFHIEX] C600 $; J IF PRIVATELY MAPPED PART
26m0141                               	
26m0141 05442 640140014171014300000000	        D[CONST 30] ROT[6] DEST[Q] JUMP[MFA1] NORM $; PAGE TAB @ 3000
26m0141 05443 640700060171000440000000	MFHIEX: D[14] DEST[Q] NORM $
26m0141 05444 640701600615000440000000	MFA1:   ALU[0] DEST[DEV-ADR] NORM $
26m0141 05445 640702234571000023600000	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $ ;CLEAR MAPPING
26m0141 05446 440701634571000033100000	        D[IR] MASK[3] DEST-A-MEM DEST[APRENB] MAPF[10] CYLEN[IOB-OUT] $
26m0141                               	                ;SAVE AR, ECC INT
26m0141 05447 640722624435066110000000	        D[MA] ROT[33] MASK[11] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE ENTRY
26m0141                               	
26m0141 05450 640700214571030160000000	        D[CONST 16] ROT[14] DEST[IR-ADR] NORM $; PREPARE INITIAL PERMIT BITS
26m0141 05451 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
26m0141 05452 640700014171000030000000	MFA2:   D[CONST 3] DEST[Q] CYLEN[FIXM] $; DON'T CLEAR IND PNTR. COUNT, WAIT FOR FETCH
26m0141 05453 640700004175044440000000	        D[MEM] ROT[18.] ALU[DORQ] DEST[Q] CYLEN[FIXM+1] $;GET PERMIT BITS
26m0141 05454 640700234635000440000000	        D[IR] ALU[D&Q] DEST[IR-ADR] SHORT $; AND THEM IN
26m0141 05455 530140004571026030000000	        D[MEM] ROT[13] MASK[3] COND[-OBUS=0] JUMP[MFTR1] C550 $; CHECK FOR TRAP BITS
26m0141 05456 510140004571032010000000	MFB3:   D[MEM] ROT[15] MASK[1] COND[OBUS=0] JUMP[MFTR2] C550 $; J IF NO ACCESS PERMIT
26m0141 05457 510140004171004020000000	        D[MEM] ROT[2] MASK[2] DEST[Q] COND[OBUS=0] JUMP[MFTYP0] C550 $; GET TYPE CODE, J
26m0141                               	 IF 0
26m0141 05460 510140000055000440000000	        ALU[Q-1] DEST[Q] COND[OBUS=0] JUMP[MFTYP1] C550 $; J IF 1
26m0141 05461 530140000055000440000000	        ALU[Q-1] DEST[Q] COND[-OBUS=0] JUMP[MFTR3] C550 $; J IF NOT 2
26m0141 05462 530140034571106010000000	        D[IR] ROT[43] MASK[1] COND[-OBUS=0] JUMP[MFTR41] C550 $; TYPE 2, J IF >2 INDR.
26m0141                               	 PNTRS
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

26m0141 05463 640700234433000440000000	        D[IR] ALU[D+1] DEST[IR-ADR] SHORT $; COUNT IND. PNTRS
26m0141 05464 640700004171066150000000	        D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET PAGE TABLE #
26m0141 05465 640701404571000443000000	        D[MEM] DEST-A-MEM DEST[6] NORM $; SAVE PNTR
26m0141 05466 640722614435030020000000	        D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH PAGE TABLE PNTR
26m0141 05467 640700070171000110000000	        D[16] MASK[11] DEST[Q] CYLEN[FIXM] $; GET PAGE #, WAIT FOR MEM
26m0141 05470 530140004571044040000000	        D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR4] C550 $; PAGE OUT-OF-CORE?
26m0141 05471 640704404571000130000000	        D[MEM] MASK[13] DEST[HOLD] NORM $
26m0141 05472 640162604575022440005452	        D[MEM] ROT[11] ALU[DORQ] DEST[MA HI-ABS-MA] JUMP[MFA2] NORM $; LOOP
26m0141 05473 640700004171066150000000	MFTYP1: D[MEM] ROT[33] MASK[15] DEST[Q] SHORT $; GET SHARED PAGE #
26m0141 05474 640722614435030020000000	        D[CONST 2] ROT[14] ALU[D+Q] DEST[MA HI-ABS-MA] NORM $; FETCH SHARED PNTR
26m0141 05475 640700014171030120000000	MFTYP0: D[CONST 12] ROT[14] DEST[Q] CYLEN[FIXM] $; GET R-X MASK
26m0141 05476 450140034635000440005500	        D[IR] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C600 $; J IF NEITHER R NOR X
26m0141 05477 640700234575000440000000	        D[IR] ALU[DORQ] DEST[IR-ADR] NORM $; TURN ON R AND X
26m0141 05500 640700034371056030000000	        D[IR] ROT[27] MASK[3] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX ENBL BITS,
26m0141                               	 INVERTED
26m0141 05501 530140004571044040000000	        D[MEM] ROT[18.] MASK[4] COND[-OBUS=0] JUMP[MFTR5] CYLEN [C550] $; J IF
26m0141                               	 OUT-OF-CORE
26m0141 05502 530140000235042030000000	        D[AR] ROT[21] MASK[3] ALU[D&Q] DEST[Q] COND[-OBUS=0] JUMP[MFTR6] C550 $; J IF
26m0141                               	 ILLEGAL ACCESS TYPE (RWX)
26m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

27m0141                               	;MFA5 JSMFR MFTR1 MFTR10 MFB5 MFB4 MFC1 MFTR2 MTRPAL MFTR3 MFTR4 MFTR5 MFTR6 MFTR7 MFTR9
27m0141                               	 MFTR41 MAPRST MAPRSS MAPRSL
27m0141 05503 640700004171000130000000	        D[MEM] MASK[13] DEST[Q] SHORT $; GET ABS PAGE #
27m0141 05504 640722614575014400000000	        D[CONST 40] ROT[6] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; GET CORE STATUS ENTRY
27m0141 05505 640700034371024440000000	        D[IR] ROT[12] ALU[NOTD] DEST[Q] CYLEN[FIXM] $; GET RWX DISABLES
27m0141 05506 640700014235052240000000	        D[CONST 24] ROT[25] ALU[D&Q] DEST[Q] SHORT $; GET ONLY R & X
27m0141 05507 640700014035052040000000	        D[CONST 4] ROT[25] ALU[D+Q] DEST[Q] SHORT $; MOVE X BIT LEFT 1
27m0141 05510 640700024175022240000000	        D[MA] ROT[11] MASK[24] ALU[DORQ] DEST[Q] SHORT $; OR IN PAGE ADDRS
27m0141 05511 510140004571006030000000	        D[MEM] ROT[3] MASK[3] COND[OBUS=0] JUMP[MFTR7] C550 $; J IF CST AGE SAYS TRAP
27m0141 05512 510140000571040010005426	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFA3] C550 $;J IF NO WRT RQ
27m0141 05513 640700200571000440000000	        D[AR] DEST[IR-ADR] SHORT $; SAVE ORRIGINAL MA
27m0141 05514 640701400571000443000000	        D[AR] DEST-A-MEM DEST[6] NORM $; SAVE TRAP WORD
27m0141 05515 640710010635060430000000	        D[MASK 43] ROT[30] ALU[D&Q] DEST[AR] SHORT $; TURN OFF WRT PREVENT, SAVE NEW MAP
27m0141                               	 WORD
27m0141 05516 640700014171064010000000	        D[CONST 1] ROT[32] DEST[Q] SHORT $; GET MODIFICATION BIT
27m0141 05517 640700004175000320000000	        D[MEM] MASK[32] ALU[DORQ] DEST[Q] SHORT $; OR INTO CST WORD
27m0141 05520 640704464575000440000000	MFA5:   D[15] ALU[DORQ] DEST[HOLD] NORM $;OR IN AGE, ETC
27m0141 05521 640700024171000440000000	        D[MA] DEST[Q] SHORT $; SAVE CST ADDRS
27m0141                               	
27m0141 05522 640722634571000220000000	        D[IR] MASK[18.] DEST[MA HI-ABS-MA] NORM $; GET ORIGINAL MA
27m0141                               	
27m0141                               	 .REPEAT NEWMAP [
27m0141                               	        D[CONST 1] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
27m0141                               	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
27m0141                               	        MAPF[10] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
27m0141                               	        MAPF[2] D[AR] C800$; LOAD MAP
27m0141                               	  NOP $ ;%%%%%%% FOR DEBUGGING $$$$$$$$
27m0141                               	  ] [
27m0141 05523 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
27m0141 05524 640702214571000043600000	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
27m0141 05525 440700000571000443700000	        MAPF[10] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
27m0141 05526 240700000571000440020000	        MAPF[2] D[AR] C800$; LOAD MAP
27m0141 05527 000700000571000440000000	  NOP $ ;%%%%%%% FOR DEBUGGING $$$$$$$$
27m0141                               	  ]; NEWMAP
27m0141                               	
27m0141                               	 .REPEAT 1 - NEWMAP [
27m0141                               	        ALU[0] DEST[DEV-ADR] SHORT $ ;NOW TURN MAP ON.
27m0141                               	        D[CONST 4] DEST[IOD] SPEC[IOB-OUT] SHORT $
27m0141                               	        MAPF[10] CYLEN[IOB-OUT] $
27m0141                               	        D[AR] DEST[STO-MAP] NORM $; LOAD MAP
27m0141                               	  ] ; 1-NEWMAP
27m0141                               	
27m0141 05530 240702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] C800 $ ;MAP OFF
27m0141 05531 465140000571000440105533	        MAPF[10] CYLEN[IOB-OUT] COND[-USER] JUMP[. + 2] $
27m0141                               	
27m0141 05532 640705614571022170000000	        D[CONST 17] ROT[11] DEST[MAP-EXEC-SR] NORM $
27m0141 05533 640724000555000440000000	        ALU[Q] DEST[MA STRT-WRT] NORM $; STORE CST
27m0141                               	
27m0141                               	.REPEAT 1 - WAITS [;Damnit. TENEX isn't the only operating system for a PDP-10!
27m0141                               	   ;Now add 1 to abs. loc. 30 of main mem (for statistics keeping)
27m0141                               	        D[CONST 30] DEST[MA] NORM $
27m0141                               	        NORM $
27m0141                               	        D[MEM] ALU[D+1] DEST[MEMSTO] NORM $
27m0141                               	];[;Damnit. TENEX isn't the only operating system for a PDP-10!
27m0141                               	   ;Now add 1 to abs. loc. 30 of main mem (for statistics keeping)
27m0141 05534 640720014571000300000000	        D[CONST 30] DEST[MA] NORM $
27m0141 05535 640700000571000440000000	        NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

27m0141 05536 640704204433000440000000	        D[MEM] ALU[D+1] DEST[MEMSTO] NORM $
27m0141                               	].REPEAT 1 - WAITS
27m0141                               	
27m0141 05537 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
27m0141 05540 640710070571000440000000	        D[16] DEST[AR] NORM $
27m0141 05541 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
27m0141 05542 640702274571000443600000	        D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN MAP BACK ON, ETC.
27m0141                               	        MAPF[10] CYLEN[MAX,IOB-OUT,C550]
27m0141 05543 170140000571032010100000	                        D[AR] ROT[15] MASK[1] COND[-OBUS=0] JUMP[JSMFR] $
27m0141                               	                ; DO SPECIAL JSYS STUFF IF APPROPRIATE
27m0141 05544 510140000571040010002026	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MAIN]  C550 $; DONE IF NO WRT
27m0141 05545 530140000571036010002026	        D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MAIN] C550 $; DONE IF READ
27m0141 05546 640720000571000220000000	        D[AR] MASK[18.] DEST[MA] SHORT $;GET ORRIG. MA
27m0141 05547 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
27m0141 05550 640144274571000440002033	        D[17] DEST[MEMSTO] JUMP[MSMAIN1] NORM $; STORE THE STORE DATA, & PROCEDE
27m0141 05551 640720000571000220000000	JSMFR:  D[AR] MASK[18.] DEST[MA] NORM $
27m0141 05552 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
27m0141 05553 640150074571000440004464	        D[17] DEST[AR] JUMP[MUJSM1] NORM $; RESTORE STORE DATA
27m0141                               	
27m0141 05554 530140004571022010000000	MFTR1:  D[MEM] ROT[11] MASK[1] COND[-OBUS=0] JUMP[MFTR9] C550 $; J IF TRAP TO USER
27m0141 05555 530140004571024010000000	        D[MEM] ROT[12] MASK[1] COND[-OBUS=0] JUMP[MFTR10] C550 $;J IF WRT TRAP
27m0141 05556 640140004571000440000000	        D[MEM] JUMP[MFTR2] NORM $; TREAT BOTH "TRAP-TO-MON" CODES AS IMMEDIATE
27m0141 05557 510140000571040010005456	MFTR10: D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFB3] C550 $; WRT RQ? J IF NO
27m0141 05560 640700014171074440000000	        D[CONST 44] ROT[36] DEST[Q] SHORT $; GET ERROR CODE BITS -- WRT TRAP
27m0141                               	MFB5:
27m0141 05561 645150000175000440005563	MFB4:   D[AR] ALU[DORQ] DEST[AR Q] COND[USER] JUMP[. + 2] NORM $; OR ERROR BITS IN, J IF
27m0141                               	 USER MODE
27m0141 05562 640710014575044010000000	        D[CONST 1] ROT[18.] ALU[DORQ] DEST[AR] NORM $; TURN ON EXEC BIT
27m0141 05563 640700014171014050000000	        D[CONST 5] ROT[6] DEST[Q] SHORT $
27m0141 05564 640700014175000710000000	        D[CONST 71] ALU[DORQ] DEST[Q] SHORT $; FORM 571
27m0141 05565 640722660575000440000000	        D[14] ALU[DORQ] DEST[MA HI-ABS-MA] SHORT $; ADD PSB (MON BASE TAB)
27m0141 05566 640704200571000440000000	        D[AR] DEST[MEMSTO] CYLEN[FIXM] $; STORE ERROR BITS THERE
27m0141 05567 510140000571040010000000	        D[AR] ROT[20] MASK[1] COND[OBUS=0] JUMP[MFC1] C550 $; J IF NO WRT RQ
27m0141 05570 530140000571036010000000	        D[AR] ROT[17] MASK[1] COND[-OBUS=0] JUMP[MFC1] C550 $; J IF RD RQ
27m0141 05571 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] SHORT $; GO TO 572
27m0141 05572 640704274571000440000000	        D[17] DEST[MEMSTO] NORM $; SAVE STORE DATA
27m0141 05573 640701600615000440000000	MFC1:   ALU[0] DEST[DEV-ADR] CYLEN[MEMSTO] $
27m0141 05574 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $; TURN OFF MAP
27m0141 05575 440702600615000440100000	        MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $
27m0141 05576 640720014571000700000000	        D[CONST 70] DEST[MA] SHORT $; FETCH TRAP INSTR
27m0141 05577 640701600615000440000000	        ALU[0] DEST[DEV-ADR] CYLEN[FIXM] $
27m0141 05600 640702274571000443600000	        D[10 + APRENB] DEST[IOD] SPEC[IOB-OUT] SHORT $; TURN ON MAP
27m0141 05601 440710020171000440100000	        D[PC] DEST[Q AR] MAPF[10] CYLEN[IOB-OUT] $
27m0141 05602 640705410635076430000000	        D[MASK 43] ROT[37] ALU[D&Q] DEST[CRYOV] NORM $;CLR USER
27m0141 05603 640140014171004550002106	        D[CONST 55] ROT[2] DEST[Q] JUMP[MUUO44] NORM $
27m0141 05604 640140014171074410005561	MFTR2:  D[CONST 41] ROT[36] DEST[Q] JUMP[MFB5] NORM $; ASCCESS PERMISSION TRAP
27m0141                               	MTRPAL:
27m0141 05605 640700014171074400000000	MFTR3:  D[CONST 40] ROT[36] DEST[Q] SHORT $
27m0141 05606 640140014175066010005561	        D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB5] NORM $; ILLEGAL PT ENTRY TYPE,
27m0141                               	 ADDRESS LIMIT
27m0141                               	MFTR4:  ;ALL THESE ARE NOT-IN-CORE
27m0141 05607 640140014171074220005561	MFTR5:  D[CONST 22] ROT[36] DEST[Q] JUMP[MFB5] NORM $; NOT-IN-CORE
27m0141 05610 510140014635000050005613	MFTR6:  D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[. + 3] C550 $; J IF NO R OR X ERROR
27m0141 05611 640700014175066040000000	        D[CONST 4] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN "R OR X ERROR" BIT
27m0141 05612 510140014635000020005614	        D[CONST 2] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] C550 $; J IF NO W ERROR
27m0141 05613 640700014175066020000000	        D[CONST 2] ROT[33] ALU[DORQ] DEST[Q] SHORT $; OR IN W ERROR BIT
27m0141 05614 640700014275000070000000	        D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

27m0141 05615 640140014175074400005561	        D[CONST 40] ROT[36] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; GROUP 2
27m0141 05616 640140014171074100005561	MFTR7:  D[CONST 10] ROT[36] DEST[Q] JUMP[MFB4] NORM $; AGE ERR -- GROUP 0
27m0141 05617 640140014171074420005561	MFTR9:  D[CONST 42] ROT[36] DEST[Q] JUMP[MFB4] NORM $; USER TRAP
27m0141 05620 640700014171074200000000	MFTR41: D[CONST 20] ROT[36] DEST[Q] NORM $; GROUP 1
27m0141 05621 640140014175066010005561	        D[CONST 1] ROT[33] ALU[DORQ] DEST[Q] JUMP[MFB4] NORM $; TOO MANY INDR. PNTRS
27m0141                               	;------------------------------------------------------------------------------
27m0141                               	;Reset map.  Clear entire map to zero.  This is because even though the map
27m0141                               	;will stop stores from happening, fetches still happen irregardless of state
27m0141                               	;of map and if map points at non-existent memory (on for example, an immediate
27m0141                               	;mode instruction), the machine will get a spurious ECC interrupt.
27m0141                               	;
27m0141                               	;It is assumed that the device address is set to 1 when this thing is called.
27m0141                               	;------------------------------------------------------------------------------
27m0141 05622 640705614571022000000000	MAPRST: SET-TEMP-EXEC $
27m0141                               	                ;Begin at the beginning of EXEC space.
27m0141 05623 640700014171022010000000	        D[CONST 1] ROT[9.] DEST[Q] SHORT $
27m0141                               	                ;Increment for MA
27m0141 05624 640720014537044010000000	MAPRSS: D[CONST 1] ROT[18.] ALU[D-Q] DEST[MA] NORM $
27m0141                               	                ;Start at the top and work down.
27m0141                               	MAPRSL:
27m0141                               	.REPEAT 1 - NEWMAP [
27m0141                               	        D[CONST 1] ROT[35. - 9.] DEST[STO-MAP] NORM $
27m0141                               	                ;Set mapping to zero, Invalid
27m0141                               	        D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 1] C550 $
27m0141                               	                ;Repeat for each page in this space.
27m0141                               	];.REPEAT 1 - NEWMAP
27m0141                               	.REPEAT NEWMAP [
27m0141                               	        START-OUT SHORT $
27m0141                               	        MAPF[2] D[CONST 1] ROT[35. - 9.] NORM $
27m0141                               	                ;Set mapping to zero, Invalid
27m0141                               	        D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 2] C800 $
27m0141                               	                ;Repeat for each page in this space
27m0141                               	];[
27m0141 05625 640700000571000443600000	        START-OUT SHORT $
27m0141 05626 640700014571064010020000	        MAPF[2] D[CONST 1] ROT[35. - 9.] NORM $
27m0141                               	                ;Set mapping to zero, Invalid
27m0141 05627 262160024537000440005625	        D[MA] ALU[D-Q] DEST[MA] COND[-MA-AC] JUMP[. - 2] C800 $
27m0141                               	                ;Repeat for each page in this space
27m0141                               	].REPEAT NEWMAP
27m0141 05630 665145614571022170005624	        SET-TEMP-USER COND[-USER] JUMP[MAPRSS] $
27m0141                               	                ;Repeat once more if currently doing EXEC space. This
27m0141                               	                ;time for USER space.  We can do this because EXEC-SR is
27m0141                               	                ;latched at the end of the cycle.
27m0141 05631 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $
27m0141 05632 640702214571000013600000	        D[CONST 1] DEST[IOD] SPEC[IOB-OUT] NORM $
27m0141 05633 440702014571000030140000	        MAPF[14] CYLEN[IOB-OUT] D[CONST 3] DEST[MAP-DISP] $
27m0141 05634 000303600571000440000000	        DEST[CLR-MI-ERR] POPJ $ ;Done
27m0141                               	
27m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

28m0141                               	;JSYS1 JSYS2 UMOVX XCT1 XCTUMV XCT5 XCT4 XCT6 XCT3 XCT13 XCT18 XCT12 XCT11 XDISP XCT2
28m0141                               	 XCTAC XCTSTK XCTS1 XCTS2 XCT10 XCTBLG XCTBYT XBY1 XBY4 XBY15 XBY14 XBY13 XBY3
28m0141                               	;------------------------------------------------------------------------------
28m0141                               	;
28m0141                               	;       BBN added instructions.  Sometimes used by other than TENEX
28m0141                               	;
28m0141                               	;------------------------------------------------------------------------------
28m0141 05635 640706000550400440020000	JSYS1:  FIXM1 $
28m0141 05636 640710020571000440000000	        D[PC] DEST[AR] NORM $   ;SAVE PC & FLAGS
28m0141 05637 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; JUMP TO RIGHT HALF
28m0141 05640 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $
28m0141 05641 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
28m0141 05642 510140014635074010005644	JSYS2:  C550 D[CONST 1] ROT[36] ALU[D&Q] COND[OBUS=0] JUMP[. + 2] $; J IF EXEC MODE
28m0141 05643 640705600615000440000000	        ALU[0] DEST[MAP-EXEC-SR]  NORM $; TEMP TURN OFF USER
28m0141 05644 640700014171014100000000	        D[CONST 10] ROT[6] DEST[Q] SHORT $
28m0141 05645 640720024575000440000000	        D[MA] ALU[DORQ] DEST[MA] SHORT $; FETCH POINTER WORD
28m0141 05646 640706000550400440020000	        FIXM1  $
28m0141 05647 640704604571000220000000	        D[MEM] MASK[18.] DEST[PC] NORM $; J TO RIGHT HALF
28m0141 05650 640700020171000440000000	        D[PC] DEST[Q] SHORT $
28m0141 05651 511140000571012440005653	        D[AR] ROT[5] C550 COND[OBUS<0] JUMP[. + 2] $
28m0141                               	                ;If we came from exec mode, then we...
28m0141 05652 640700014175070010000000	        D[CONST 1] ROT[34] ALU[DORQ] DEST[Q] SHORT $
28m0141                               	                ; ...TURN ON FLAG BIT 7
28m0141 05653 640705414675074010000000	        D[CONST 1] ROT[36] ALU[-D&Q] DEST[CRYOV] SHORT $; TURN OFF USER
28m0141 05654 640720004571044220000000	        D[MEM] ROT[18.] MASK[18.] DEST[MA] SHORT $; LEFT HALF
28m0141 05655 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMSTMA  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$; STORE PC
28m0141                               	
28m0141                               	  .DEFINE JCFM [JAD]
28m0141                               	[       D[PC] ROT[10] MASK[1] COND[-OBUS=0] JUMP[JAD] C550 $;J IF CALL FM MON]
28m0141                               	
28m0141 05656 645140000571000440002100	UMOVX:  COND[USER] JUMP[MUUO] NORM $
28m0141 05657 640700004171000440000000	        D[MEM] DEST[Q] NORM $
28m0141 05660 640704414435102010000000	        D[CONST 1] ROT[41] ALU[D+Q] DEST[HOLD] NORM $
28m0141 05661 640140014171000050000000	        D[CONST 5] DEST[Q] JUMP[XCTUMV] NORM $
28m0141                               	
28m0141                               	;------------------------------------------------------------------------------
28m0141                               	;
28m0141                               	;       XCTR - Execute Relocated
28m0141                               	;
28m0141                               	;       If in Exec mode and the AC field of the XCT instruction is non-zero,
28m0141                               	;       it means do some of the references from User mode if PC bit (?),
28m0141                               	;       meaning JSYS from Moniter, is not set.
28m0141                               	;
28m0141                               	;       This code is not map dependent, although other maps (like ITS) may code
28m0141                               	;       the bits in the AC field differently, requiring some rewriting.
28m0141                               	;
28m0141                               	;       Warning:  This code is complex and prone to bugs.  Many probably lurk
28m0141                               	;                 in the cracks.  If you find one, please document it even if
28m0141                               	;                 no solution seems to appear.
28m0141                               	;------------------------------------------------------------------------------
28m0141 05662 640704620531000440000000	XCT1:   D[PC] ALU[D-1] DEST[PC] NORM $
28m0141 05663 645140000571000440000000	        COND[USER] JUMP[XCT2] NORM $
28m0141 05664 640700034171032040000000	        D[IR] ROT[15] MASK[4] DEST[Q] SHORT $; SAVE XCT AC FLD
28m0141 05665 664170604571000440000000	XCTUMV: D[MEM] DEST[AR IR-ALL MA] COND[-MEM-IDX-IND] JUMP[XCT3] NORM $
28m0141 05666 510140034571044040020000	XCT5:   D[IR] ROT[18.] MASK[4] COND[OBUS=0] JUMP[XCT4] C550 MAPF[2] $; J IF NO IDX FLD
28m0141 05667 000730234420400220000000	        D[IR] MASK[18.] ALU[IX+D] DEST[MA IR-ADR AR] $; DO INDEX
28m0141 05670 510140034571034010020000	XCT4:   D[IR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XCT3] C550 MAPF[2] $; J IF NO INDR
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

28m0141 05671 530040014635000100000000	        D[CONST 10] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF ADDR CALC USER
28m0141                               	
28m0141                               	XCT6:
28m0141 05672 640706000550400440010000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[NORM-IND] CYLEN[FIXM] $
28m0141                               	;;;     FIXM1 $
28m0141                               	;;;             ;It was overdecrementing PC  TVR-Mar80
28m0141 05673 640705614571022000000000	        SET-TEMP-EXEC $
28m0141 05674 644170404571000440005666	        D[MEM] DEST[AR IR-23 MA] COND[MEM-IDX-IND] JUMP[XCT5] NORM $
28m0141 05675 640700200555000440020000	XCT3:   ALU[Q] DEST[IR-ADR] SHORT  MAPF[2] $; SAVE XCT AC FLD
28m0141 05676 640700034171016070000000	        D[IR] ROT[7] MASK[7] DEST[Q] SHORT $; GET HO 7 BITS OF OPCODE
28m0141 05677 510140014735000540000000	        D[CONST 54] ALU[D#Q] COND[OBUS=0] JUMP[XCTSTK] C550 $; J IF STACK GROUP
28m0141 05700 510140014735000270000000	        D[CONST 27] ALU[D#Q] COND[OBUS=0] JUMP[XCTBYT] C550 $; J IF BYTE GROUP
28m0141 05701 510140014735000520000000	        D[CONST 52] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLG] C550 $; J IF GROUP WITH BLT IN IT
28m0141                               	
28m0141 05702 640700034171000040000000	XCT13:  D[IR] MASK[4] DEST[Q] SHORT $; GET XCT AC FLD
28m0141 05703 510140014635000050000000	XCT18:  D[CONST 5] ALU[D&Q] COND[OBUS=0] JUMP[XDISP] C550 $; J IF NEITHER RELEVANT BIT
28m0141 05704 642140000571000440000000	        COND[MA-AC] JUMP[XCT10] NORM $; J IF EF ADR IS AC
28m0141                               	        JCFM[XDISP] 
28m0141 05705 530140020571020010000000	[       D[PC] ROT[10] MASK[1] COND[-OBUS=0] JUMP[XDISP] C550 $;J IF CALL FM MON];J IF
28m0141                               	 CALL FM MON
28m0141 05706 510140014635000010000000	        D[CONST 1] ALU[D&Q] COND[OBUS=0] JUMP[XCT11] C550 $;J IF BIT OFF
28m0141 05707 510140014635000040000000	        D[CONST 4] ALU[D&Q] COND[OBUS=0] JUMP[XCT12] C550 $; J IF OTHER BIT OFF
28m0141 05710 640145614571022030000000	        D[CONST 03] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET SRC & DEST TO USER
28m0141                               	
28m0141 05711 640145614571022020000000	XCT12:  D[CONST 02] ROT[11] DEST[MAP-EXEC-SR] JUMP[XDISP] NORM $; SET DEST TO USER
28m0141 05712 640705614571022010000000	XCT11:  D[CONST 01] ROT[11] DEST[MAP-EXEC-SR] NORM $; SET SRC TO USER
28m0141 05713 540520224571000441602000	XDISP:  D[MA] DEST[MA IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141 05714 540530604571000441602174	XCT2:   D[MEM] DEST[IR-ALL AR MA] DISP[2174] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141                               	XCTAC:
28m0141                               	.REPEAT 1 - WAITS [
28m0141                               	        ACSEL[AC] ALU[AC] DEST[HOLD]  SHORT $; SAVE AC
28m0141                               	        ACSEL[AC] DEST[CLR-DEV-FROM-INTR AC] D[MA] SHORT $; GET AC ADDRS
28m0141                               	        D[CONST 1] DEST[DEV-ADR] SHORT $
28m0141                               	        ACSEL[AC] D[13] ALU[D+AC] DEST[AC] SHORT $; ADD IN AC BASE REG.
28m0141                               	        ACSEL[AC] D[CONST 75] ROT[11] ALU[D+AC] DEST[AC] SHORT $
28m0141                               	        ACSEL[AC] D[CONST 7] ROT[17] ALU[D+AC] DEST[AC] NORM $
28m0141                               	        D[MEM] ACSEL[AC] DEST[O_AC MA] POPJ NORM $
28m0141                               	];[
28m0141 05715 640704400551000440000000	        ACSEL[AC] ALU[AC] DEST[HOLD]  SHORT $; SAVE AC
28m0141 05716 640702425571000440000000	        ACSEL[AC] DEST[CLR-DEV-FROM-INTR AC] D[MA] SHORT $; GET AC ADDRS
28m0141 05717 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] SHORT $
28m0141 05720 640700055421000440000000	        ACSEL[AC] D[13] ALU[D+AC] DEST[AC] SHORT $; ADD IN AC BASE REG.
28m0141 05721 640700015421022750000000	        ACSEL[AC] D[CONST 75] ROT[11] ALU[D+AC] DEST[AC] SHORT $
28m0141 05722 640700015421036070000000	        ACSEL[AC] D[CONST 7] ROT[17] ALU[D+AC] DEST[AC] NORM $
28m0141 05723 640320005171000440000000	        D[MEM] ACSEL[AC] DEST[O_AC MA] POPJ NORM $
28m0141                               	].REPEAT 1 - WAITS
28m0141                               	.REPEAT WAITS [
28m0141                               	        D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $; LEAVE IF CALL FM MON
28m0141                               	        ACSEL[AC] D[MA] DEST[O_AC HOLD] $
28m0141                               	                ;Get address of AC, we need to mung it
28m0141                               	                ;Save AC, we can't use Q for some reason [???]
28m0141                               	        ACSEL[AC] D[CONST 77] ROT[9. + 3.] ALU[D+AC] DEST[AC] NORM $
28m0141                               	                ;Add page number of window
28m0141                               	                ;Use 770xxx for window into user ACs
28m0141                               	        D[MEM] ACSEL[AC] DEST[O_AC MA CLR-DEV-FROM-INTR] NORM $
28m0141                               	                ;Restore AC and set MA from AC to start read
28m0141                               	.REPEAT 1 - NEWMAP [
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

28m0141                               	        D[CONST 1] DEST[DEV-ADR] NORM $
28m0141                               	                ;Select appropriate A-MEM
28m0141                               	        D[13] ROT[9.] MASK[36. - 13.] DEST[STO-MAP] COND[OBUS=0] JUMP[.] NORM $
28m0141                               	                ;Extract address and position for map
28m0141                               	                ;Not R,W,X excluded.  Not NO ENTRY AT ALL
28m0141                               	                ;Hang if attempt to reference user ACs with no shadow
28m0141                               	                ;memory defined at time of CONO PAG,
28m0141                               	];.REPEAT 1 - NEWMAP
28m0141                               	.REPEAT NEWMAP [
28m0141                               	        D[CONST 1] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
28m0141                               	                ;Select appropriate A-MEM
28m0141                               	                ;Set place in map to write it and start map write
28m0141                               	        MAPF[2] ROT[9.] MASK[36. - 13.] COND[OBUS=0] JUMP[.] NORM $
28m0141                               	                ;Finish map write.
28m0141                               	                ;Not R,W,X excluded.  Not NOT ENTRY AT ALL
28m0141                               	                ;Hang if attempt to reference user ACs with no shadow
28m0141                               	                ;memory defined at time of CONO PAG,
28m0141                               	];.REPEAT NEWMAP
28m0141                               	        D[MA] DEST[MA] POPJ NORM $
28m0141                               	];.REPEAT WAITS
28m0141                               	XCTSTK:
28m0141                               	;;;     COND[-MA-AC] JUMP[XCT13] NORM $; J IF EF ADR NOT AC (TREAT NORMALLY)
28m0141 05724 510140034171022020005702	        D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LOW ORDER
28m0141                               	 BITS OF OP CODE, J IF PUSHJ
28m0141 05725 510140014735000030005702	        D[CONST 3] ALU[D#Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF POPJ
28m0141                               	.repeat 0[
28m0141                               	        D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XCTS1] C550 $; J IF POP
28m0141                               	        D[CONST 4] DEST[Q] JUMP[XCTS2] NORM $
28m0141                               	XCTS1:  D[CONST 1] DEST[Q] SHORT $
28m0141                               	XCTS2:  D[IR] ALU[D&Q] COND[OBUS=0] JUMP[XCT13] C550 $; J IF AC REF NOT USER
28m0141                               	        D[IR] ALU[D-Q] DEST[IR-ADR] PUSHJ[XCTAC] NORM $; FIX EF ADR.
28m0141                               	        MAPF[2] JUMP[XCT13] NORM $
28m0141                               	];.repeat 0
28m0141 05726 510140014735000020000000	        D[CONST 2] ALU[D#Q] COND[OBUS=0] JUMP[XPOP1] C550 $; J IF POP
28m0141 05727 640140000571000440000000	        JUMP[XPUSH1] NORM $
28m0141                               	                ;Someday, move code over here (when we have space)
28m0141                               	
28m0141 05730 640040000571000440005715	XCT10:  PUSHJ[XCTAC] NORM $; FIX EF ADR
28m0141 05731 540500224571000041622000	        MAPF[2] D[MA] MASK[4] DEST[IR-ADR] DISP[2000] SPEC[PC+1-IF] CYLEN[DISP] $
28m0141 05732 510140034171022020005702	XCTBLG: D[IR] ROT[11] MASK[2] DEST[Q] COND[OBUS=0] JUMP[XCT13] C550 $; GET 2 LO BITS OF
28m0141                               	 OPCODE, J IF EXCH
28m0141 05733 510140014735000010000000	        D[CONST 1] ALU[D#Q] COND[OBUS=0] JUMP[XCTBLT] C550 $; J IF BLT
28m0141 05734 640140034171000040005703	        D[IR] MASK[4] DEST[Q] JUMP[XCT18] NORM $; GET XCT AC FLD, PROCEDE
28m0141                               	
28m0141 05735 530040034571104012000000	XCTBYT: D[IR] ROT[42] MASK[1] SPEC[PC+1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF
28m0141                               	 B.P. FETCH IS NOT EXEC
28m0141 05736 510140034571022010020000	XBY1:   D[IR] ROT[11] MASK[1] COND[OBUS=0] JUMP[XBY3] C550 MAPF[2] $;J IF BP WILL BE INCR
28m0141                               	
28m0141 05737 640706000550400440020000	        FIXM1 $
28m0141 05740 640710004171000440000000	        D[MEM] DEST[AR Q] NORM $; GET BP
28m0141 05741 640705614571022000000000	XBY4:   SET-TEMP-EXEC $
28m0141 05742 664160000571000220000000	        D[AR] MASK[18.] DEST[MA] COND[-MEM-IDX-IND] JUMP[XBY13] NORM $; J IF BP HAS NO
28m0141                               	 IDX OR INDR
28m0141 05743 510141000571044040020000	XBY15:  D[AR] ROT[18.] MASK[4] DEST[AC-SEL] COND[OBUS=0] JUMP[XBY14] C550 MAPF[2] $; J IF
28m0141                               	 NO IX FLD
28m0141 05744 640700010235044220000000	        D[MASK 22] ROT[18.] ALU[D&Q] DEST[Q] NORM $
28m0141 05745 640710000420000220000000	        D[AR] MASK[18.] ACSEL[REG] ALU[D+AC] DEST[AR] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

28m0141 05746 640730000175000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[Q AR MA] SHORT $
28m0141 05747 510140000571034010020000	XBY14:  D[AR] ROT[16] MASK[1] COND[OBUS=0] JUMP[XBY13] C550 MAPF[2] $; J IF NO INDR
28m0141 05750 530040034571106010000000	        D[IR] ROT[43] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; PUSHJ IF BP ADR CALC IS
28m0141                               	 USER
28m0141 05751 640706000550400440020000	        FIXM1 $
28m0141 05752 640705614571022000000000	        SET-TEMP-EXEC $
28m0141 05753 640710000571030140000000	        D[AR] ROT[14] MASK[14] DEST[AR] SHORT $
28m0141 05754 640700000171060440000000	        D[AR] ROT[30] DEST[Q] SHORT $
28m0141 05755 644170004175000270005743	        D[MEM] MASK[27] ALU[DORQ] DEST[Q AR MA] COND[MEM-IDX-IND] JUMP[XBY15] NORM $
28m0141 05756 030040034571000010020000	XBY13:  D[IR] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] MAPF[2] $; MAKE MA OK
28m0141 05757 510140034571020010022625	        D[IR] ROT[10] MASK[1] COND[OBUS=0] JUMP[LDB5] C550 MAPF[2] $; DISTINGUISH LOADS
28m0141                               	 FROM DEPOSITS, J IF LOAD
28m0141 05760 640140000571000440002637	        JUMP[DPB5] NORM $
28m0141                               	
28m0141 05761 640706200550400440030000	XBY3:   FIXM2 $
28m0141 05762 656150004171000440005741	        D[MEM] DEST[AR Q] COND[HALF] JUMP[XBY4] NORM $;GET BP, J IF NO INCR
28m0141 05763 657051400571030060004035	        D[AR] ROT[14] MASK[6] DEST[AR MASKR] COND[BYTE-OVF] PUSHJ[IBT1] NORM $; GET S
28m0141                               	 FLD, HANDLE OVERFLOW
28m0141 05764 662154200077074440005766	        D[AR] ROT[36] ALU[Q-D] DEST[Q AR MEMSTO] COND[-MA-AC] JUMP[. + 2] NORM $; SUB S
28m0141                               	 FROM P
28m0141 05765 640700005570400440000000	        ACSEL[MA] D[MEM] DEST[AC] NORM $
28m0141 05766 640040000571000440006146	        PUSHJ[SETHLF] NORM $; SET HALF
28m0141 05767 640140000571000440005741	        JUMP[XBY4] NORM $; (IN CASE OF MAP FAULTS)
28m0141                               	
28m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

29m0141                               	;XFIXMA XCTBLT XBLTL XPUSH1 XPDLO2 XPOP1 XPOP2 XPOP3
29m0141 05770 642140000571000440005715	XFIXMA: COND[MA-AC] JUMP[XCTAC] NORM $; J IF ADDRS IS AC
29m0141 05771 530300020571020010020000	        D[PC] ROT[10] MASK[1] COND[-OBUS=0] POPJ C550 MAPF[2] $; LEAVE IF CALL FM MON
29m0141 05772 640705614571022170000000	        SET-TEMP-USER $
29m0141 05773 640320024571000440000000	        D[MA] DEST[MA] POPJ NORM $
29m0141                               	
29m0141                               	;;;;;.USE[OTHER]  DWP 9-19-80
29m0141                               	
29m0141 05774 640710025171000442000000	XCTBLT: D[MA] SPEC[PC+1] DEST[O_AC AR] NORM $; END ADR IN AC, AC IN AR
29m0141 05775 640720000571044220000000	XBLTL:  D[AR] ROT[18.] MASK[18.] DEST[MA] SHORT $; GET WORD
29m0141 05776 530040034571104010005770	        D[IR] ROT[42] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $; FIX IF USER ADDRS
29m0141 05777 640706000550400440070000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[BLT-RDA] CYLEN[FIXM] $
29m0141 06000 640700004171000440000000	        D[MEM] DEST[Q] SHORT $; GET DATA WORD
29m0141 06001 640720000571000220000000	        D[AR] MASK[18.] DEST[MA] SHORT $; GET DEST ADR
29m0141 06002 530045634571000010005770	        D[IR] MASK[1] DEST[MAP-EXEC-SR] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $;FIX MA ADDRS
29m0141 06003 640704200555000440000000	        ALU[Q] DEST[MEMSTO] SHORT $
29m0141 06004 471140000523000220144344	        D[AR] MASK[18.] ALU[D-AC] MAPF[BLT-WRTB] COND[-OBUS<0] JUMP[BLTA12] C600 $
29m0141 06005 662145614171001000006007	        D[CONST 1,,1] DEST[Q MAP-EXEC-SR] COND[-MA-AC] JUMP[. + 2] NORM $
29m0141 06006 640700005570400440000000	        D[MEM] ACSEL[MA] DEST[AC] SHORT $
29m0141 06007 640150000435000440005775	        D[AR] ALU[D+Q] DEST[AR] JUMP[XBLTL] NORM $; TEST FOR INTERPT HERE ? *****
29m0141                               	
29m0141                               	;Special case for PUSH.  Check for AC reference from stack pointer
29m0141 06010 510140034571000010005702	XPUSH1: D[IR] MASK[1] COND[OBUS=0] JUMP[XCT13] C550 $
29m0141                               	                ;If not mapping stack references, it's simple
29m0141 06011 530040034571104012005770	        D[IR] ROT[36. - 2] MASK[1] COND[-OBUS=0] PUSHJ[XFIXMA] SPEC[PC+1] C550$
29m0141                               	                ;Make sure we're referring to the right place here.
29m0141                               	                ;Also, we're now executing the instruction (PC+1)
29m0141 06012 640706000550400440020000	        FIXM1 $ ;Check page faults for effective address part.
29m0141 06013 640710004571000440000000	        D[MEM] DEST[AR] NORM $
29m0141                               	                ;Copy away the thing that we want to push
29m0141 06014 515160015421001000000000	        D[CONST 1,,1] ALU[D+AC] DEST[AC MA] COND[CRY0] JUMP[XPDLO2] C550 $
29m0141                               	                ;Advance frame pointer and check for overflow
29m0141 06015 640040000571000440005770	        PUSHJ[XFIXMA] NORM $
29m0141                               	                ;Decide whether to map destination.
29m0141 06016 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
29m0141                               	                ;Finish instruction. We're done
29m0141 06017 640040000571000440005770	XPDLO2: PUSHJ[XFIXMA] NORM $
29m0141                               	                ;Fixup AC references
29m0141 06020 640140000571000440000000	        JUMP[PDLO2] NORM $
29m0141                               	                ;Done.  Take stack overflow trap
29m0141                               	
29m0141                               	;Special case for POP.  Check for AC reference from stack pointer
29m0141 06021 640700034171022442000000	XPOP1:  D[IR] ROT[11] DEST[Q] NORM SPEC[PC+1] $
29m0141                               	                ;Save bit meaning 'source from user' in format that can
29m0141                               	                ;be fed easily to EXEC-SR
29m0141                               	                ;Now we're executing the PUSH (implied by PC+1)
29m0141 06022 640700224571000440000000	        D[MA] DEST[IR-ADR] NORM $
29m0141                               	                ;Restore normal effective address 
29m0141 06023 640720015063001000000000	        ACSEL[AC] D[CONST 1,,1] ALU[AC-D] DEST[MA O_AC] NORM $
29m0141                               	                ;Update AC and MA for stack reference
29m0141 06024 530040014635022040005770	        D[CONST 4] ROT[11] ALU[D&Q] COND[-OBUS=0] PUSHJ[XFIXMA] C550 $
29m0141                               	                ;Fixup stack addressing if user AC
29m0141 06025 640706000550400440160000	        ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
29m0141                               	                ;Check for page faults
29m0141 06026 640710004571000440000000	        D[MEM] DEST[AR] NORM $
29m0141                               	                ;Find somewhere safer for thing to push
29m0141                               	        D[CONST 1] ROT[11] ALU[D&Q] DEST[MAP-EXEC-SR]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

29m0141 06027 510145614635022010000000	                        COND[OBUS=0] JUMP[XPOP3] C550 $
29m0141                               	                ;Set appropriate mode to do store in
29m0141 06030 640720034571000220000000	        D[IR] MASK[22] DEST[MA] NORM $
29m0141                               	                ;Extract address and fetch it from the appropriate page.
29m0141 06031 642040000571000440005715	        COND[MA-AC] PUSHJ[XCTAC] NORM $
29m0141                               	                ;Fixup AC addressing if needed.  (We can't combine this and
29m0141                               	                ;previous instruction because MA is strobed at end of cycle.
29m0141                               	                ;We can't call XFIXMA because it uses SET-TEMP-USER which
29m0141                               	                ;would affect the next instruction fetch. Sigh...)
29m0141 06032 515140014421001000000000	XPOP2:  D[CONST 1,,1] ALU[D+AC] COND[CRY0] JUMP[PDLO5] C550 $
29m0141                               	                ;Try for overflow again.  Take it if you need it.
29m0141 06033 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
29m0141                               	                ;Write out thing we POP'ped
29m0141 06034 640160034571000220006032	XPOP3:  D[IR] MASK[22] DEST[MA] NORM JUMP[XPOP2] $
29m0141                               	                ;Extract address and don't do anything special about it
29m0141                               	
29m0141                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

30m0141                               	;APRDSP PIDSP AREA53 APRCO APRCO2 APRCO3 APRIEN APRC1 APRC2 APRCHK APRCK1 APDINT APRCI
30m0141                               	 APRCII APRDI APIOT
30m0141                               	;------------------------------------------------------------------------------
30m0141                               	;
30m0141                               	;       APR and PI instructions
30m0141                               	;
30m0141                               	;------------------------------------------------------------------------------
30m0141                               	        .ORG[5300]       [ XLIST
30m0141                               	 LIST ] ;APR & PI IOT DISP TABLE
30m0141                               	APRDSP: ILGIOT 
30m0141 05300 000140000571000440002026	[  JUMP [MAIN] ]$; BLKI APR
30m0141 05301 000700000571000440000000	        NOP $
30m0141 05302 640701600615000440000000	        ALU[0] DEST[DEV-ADR] NORM $; DATAI -- RD SW
30m0141 05303 640142400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] JUMP[APRDI] NORM $
30m0141                               	        ILGIOT 
30m0141 05304 000140000571000440002026	[  JUMP [MAIN] ]$ ;BLKO APR
30m0141 05305 000700000571000440000000	        NOP $
30m0141 05306 000140000571000440002026	        JUMP[MAIN] $; DATAO
30m0141 05307 000700000571000440000000	        NOP $
30m0141 05310 640700034171000130000000	        D[IR] MASK[13] DEST[Q] NORM $; GET CONO BITS
30m0141 05311 640140014275012330000000	        D[CONST 33] ROT[5] ALU[-D&Q] DEST[Q] JUMP[APRCO] NORM $
30m0141 05312 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONI -- GET BITS IN AR & Q
30m0141 05313 662104200571000220002032	        D[AR] MASK[18.] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
30m0141 05314 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONSZ -- GET BITS IN AR & Q
30m0141 05315 640140034171000220004470	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
30m0141 05316 640040000571000440000000	        PUSHJ[APRCI] NORM $; CONSO -- GET BITS IN AR & Q
30m0141 05317 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
30m0141                               	PIDSP:  .REPEAT 3[ ILGIOT $
30m0141                               	        NOP $
30m0141                               	]
30m0141                               	[ ILGIOT 
30m0141 05320 000140000571000440002026	[  JUMP [MAIN] ]$
30m0141 05321 000700000571000440000000	        NOP $
30m0141                               	][ ILGIOT 
30m0141 05322 000140000571000440002026	[  JUMP [MAIN] ]$
30m0141 05323 000700000571000440000000	        NOP $
30m0141                               	][ ILGIOT 
30m0141 05324 000140000571000440002026	[  JUMP [MAIN] ]$
30m0141 05325 000700000571000440000000	        NOP $
30m0141                               	]       ;DATAO PI -- Set lights
30m0141 05326 640041614571000000004444	        D[CONST 0] DEST[DEV-ADR] PUSHJ[SETLTS] NORM $   ;Just like examine...?
30m0141 05327 640140000571000440002026	        JUMP[MAIN] SHORT $
30m0141 05330 640140000571000440004606	        JUMP[PICONO] NORM $; PI CONO
30m0141 05331 000700000571000440000000	        NOP $
30m0141 05332 640040000571000440004637	        PUSHJ[PICONISUB] NORM $; CONI -- GET BITS IN AR & Q
30m0141 05333 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
30m0141 05334 640040000571000440004637	        PUSHJ[PICONISUB] NORM $; CONSZ -- GET BITS IN AR & Q
30m0141 05335 640140034171000220004470	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
30m0141 05336 640040000571000440004637	        PUSHJ[PICONISUB] NORM $; CONSO -- GET BITS IN AR & Q
30m0141 05337 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
30m0141                               	
30m0141                               	
30m0141                               	   .USE[NORMAL]
30m0141                               	 [ XLIST
30m0142                               	 LIST ]
30m0142 04647 640710014675006010000000	APRCO:  D[CONST 1] ROT[3] ALU[-D&Q] DEST[AR] SHORT $
30m0142 04650 640700034371106210000000	        D[IR] ROT[43] MASK[21] ALU[NOTD] DEST[Q] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

30m0142                               	                ; GET CLR BITS
30m0142 04651 640700014275000070000000	        D[CONST 7] ALU[-D&Q] DEST[Q] SHORT $
30m0142                               	                ; Remove PI assignment
30m0142 04652 640702450235000442400000	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[D&Q] DEST[Q CLR-DEV-FROM-INTR] SHORT $
30m0142                               	                ; CLEAR INDICATED BITS
30m0142 04653 640710400575000442600000	        D[AR] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS AR] NORM $
30m0142                               	                ; SET INDICATED BITS & CHAN
30m0142 04654 510140034571102010000000	        D[IR] ROT[41] MASK[1] COND[OBUS=0] JUMP[APRCO2] C550 $
30m0142                               	                ; J IF NO CLR OVERFLOW BIT
30m0142 04655 640705420571000430000000	        D[PC] MASK[43] DEST[CRYOV] SHORT $; CLR OV
30m0142                               	                ; Remove overflow bit from current PC flags
30m0142 04656 510140034571074010000000	APRCO2: D[IR] ROT[36] MASK[1] COND[OBUS=0] JUMP[APRCO3] C550 $
30m0142                               	                ; J IF NO CLR FLT OV
30m0142 04657 640700010171102430000000	        D[MASK 43] ROT[41] DEST[Q] SHORT $
30m0142                               	                ; Remove bit from current PC flags
30m0142 04660 640705420635000440000000	        D[PC] ALU[D&Q] DEST[CRYOV] SHORT $
30m0142                               	                ; CLR FLT OV
30m0142 04661 530040034571066010004510	APRCO3: D[IR] ROT[33] MASK[1] COND[-OBUS=0] PUSHJ[CLKCLR] C550 $
30m0142                               	                ; CLR CLOCK FLAG IF INDICATED
30m0142                               	;       ---
30m0142                               	
30m0142                               	; TEMP **** APRCI:
30m0142 04662 640042400571000440000000	APRIEN: PUSHJ[APRCII] DEST[CLR-DEV-FROM-INTR] NORM $
30m0142                               	                ; GET APR CONI BITS
30m0142 04663 640701614571000013400000	        D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
30m0142                               	                ; Select and read MAP and ECC enablings
30m0142 04664 140700030171000030040000	        D[IOD] MAPF[4] MASK[3] DEST[Q] CYLEN[IOB-IN] $
30m0142 04665 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
30m0142                               	                ; For some pecular reason, the thing we read from device 1 is
30m0142                               	                ; written in device 0???
30m0142 04666 510140000571000030000000	        D[AR] MASK[3] COND[OBUS=0] JUMP[APRC1] C550 $
30m0142                               	                ; Jump if no PI channel.  We don't want to enable arithmetic
30m0142                               	                ; micro-interrupts in that case.
30m0142 04667 510140000571100010000000	        D[AR] ROT[40] MASK[1] COND[OBUS=0] JUMP[APRC1] C550 $
30m0142                               	                ; J IF NO OV INT ENBL
30m0142                               	                ; *** Don't both enables need to be checked???
30m0142 04670 640142214575000023600000	        D[CONST 2] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] JUMP[APRC2] NORM $; ENABLE OV INT
30m0142                               	                ; Turn on arithmetic interrupts
30m0142 04671 640702214675000023600000	APRC1:  D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
30m0142                               	                ; Turn off arithmetic interrupts
30m0142 04672 440140000171000440100000	APRC2:  MAPF[10] CYLEN[IOB-OUT] D[AR] DEST[Q] JUMP[APRCK1] $
30m0142                               	                ; Finish turning arithmetic interrupts off or on, and we're done
30m0142                               	
30m0142                               	;Check for clock interrupts (and other things)
30m0142 04673 640040000571000440000000	APRCHK: PUSHJ[APRCI] NORM $; GET CONI BITS IN AR & Q
30m0142                               	
30m0142                               	APRCK1:
30m0142                               	.REPEAT 1 - WAITS [
30m0142                               	        D[AR] MASK[3] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF PI=0
30m0142                               	        D[AR] ROT[20] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF PDLOV INT
30m0142                               	        D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $; AND MASK WITH FLAG
30m0142                               	        D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF OV INT
30m0142                               	        D[CONST 10] ROT[6] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF NO CLOCK INT
30m0142                               	
30m0142                               	;       \ /
30m0142                               	];[
30m0142 04674 510140000571000030002026	        D[AR] MASK[3] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF PI=0
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

30m0142 04675 530140000571040010000000	        D[AR] ROT[20] MASK[1] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF PDLOV INT
30m0142 04676 640700000235106440000000	        D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $; AND MASK WITH FLAG
30m0142 04677 530140014635006110000000	        D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APDINT] C550 $; J IF OV INT
30m0142 04700 510140014635014100002026	        D[CONST 10] ROT[6] ALU[D&Q] COND[OBUS=0] JUMP[MAIN] C550 $; DONE IF NO CLOCK INT
30m0142                               	
30m0142                               	;       \ /
30m0142                               	].REPEAT 1 - WAITS
30m0142                               	.REPEAT WAITS [
30m0142                               	        D[AR] ROT[27.] COND[OBUS<0] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
30m0142                               	                ;If no APR interrupt is not requested, don't interrupt.
30m0142                               	                ;Otherwise, fall thru
30m0142                               	];.REPEAT WAITS
30m0142                               	
30m0142                               	;       \ /     (Falls thru from APRCK1)
30m0142 04701 640150000171000030004562	APDINT: D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; GET CHAN #, CAUSE INTERRUPT
30m0142                               	
30m0142                               	APRCI:  ;TEMP -- LATER WE FIX OV
30m0142 04702 640040000571000440000000	APRCII: PUSHJ[CLKRDFLG] NORM $
30m0142                               	         ;Get CLOCK FLAG in AR 35, rest of AR = 0
30m0142                               	        .DEFINE APRGBT [R1 R2]
30m0142                               	[       D[PC] ROT[R1] MASK[1] DEST[Q] SHORT $
30m0142                               	        D[AR] ROT[R2] ALU[DORQ] DEST[AR] SHORT $
30m0142                               	]
30m0142                               	        APRGBT[1 6]
30m0142                               	
30m0142 04703 640700020171002010000000	[       D[PC] ROT[1] MASK[1] DEST[Q] SHORT $
30m0142 04704 640710000575014440000000	        D[AR] ROT[6] ALU[DORQ] DEST[AR] SHORT $
30m0143                               	]       APRGBT[4 41]
30m0143                               	
30m0143 04705 640700020171010010000000	[       D[PC] ROT[4] MASK[1] DEST[Q] SHORT $
30m0143 04706 640710000575102440000000	        D[AR] ROT[41] ALU[DORQ] DEST[AR] SHORT $
30m0144                               	]       APRGBT[7 33]
30m0144                               	
30m0144 04707 640700020171016010000000	[       D[PC] ROT[7] MASK[1] DEST[Q] SHORT $
30m0144 04710 640710000575066440000000	        D[AR] ROT[33] ALU[DORQ] DEST[AR] SHORT $
30m0145 04711 640700000171036440000000	]       D[AR] ROT[17] DEST[Q] SHORT $; SET FLAGS
30m0145                               	.REPEAT 1 - WAITS [
30m0145                               	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM POPJ $
30m0145                               	];[
30m0145 04712 640310050175000442400000	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM POPJ $
30m0145                               	].REPEAT 1 - WAITS
30m0145                               	
30m0145                               	.REPEAT WAITS [
30m0145                               	;SAIL's KA-10 has a processor modification which sets bit 27 (400 bit) if the
30m0145                               	;APR is NOT interrupting.  This feature is used in a CONSZ chain and would
30m0145                               	;consume many instructions to simulate in a critical path in the system.
30m0145                               	        D[10 + APRSTS] SPEC[A-MEM-APR] ALU[DORQ] DEST[Q AR] NORM $
30m0145                               	                ;Construct full status
30m0145                               	        D[AR] MASK[3] COND[OBUS=0] JUMP[APRCIN] NORM $
30m0145                               	                ;Set 400 bit if interrupts disabled 
30m0145                               	                ;(This may not be the same as SAIL)
30m0145                               	        D[AR] ROT[20] MASK[1] COND[-OBUS=0] POPJ C550 $
30m0145                               	                ;If pushdown overflow, we will interrupt.
30m0145                               	        D[AR] ROT[43] ALU[D&Q] DEST[Q] SHORT $
30m0145                               	                ;Combine flag with enable to see which interrupts
30m0145                               	        D[CONST 11] ROT[3] ALU[D&Q] COND[-OBUS=0] JUMP[APRCIY] C550 $
30m0145                               	                ;Jump if overflow is causing an interrupt.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

30m0145                               	        D[CONST 10] ROT[6] ALU[D&Q] COND[-OBUS=0] JUMP[APRCIY] C550 $
30m0145                               	                ;Jump if clock is causing an interrupt.
30m0145                               	APRCIN: D[CONST 4] ROT[6] DEST[Q] SHORT $
30m0145                               	                ;Not interrupting, set 400 bit in APR status
30m0145                               	APRCIY: D[AR] ALU[DORQ] DEST[AR Q] POPJ NORM $
30m0145                               	                ;Turn on 400 bit if needed.
30m0145                               	                ;Note, that since we ANDed something with Q, ORing in Q is
30m0145                               	                ;a NO-OP if we didn't go thru APRCIN.
30m0145                               	];.REPEAT WAITS
30m0145                               	
30m0145 04713 162104230571000440022032	APRDI:  MAPF[2] D[IOD] DEST[MEMSTO] COND[-MA-AC] LBJUMP[MSMAIN] CYLEN[IOB-IN] $
30m0145                               	
30m0145                               	        .PAIR
30m0145                               	 [:. \ 2 + .
30m0146                               	]       UIOTRP[MUUO] 
30m0146 04714 010140020571016010002100	[       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
30m0146                               	]$                      ;Trap if not IOT-USER Mode
30m0146                               	APIOT:  IOTDIS[53]
30m0146                               	
30m0146 04715 640700034171034050000000	[       D[IR] ROT[16] MASK[5] DEST[Q] NORM $
30m0146 04716 540540014575014530000000	        D[CONST 53] ROT[6] ALU[DORQ] SDISP CYLEN[C500] $
30m0147                               	]
30m0147                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

31m0147                               	;PDLO1 PDLO2 PDLO5 PDLO3 PDLO4 PDLO6 PDLMEM PDLOE PDLO SOED STOPS SOVRS SECCS SOEDOV
31m0147                               	
31m0147 04717 640040000571000440000000	PDLO1:  PUSHJ[PDLO] NORM $ ;SET PDLO BIT
31m0147 04720 640714220571000440000000	        D[PC] DEST[AR MEMSTO] NORM $
31m0147 04721 662104634571000222370000	        MAPF[MASTO] D[IR] MASK[18.] SPEC[CLR-HALF] DEST[PC] COND[-MA-AC] LBJUMP[PDLMEM]
31m0147                               	 NORM $
31m0147 04722 640040000571000440000000	PDLO2:  PUSHJ[PDLO] NORM $; SET FLAG
31m0147 04723 662104200571000440000000	PDLO5:  D[AR] DEST[MEMSTO] COND[-MA-AC] LBJUMP[PDLMEM] NORM $
31m0147 04724 640706000550400440160000	PDLO3:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
31m0147 04725 640050004571000440000000	        D[MEM] DEST[AR] PUSHJ[PDLO] NORM $
31m0147 04726 640160034571000220004723	        D[IR] MASK[18.] DEST[MA] JUMP[PDLO5] NORM $
31m0147 04727 640706000550400440160000	PDLO4:  ACSEL[MA] ALU[AC] DEST[FIXMAC-MAPF-RD] MAPF[PPOP] CYLEN[FIXM] $
31m0147 04730 640040000571000440000000	        PUSHJ[PDLO] NORM $
31m0147 04731 640144604571000220000000	        D[MEM] MASK[18.] DEST[PC] JUMP[PDLOE] NORM $
31m0147                               	;PDLOV from ADJSP
31m0147 04732 640040000571000440000000	PDLO6:  PUSHJ[PDLO] NORM $
31m0147 04733 640140000571000440000000	        JUMP[PDLOE] NORM $
31m0147                               	
31m0147                               	        .PAIR
31m0147                               	 [:. \ 2 + .
31m0148 04734 640700005570400440170000	]PDLMEM:        ACSEL[MA] D[MEM] DEST[AC] CYLEN[MEMSTO] MAPF[MASTO] $
31m0148                               	PDLOE:  MAPF[MASTO] D[10 + APRSTS] MASK[3] DEST[AR] SPEC[A-MEM-APR]
31m0148 04735 640150050571000032574562	        JUMP[PIGEN] NORM $; CHAN # IN AR, TRY INTERRUPT
31m0148                               	
31m0148 04736 640700050171000442400000	PDLO:   D[10 + APRSTS] SPEC[A-MEM-APR] DEST[Q] NORM $; APR CONI WORD
31m0148                               	        D[CONST 1] ROT[20] ALU[DORQ] SPEC[A-MEM-APR&DEST-A-MEM] DEST[APRSTS]
31m0148 04737 640300414575040012600000	                        NORM POPJ $
31m0148                               	                ;SET PDLOV BIT
31m0148                               	
31m0148                               	        .USE[AREA53]
31m0148                               	 [ XLIST
31m0149                               	 LIST ]
31m0149                               	.REPEAT F3SW [
31m0149                               	
31m0149                               	SOED:   D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
31m0149                               	        D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
31m0149                               	        D[CONST 1] ROT[25] ALU[D&Q] COND[OBUS=0] JUMP[DOHALT] C600 $
31m0149                               	        D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] C550 $; J IF NO OV
31m0149                               	        D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
31m0149                               	        D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
31m0149                               	
31m0149                               	        D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
31m0149                               	.REPEAT 1 - XUCODE [
31m0149                               	        D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149                               	          NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
31m0149                               	];.REPEAT 1 - XUCODE
31m0149                               	.REPEAT XUCODE [
31m0149                               	        D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149                               	          NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
31m0149                               	];.REPEAT XUCODE
31m0149                               	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
31m0149                               	        D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $
31m0149                               	
31m0149                               	        ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
31m0149                               	        D[MEM] DEST[Q] NORM $
31m0149                               	        D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
31m0149                               	        D[AR] ALU[D+1] DEST[ECCSVP] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

31m0149                               	        SPEC[IOB-IN] D[CONST 1] DEST[DEV-ADR] NORM $
31m0149                               	         ;NOW READ STATE OF MAP ON, OV ENBL, ETC.
31m0149                               	        D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
31m0149                               	         ;PRESERVE IN IR.
31m0149                               	        ALU[0] DEST[DEV-ADR] SHORT $
31m0149                               	;;;     D[IR] ROT[31.] COND[OBUS<0] PUSHJ[ECC-UNC] C550 $
31m0149                               	         ;IF ERROR WAS UNCORRECTABLE, GO SEE ABOUT INTERRUPTING.
31m0149                               	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
31m0149                               	        MAPF[2] D[MEM] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
31m0149                               	        MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
31m0149                               	        D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
31m0149                               	        CYLEN[C500] $;WAIT
31m0149                               	        D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
31m0149                               	        NORM $; WAIT -- FOR LUCK
31m0149                               	        D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
31m0149                               	         MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
31m0149                               	        DEST[CLR-MI-ERR] JUMP[MAIN] $  ;CLEAR THE ERROR FLIPFLOP
31m0149                               	
31m0149                               	  ]  ;; END OF .REPEAT F3SW
31m0149                               	
31m0149                               	;(ECC-UNC moved to bottom of page)
31m0149                               	
31m0149                               	 .REPEAT F2SW [ 
31m0149                               	
31m0149                               	STOPS:  D[CONST 1] DEST[DEV-ADR] JUMP[DOHALT] NORM $
31m0149                               	
31m0149                               	SOVRS:  D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] DEST[CLR-DEV-FROM-INTR] C550 $
31m0149                               	                ; J IF NO OV
31m0149                               	        D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
31m0149                               	        D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
31m0149                               	        JUMP[.] $ ; HOW COULD WE GET HERE?
31m0149                               	
31m0149                               	SECCS:  D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
31m0149                               	        D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
31m0149                               	        D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
31m0149                               	.REPEAT 1 - XUCODE [
31m0149                               	        D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149                               	          NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
31m0149                               	];.REPEAT 1 - XUCODE
31m0149                               	.REPEAT XUCODE [
31m0149                               	        D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149                               	          NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
31m0149                               	];.REPEAT XUCODE
31m0149                               	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
31m0149                               	 ;;;;;  D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $
31m0149                               	
31m0149                               	        ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
31m0149                               	        D[MEM] DEST[Q] NORM $
31m0149                               	        D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
31m0149                               	        D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
31m0149                               	        D[CONST 1] DEST[DEV-ADR] NORM $
31m0149                               	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
31m0149                               	        D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
31m0149                               	        ALU[0] DEST[DEV-ADR] SHORT $
31m0149                               	;NOTE:  This conflicts with the use of the lights by diagnostics.
31m0149                               	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
31m0149                               	        MAPF[2] ALU[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

31m0149                               	        MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
31m0149                               	        ALU[Q] DEST[A-MEM-ECC-DATA] DEST-A-MEM NORM $
31m0149                               	          ;Save info for reading via opcode 750.  
31m0149                               	        D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
31m0149                               	        CYLEN[C500] $;WAIT
31m0149                               	        D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
31m0149                               	        NORM $; WAIT -- FOR LUCK
31m0149                               	        D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
31m0149                               	         MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
31m0149                               	        DEST[CLR-MI-ERR] JUMP[MAIN] NORM $
31m0149                               	
31m0149                               	  ] [ 
31m0149                               	
31m0149 06035 640141614571000010004366	STOPS:  D[CONST 1] DEST[DEV-ADR] JUMP[DOHALT] NORM $
31m0149                               	
31m0149 06036 531142420571000443406041	SOVRS:  D[PC] COND[-OBUS<0] SPEC[IOB-IN] JUMP[. + 3] DEST[CLR-DEV-FROM-INTR] C550 $
31m0149                               	                ; J IF NO OV
31m0149 06037 140702430171000440040000	        D[IOD] MAPF[4] DEST[Q CLR-DEV-FROM-INTR] CYLEN[IOB-IN] $
31m0149 06040 530140014635000020000000	        D[CONST 2] ALU[D&Q] COND[-OBUS=0] JUMP[SOEDOV] C550 $ ;J IF OV INT EN
31m0149 06041 000140000571000440006041	        JUMP[.] $ ; HOW COULD WE GET HERE?
31m0149                               	
31m0149 06042 640701614571000013400000	SECCS:  D[CONST 1] DEST[DEV-ADR] SPEC[IOB-IN] NORM $
31m0149 06043 140704430171000440020000	        D[IOD] MAPF[2] DEST[Q HOLD] CYLEN[IOB-IN] $
31m0149 06044 640700054171000042400000	        D[10 + ECCSVP] SPEC[A-MEM-APR] MASK[4] DEST[Q] NORM $
31m0149                               	.REPEAT 1 - XUCODE [
31m0149                               	        D[MASK 8.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149                               	          NORM SPEC[IOB-IN] $  ;;7760 IS NEW LOC. OF ERROR LOG.
31m0149                               	];.REPEAT 1 - XUCODE
31m0149                               	.REPEAT XUCODE [
31m0149                               	        D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149                               	          NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
31m0149                               	];[
31m0149                               	        D[MASK 9.] ROT[4] ALU[DORQ] DEST[AR CLR-DEV-FROM-INTR] 
31m0149 06045 640712410575010113400000	          NORM SPEC[IOB-IN] $  ;;17760 IS NEW LOC. OF ERROR LOG.
31m0149                               	].REPEAT XUCODE
31m0149 06046 140700030171000440040000	        MAPF[4] D[IOD] DEST[Q] CYLEN[IOB-IN] $
31m0149                               	 ;;;;;  D[CONST 1] ROT[7] ALU[D&Q] COND[-OBUS=0] JUMP[.] C550 $
31m0149                               	
31m0149 06047 140707400615000440000000	        ALU[0] DEST[MUCODE-HI] CYLEN[MUSTO] $
31m0149 06050 640700004171000440000000	        D[MEM] DEST[Q] NORM $
31m0149 06051 140707610635052420000000	        D[MASK 42] ROT[25] ALU[D&Q] DEST[MUCODE-LO] CYLEN[MUSTO] $
31m0149 06052 640700600433000442600000	        D[AR] ALU[D+1] DEST[3] SPEC[A-MEM-APR&DEST-A-MEM] NORM $
31m0149 06053 640701614571000010000000	        D[CONST 1] DEST[DEV-ADR] NORM $
31m0149 06054 640702400571000443400000	        DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] SHORT $
31m0149 06055 140700230571000440040000	        D[IOD] DEST[IR-ADR]  MAPF[4] CYLEN[IOB-IN] $
31m0149 06056 640701600615000440000000	        ALU[0] DEST[DEV-ADR] SHORT $
31m0149                               	;NOTE:  This conflicts with the use of the lights by diagnostics.
31m0149 06057 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;PUT JUNK IN LIGHTS
31m0149 06060 440700000555000443620000	        MAPF[2] ALU[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ;LTS_OBUS
31m0149 06061 440703600571000440100000	        MAPF[10] DEST[CLR-MI-ERR] CYLEN[IOB-OUT] $; TURN OFF MAP
31m0149 06062 640700200555000443000000	        ALU[Q] DEST[A-MEM-ECC-DATA] DEST-A-MEM NORM $
31m0149                               	          ;Save info for reading via opcode 750.  
31m0149 06063 640722604571000440000000	        D[MEM] DEST[MA HI-ABS-MA] NORM $; GET DATA
31m0149 06064 540700000571000440000000	        CYLEN[C500] $;WAIT
31m0149 06065 640704204571000440000000	        D[MEM] DEST[MEMSTO] NORM $; RE-STORE IT
31m0149 06066 640700000571000440000000	        NORM $; WAIT -- FOR LUCK
31m0149 06067 640702234571000443600000	        D[IR] DEST[IOD] SPEC[IOB-OUT] NORM $; RESTORE STATE OF MAP, ETC.
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

31m0149 06070 440702600615000440100000	         MAPF[10] ALU[0] DEST[HI-ABS-MA] CYLEN[IOB-OUT] $;
31m0149 06071 640143600571000440002026	        DEST[CLR-MI-ERR] JUMP[MAIN] NORM $
31m0149                               	
31m0149                               	  ];; END OF .REPEAT F2SW
31m0149                               	
31m0149 06072 640701600615000440000000	SOEDOV: ALU[0] DEST[DEV-ADR] NORM $
31m0149 06073 640702214675000023600000	        D[CONST 2] ALU[-D&Q] DEST[IOD] SPEC[IOB-OUT] NORM $; CLR OV INT
31m0149 06074 440040000571000440104702	        MAPF[10] CYLEN[IOB-OUT] PUSHJ[APRCII] $; GET CONI BITS
31m0149 06075 640150000171000030004562	        D[AR] MASK[3] DEST[Q AR] JUMP[PIGEN] NORM $; DO INTR.
31m0149                               	
31m0149                               	;$*$*$*$ No space left in NORMAL by now...
31m0149                               	        .USE[OTHER]
31m0149                               	 [ XLIST
31m0150                               	 LIST ]
31m0150                               	ECC-UNC:  ;SEE IF WE SHOULD GIVE INTERRUPT FOR HARD ECC ERR
31m0150                               	          ;RETURN TO CALLER IF NOT, BUT STILL SET PAR ERR FLAG.
31m0150 06206 640700060171000440000000	        D[14] DEST[Q] NORM $
31m0150                               	         ;FIRST, SET PAR ERR FLAG IN PI CONI BITS.
31m0150                               	        D[CONST 1] ROT[35. - 19.] ALU[DORQ] 
31m0150 06207 640711014575040013000000	                DEST[AR 4] DEST-A-MEM NORM $
31m0150 06210 531300000571036440000000	        D[AR] ROT[35. - 20.] C550 COND[-OBUS<0] POPJ $
31m0150                               	         ;IF PAR ERR INTRPT ENABLE OFF, DO NO MORE.
31m0150 06211 510310050171000030000000	        D[10 + APRSTS] MASK[3] DEST[Q AR] C550 COND[OBUS=0] POPJ $
31m0150                               	         ;IF APR PI CHAN IS 0, DON'T GIVE INTRPT.
31m0150 06212 640343600571000440004562	        DEST[CLR-MI-ERR] NORM JPOP[PIGEN] $ 
31m0150                               	         ;CLEAR ERR FF AND GIVE INTERRUPT ON APR CHANNEL.
31m0150                               	
31m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

32m0150                               	;; 60 HZ CLOCK READING AND INTERRUPT ROUTINES
32m0150                               	
32m0150                               	 .REPEAT OTP [
32m0150                               	  .ORG[2134]            ;INTRPT LOC. FOR DEV. 5
32m0150                               	CLKINT: NORM PUSHJ[CLRDEVINT] $ ;Enable addressing of other devices.
32m0150                               	        D[CONST 1] ALU[NOTD] DEST[Q] PUSHJ[DEV6CL] NORM $
32m0150                               	                ;Clear hdwr int. enable for 60HZ clk.
32m0150                               	    ]  ;OTP
32m0150                               	
32m0150                               	
32m0150                               	 .REPEAT NTP [ ;We branch here from CTYINT if intrpt. is really 60HZ CLK.
32m0150                               	
32m0150                               	CLKINT: START-OUT ALU[0] DEST[IOD] NORM $
32m0150                               	          ;Clear hardware int. enb. for 60HZ CLK.
32m0150                               	  ] [ ;We branch here from CTYINT if intrpt. is really 60HZ CLK.
32m0150                               	
32m0150 06213 640702200615000443600000	CLKINT: START-OUT ALU[0] DEST[IOD] NORM $
32m0150                               	          ;Clear hardware int. enb. for 60HZ CLK.
32m0150                               	  ];NTP
32m0150                               	
32m0150                               	.REPEAT TYMNET [
32m0150                               	        MAPF[6] DEST[CLR-DEV-FROM-INTR] PUSHJ[TYMCLK] C600 $
32m0150                               	          ;Start up TYMNET interface if needed.
32m0150                               	];[
32m0150 06214 440042400571000440060000	        MAPF[6] DEST[CLR-DEV-FROM-INTR] PUSHJ[TYMCLK] C600 $
32m0150                               	          ;Start up TYMNET interface if needed.
32m0150                               	]TYMNET
32m0150 06215 440142400571000440064673	        MAPF[6] DEST[CLR-DEV-FROM-INTR] JUMP[APRCHK] C600 $     
32m0150                               	          ;Cause PI on APR channel if enabled, and exit.
32m0150                               	
32m0150                               	CLKRDFLG:  ;Put hardware 60HZ CLK FLAG into AR35.
32m0150 06216 640701614571000063400000	        START-IN D[CONST 6] DEST[DEV-ADR] NORM $
32m0150                               	          ;Select device 6.
32m0150 06217 140310030571106010050000	        MAPF[5] D[IOD] ROT[34. + 1] MASK[1] DEST[AR] CYLEN[IOB-IN] POPJ $
32m0150                               	          ;Get bit and return.
32m0150                               	
32m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

33m0150                               	.REPEAT NTP [ ;Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
33m0150                               	
33m0150                               	  .REPEAT 1 - TAPE [
33m0150                               	.INSERT CFKNYD.SLO
33m0150                               	  ]
33m0150                               	
33m0150                               	  .REPEAT TAPE [  ;New (DMA tape controller, Pertec compatible fmtr )
33m0150                               	.INSERT TAPE.SLO
33m0150                               	  ]
33m0150                               	
33m0150                               	  ] [ ;Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
33m0150                               	
33m0150                               	  .REPEAT 1 - TAPE [
33m0150                               	.INSERT CFKNYD.SLO
33m0150                               	  ]
33m0150                               	
33m0150                               	  .REPEAT TAPE [  ;New (DMA tape controller, Pertec compatible fmtr )
33m0150                               	.INSERT TAPE.SLO
33m0150                               	  ]
33m0150                               	[  ;New (DMA tape controller, Pertec compatible fmtr )
33m0150                               	.INSERT TAPE.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0001                               	;-------------------------------------------------------------------------------
01m0001                               	;
01m0001                               	;       Ucode for KENNEDY or PERTEC formatter and DMA tape controller.
01m0001                               	;
01m0001                               	;-------------------------------------------------------------------------------
01m0001                               	.REPEAT XUCODE [
01m0001                               	        .USE[HIGHMEM]   ;If 8K u-mem present, put tape code there.
01m0001                               	   ]
01m0001                               	[
01m0001                               	        .USE[HIGHMEM]    [ XLIST
01m0001                               	 LIST ];If 8K u-mem present, put tape code there.
01m0001                               	   ]
01m0001                               	;TAPE READING AND WRITING CODE
01m0001                               	; A-MEM USEAGE:
01m0001                               	;               0       DISPATCH ADDR.
01m0001       0	TPMODE =        0       ;DATA PACKING MODE 
01m0001                               	;                        BIT 0: 0=PDP-10 CORE-DUMP, 1=INDUSTRY (32-bit mode)
01m0001                               	;                        BIT 1: NRZI Kluge Mode (to read old CCRMA & SCI tapes)
01m0001                               	;               1       Used by FMNBWT and TRCHECK for NRZI Kluge Mode info.
01m0001                               	;               2       Used by KNYGOA and TRCHECK for NRZI Kluge Mode info.
01m0001                               	;               3       DON'T USE... Storing into it clobbers IR left !
01m0001                               	;               4       Next mem adr of xfer (STRTDC)
01m0001                               	;               5       Remaining word count in current WCMA (STRTDC)
01m0001                               	;               6       Not currently used-- will be  Data Channel PC
01m0001                               	;               7       RETRY COUNT (WRITE); 400000,,STARTING-MA (READ)
01m0001                               	
01m0001                               	;MAPF values
01m0001                               	
01m0001       4	TP.RS = 4       ;read status (from formatter)
01m0001       2	TP.RC = 2       ;read control (controller status and un-fifo'd read data)
01m0001                               	
01m0001       2	TP.WF = 2       ;write formatter (send ctrl bits to formatter)
01m0001       4	TP.WM = 4       ;write mode control reg.
01m0001       1	TP.WC = 1       ;write control reg.
01m0001       5	TP.MR = 5       ;give Master Reset
01m0001       3	TP.WMA = 3      ;write (load) the CNTMA reg. (count and MA)
01m0001                               	
01m0001                               	KNYCLR:  ;RESET the formatter and drive.
01m0001                               	
01m0001 10001 000702200615000443600000	KNYRS1: START-OUT ALU[0]  DEST[IOD] $
01m0001                               	                ;Turn off "FORMATTER ENABLE"
01m0001 10002 000300000571000440020000	        MAPF[TP.WF] LONG POPJ $
01m0001                               	
01m0001                               	   ;725 - OBSOLETE VERSION OF READ
01m0001                               	
01m0001                               	  .PAIR
01m0001                               	 [:. \ 2 + .
01m0002                               	]  UIOTRP[MUUO] 
01m0002 10004 010140020571016010002100	[       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0002                               	]$
01m0002                               	
01m0002 10005 640040214571014140000000	TAPERD: D[CONST 14] ROT[6] DEST[IR-ADR] NORM PUSHJ[KNYRGO] $
01m0002                               	                ;Fake a word count of 1400
01m0002 10006 640041024571000443000000	        D[MA] DEST[4] DEST-A-MEM NORM PUSHJ[TRP2] $
01m0002 10007 640140001555000440000000	        ALU[Q] DEST[AC] ACSEL[AC] NORM JUMP[GOMAIN] $
01m0002                               	                ;Move status into AC.
01m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0002 10010 640740014571000103600000	TPINIT: START-OUT D[CONST 8.] LLOAD NORM $
01m0002                               	                ;Give TP MR
01m0002 10011 440702200615000443650000	        MAPF[TP.MR] START-OUT ALU[0] DEST[IOD] C600 $
01m0002                               	                ;Load 0 into cntma (the COUNT and MA registers)
01m0002 10012 440702210571054143630000	        MAPF[TP.WMA] START-OUT D[MASK 12.] ROT[35. - 13.] DEST[IOD] C600 $
01m0002                               	                ;Load cntma again-- since COUNT is 0, this will 
01m0002                               	                ; force BUF CNT to be 0.  But, we put -1 into COUNT this
01m0002                               	                ; time, which, with BUF CNT = 0, will make BUF CNT load
01m0002                               	                ; properly when STARTDC loads cntma.
01m0002 10013 440702214571000023630000	        MAPF[TP.WMA] START-OUT D[CONST 2] DEST[IOD] C600 $
01m0002                               	                ;Set MBUSY
01m0002 10014 500240000571000440010014	        MAPF[TP.WC] C550 LOOP[.] $
01m0002                               	                ;Wait for a few usec.  This clears mem rq.
01m0002 10015 640702200615000443600000	        START-OUT ALU[0] DEST[IOD] NORM $
01m0002                               	                ;Clr MBUSY
01m0002 10016 440300000571000440010000	        MAPF[TP.WC] C600 POPJ $
01m0002                               	
01m0002                               	; KNYRGO -- CALLED START TAPE MOTION ON READS
01m0002 10017 640040000571000440000010	KNYRGO: NORM PUSHJ[TPINIT] $
01m0002 10020 640710040571002010000000	        D[10 + TPMODE]  ROT[1] MASK[1] DEST[AR] NORM $
01m0002                               	                ;Get the 32-bit mode flag.
01m0002 10021 640702200571014443600000	        START-OUT D[AR] ROT[35. - 29.] DEST[IOD] NORM $
01m0002                               	                ;Position it for the hardware.
01m0002 10022 440140014171000000040000	        MAPF[TP.WM] D[CONST 0] DEST[Q]   C-OUT JUMP[KNYGOA] $
01m0002                               	                ;Send command to formatter.
01m0002                               	
01m0002                               	  ;Send a tape-motion command to the formatter.  Call with command bits
01m0002                               	  ;  (except for FMTR ENABLE and GO) in Q.  Clobbers Q, HOLD, AR
01m0002 10023 000040014175022013400000	KNYGOA: START-IN D[CONST 1] ROT[35. - 26.] ALU[DORQ] DEST[Q] PUSHJ[FMNBWT] $
01m0002                               	          ;Add the FMTR ENBL bit to the command word.
01m0002                               	          ;Wait for FORMATTER NOT BUSY.
01m0002 10024 640700404571000443000000	        D[MEM] DEST[2] DEST-A-MEM NORM $
01m0002                               	          ;Save status bits returned by FMNBWT for use by TRCHECK
01m0002 10025 440702214735004013600000	        START-OUT D[CONST 1] ROT[35. - 33.] ALU[D#Q] DEST[IOD] C-OUT $
01m0002                               	          ;Set the GO bit to fmtr (except: on RWD, CLEAR the bit !)
01m0002 10026 000702214675004013620000	        MAPF[TP.WF] START-OUT D[CONST 1] ROT[35. - 33.] ALU[-D&Q] DEST[IOD] $
01m0002                               	          ;Send command word again, without GO bit.
01m0002 10027 000300000571000440020000	        MAPF[TP.WF] LONG POPJ $
01m0002                               	
01m0002                               	
01m0002                               	FMNBWT:   ;Wait for formatter to be not busy.
01m0002                               	          ;Return tape status in MEM;  timeout in 164 msec.
01m0002                               	          ;Duration of loop should be 2.5 usec. (for TRCHECK).
01m0002 10030 640710014571040013400000	        START-IN D[CONST 1] ROT[16.] DEST[AR] NORM $
01m0002 10031 240704430571000440040000	FMNBW1: MAPF[TP.RS] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
01m0002 10032 511350000531000440000000	        D[AR] ALU[D-1] DEST[AR] C550 OBUS<0 JPOP[FMTHNG] $
01m0002 10033 440700000571000440000000	        C600 $
01m0002 10034 531140004571016443400031	        START-IN D[MEM] ROT[7] C550 -OBUS<0 JUMP[FMNBW1] $
01m0002                               	          ;check for 'BUSY'
01m0002 10035 640300200571000443000000	        D[AR] DEST[1] DEST-A-MEM NORM POPJ $
01m0002                               	          ;Save ending timeout count (for TRCHECK)
01m0002 10036 640040000571000440000001	FMTHNG: NORM PUSHJ[KNYRS1] $
01m0002                               	                ;Blast the formatter.
01m0002 10037 000340015571074420000000	        D[CONST 42] ROT[30.] DEST[AC] JPOP[GOMAIN] $
01m0002                               	                ;Return error code for 'hung fmtr' and abort.
01m0002                               	
01m0002                               	NCNTWT:   ;Wait for TP CNT GO to be off.
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0002                               	          ;Return tape status in MEM;  timeout in 164 msec.
01m0002                               	          ;Duration of loop should be 2.5 usec. (for TRCHECK).
01m0002                               	;       START-IN D[CONST 1] ROT[16.] DEST[AR] NORM $
01m0002 10040 240704430571000440020000	NCNTW1: MAPF[TP.RC] D[IOD] DEST[HOLD] C800 $ ;GET STATUS BITS.
01m0002 10041 511310000531000440000000	        D[AR] ALU[D-1] DEST[AR] C550 OBUS<0 POPJ $
01m0002                               	          ;Exit if we time out-- probably just a short record.
01m0002 10042 440700000571000440000000	        C600 $
01m0002 10043 511140004571046443400040	        START-IN D[MEM] ROT[19.] C550 OBUS<0 JUMP[NCNTW1] $
01m0002                               	          ;check for 'BUSY'
01m0002 10044 640300200571000443000000	        D[AR] DEST[1] DEST-A-MEM NORM POPJ $
01m0002                               	          ;Save ending timeout count (for TRCHECK)
01m0002                               	
01m0002                               	;START DATA CHANNEL to write or read a record.  Transfer up to C(IR-ADR) words;
01m0002                               	;  starting address is in A-MEM[4].
01m0002                               	
01m0002 10045 640701234571000223000000	STRTDC: D[IR] MASK[18.] NORM DEST[5] DEST-A-MEM $
01m0002                               	                ;Initialize word count
01m0002                               	        
01m0002 10046 640700214571040013000000	        D[CONST 1] ROT[16.] DEST[1] DEST-A-MEM NORM $
01m0002                               	                ;Initialize timeout count (for NCNTWT and FMNBWT)
01m0002 10047 510154464171000440000000	DCGO:   MAPF[0] D[15] DEST[Q AR HOLD] C550 OBUS=0 JUMP[WCDONE] $
01m0002                               	                ;Get remaining word count. If =0, we are done.
01m0002                               	                ;MAPF is to set MEM RQ if we get here from DCRINT below.
01m0002 10050 511140014477020010000000	        D[CONST 1] ROT[8] ALU[Q-D] C550 OBUS<0 JUMP[DCG1] $
01m0002                               	                ;Jump if it is less than 400
01m0002 10051 640710014171020010000000	         D[CONST 1] ROT[8] DEST[Q AR] NORM $    
01m0002                               	                ;It is not. Use 400 instead.
01m0002 10052 640701204537000443000000	DCG1:   D[MEM] ALU[D-Q] DEST[5] DEST-A-MEM NORM $
01m0002                               	                ;Decrement remaining WC by amount of current WC.
01m0002 10053 640704460571000440000000	        D[14] DEST[HOLD] SHORT $
01m0002                               	                ;Get current starting adr
01m0002 10054 640701004435000443000000	        D[MEM] ALU[D+Q] DEST[4] DEST-A-MEM NORM $
01m0002                               	                ;Increment it by current WC.
01m0002 10055 511140040571000440000057	        D[10 + TPMODE] C550 OBUS<0 JUMP[. + 2] $
01m0002                               	                ;Are we in 32-bit mode ?  Jump if so.
01m0002 10056 640150000435004440000060	         D[AR] ROT[2] ALU[D+Q] DEST[AR] NORM JUMP[. + 2] $
01m0002                               	                ;Form byte count (=5*word count).
01m0002 10057 640710000571004440000000	         D[AR] ROT[2] ALU[D] DEST[AR] NORM $
01m0002                               	                ;Form byte count (=4*word count).
01m0002 10060 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] NORM $
01m0002                               	                ;Adjust to be right for hdwr.
01m0002                               	        
01m0002 10061 640700000171054440000000	        D[AR] ROT[35. - 13.] DEST[Q] NORM $
01m0002                               	                ;Align count at bit 13.
01m0002 10062 640702204575000243600000	        START-OUT D[MEM] MASK[20.] ALU[DORQ] DEST[IOD] NORM $
01m0002                               	                ;Include mem addr and load into CNT, MA
01m0002                               	                ;Also sets BUF CNT to 0 (if IN) or 5 (if OUT)-- this
01m0002                               	                ; depends on COUNT not =0 and BUF CNT not = 4 or 5
01m0002 10063 640702214571000023630000	        MAPF[TP.WMA] START-OUT D[CONST 2] DEST[IOD] NORM $
01m0002                               	                ;Set M BUSY
01m0002 10064 440700000571000443610000	        MAPF[TP.WC] START-OUT C600 $
01m0002                               	                ;Set CNT GO
01m0002 10065 451140074571000440130000	        MAPF[13] D[17] C600 OBUS<0 JUMP[DCGRD] $
01m0002                               	                ;Jump to DCGRD if this is a READ op.
01m0002 10066 530140064571000443600000	DCGWR:  START-OUT D[15] C550 -OBUS=0 JUMP[DCGRD] $
01m0002                               	                ;Set MEM RQ to fetch first word.
01m0002                               	                ; Is this the last WCMA in the record ?
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0002 10067 440702214571000123600000	        MAPF[0] START-OUT D[CONST 12] DEST[IOD] C600  $
01m0002                               	                ;Yes.  Set TP ENB LAST BYTE as well as M BUSY
01m0002 10070 440700000571000440010000	        MAPF[TP.WC] C600 $
01m0002 10071 440050044571000443400040	DCGRD:  MAPF[0] START-IN D[11] DEST[AR] C600 PUSHJ[NCNTW1] $
01m0002                               	          ;Wait for TP CNT GO to be off (continue with current timeout count)
01m0002                               	          ;MAPF is relevant if we came from DCGWR above.
01m0002 10072 531140074571000440000047	        D[17] C550 -OBUS<0 JUMP[DCGO] $
01m0002                               	          ;Jump if this is a WRITE operation.
01m0002 10073 531140000571000443600047	        START-OUT D[AR] C550 -OBUS<0 JUMP[DCGO] $
01m0002                               	          ;READ op, so set MEM RQ to store last word.
01m0002                               	          ;Jump unless we timed out waiting for end of last COUNT.
01m0002 10074 440150044571000443400031	WCDONE: MAPF[0] START-IN D[11] DEST[AR] C600 JUMP[FMNBW1] $
01m0002                               	          ;Enter FMNBWT with the timeout count left from NCNTWT.
01m0002                               	          ;The MAPF sets MEM RQ if we have fallen in from previous instr.
01m0002                               	 
01m0002                               	  ;Here to do the data xfer for a read operation.
01m0002 10075 640700060171000440000000	TRP2:   D[14] DEST[Q] SHORT $
01m0002                               	          ;We must save initial mem. adr. for NRZI KLUGE stuff..
01m0002 10076 640041614575106013000045	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[7] DEST-A-MEM NORM PUSHJ[STRTDC] $
01m0002                               	          ;Flag op. as a READ, start the data channel
01m0002 10077 000140000571000440000000	        JUMP[TRCHKB] $
01m0002                               	
01m0002                               	TRCHECK:        
01m0002 10100 000040000571000440000030	        PUSHJ[FMNBWT] $
01m0002                               	          ;wait for formatter not busy.
01m0002 10101 531140004571100440000000	TRCHKB: D[MEM] ROT[32.] C550 -OBUS<0 JUMP[TRERR] $
01m0002                               	          ;check for hard error status.
01m0002 10102 531140004571102440000000	TRCHA:  D[MEM] ROT[33.] C550 -OBUS<0 JUMP[TREOF] $
01m0002                               	          ;Jump if EOF seen by formatter
01m0002 10103 640700000215000440000000	        ALU[0] DEST[Q] NORM $
01m0002                               	                ;Flag no errors.
01m0002 10104 640700000571000443400000	TRDONE: START-IN NORM $
01m0002 10105 440710030571000443420000	        MAPF[TP.RC] START-IN D[IOD] DEST[AR] C600  $  
01m0002                               	          ;Get data channel status bits.
01m0002 10106 240701230175000253030000	        MAPF[3] D[IOD] MASK[21.] ALU[DORQ] DEST[Q 5] DEST-A-MEM C800 $
01m0002                               	          ;Include ending MA value in status info.
01m0002 10107 531140000571046440000000	        D[AR] ROT[19.] C550 -OBUS<0 JUMP[TPMAOK] $
01m0002                               	          ;If TP CNT GO is off,
01m0002 10110 530140000531060033400000	        START-IN D[AR] ROT[24.] MASK[3] ALU[D-1] C550 -OBUS=0 JUMP[TPMAOK] $
01m0002                               	          ;  or if BUF CNT is not =1, then right no. of words were stored.
01m0002 10111 640701200055000443000000	         ALU[Q-1] DEST[Q 5] DEST-A-MEM NORM $
01m0002                               	           ;Otherwise, 1 extra word was stored, so decrement ending MA.
01m0002 10112 511140004571014440000000	TPMAOK: D[MEM] ROT[6] C550 OBUS<0 JUMP[TRCRET] $        
01m0002                               	          ;Done if not in NRZI mode.
01m0002 10113 531140040571002440000000	        D[10 + TPMODE] ROT[1] C550 -OBUS<0 JUMP[TRCRET] $
01m0002                               	          ;Also done if not in NRZI Kluge Mode,
01m0002 10114 510140060571000440000000	        D[14] C550 OBUS=0 JUMP[TRCRET] $
01m0002                               	          ; or if this was not a data-xfer operation.
01m0002 10115 531140050571030440000000	        D[12] ROT[12.] C550 -OBUS<0 JUMP[TRCRET] $
01m0002                               	          ;Neither do we check for EOF if we started at BOT (see KNYGOA)
01m0002                               	
01m0002                               	    ;In NRZI Kluge Mode, detect EOF by timing.
01m0002 10116 640704474077000240000000	        D[17] MASK[20.] ALU[Q-D] DEST[Q HOLD] NORM $
01m0002                               	          ;Get number of words xferred (= ending MA minus starting MA )
01m0002 10117 640700004035004440000000	        D[MEM] ROT[2] ALU[D+Q] DEST[Q] NORM $
01m0002                               	          ;Get no. of bytes (=5* no. of words)
01m0002 10120 640700044035104240000000	        D[11] ROT[36. - 2] MASK[20.] ALU[D+Q] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0002                               	          ;Add 1/4 of remaining timeout count from FMNBWT
01m0002 10121 640700014137034010000000	        D[CONST 1] ROT[14.] ALU[D-Q] DEST[Q] NORM $
01m0002                               	          ;Get no. of byte-times not accounted for by bytes xfrd.
01m0002 10122 533140014537020110000000	        D[CONST 11] ROT[8.] ALU[D-Q] C550 COND[-OBUS18] JUMP[TRCRET] $
01m0002                               	          ;Jump if it is not more than appropriate for a record gap.
01m0002 10123 640040000571000440000000	        NORM PUSHJ[TAPEBR] $
01m0002                               	          ;Too long.  Assume an EOF was passed.  Back up over record read.
01m0002 10124 000040000571000440000030	        PUSHJ[FMNBWT] $
01m0002 10125 640300014171074600000000	        D[CONST 60] ROT[30.] DEST[Q] NORM POPJ $
01m0002                               	          ;Return EOF status.
01m0002 10126 511140060131000220000000	TRCRET: D[14] MASK[18.] ALU[D-1] DEST[Q] C550 OBUS<0 JUMP[TRCX] $
01m0002                               	          ;Get last loc. of input buffer (<0 iff non-data xfer operation)
01m0002 10127 640704400615000440000000	        ALU[0] DEST[HOLD] NORM $
01m0002                               	          ;Prepare to clear the part of the input buffer we didn't use.
01m0002                               	  .REPEAT NEWMAP [
01m0002                               	        ALU[-1] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Disable mapping.
01m0002                               	           ]
01m0002                               	[
01m0002 10130 640705200741000440000000	        ALU[-1] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Disable mapping.
01m0002                               	           ]  .REPEAT 1 - NEWMAP [
01m0002                               	        START-IN D[CONST 1] DEST[DEV-ADR] NORM $
01m0002                               	        D[IOD] MASK[3] DEST[IR-ADR] MAPF[4] CYLEN[IOB-IN] $
01m0002                               	        ALU[0] DEST[DEV-ADR] SHORT $
01m0002                               	        D[IR] MASK[2] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0002                               	        MAPF[10] D[CONST 7] DEST[DEV-ADR] C800 $
01m0002                               	         ]
01m0002 10131 640720064531000440000000	        D[15] ALU[D-1] DEST[MA] NORM $
01m0002 10132 511140024475000440000134	        D[MA] ALU[Q-D-1] C550 OBUS<0 JUMP[. + 2] $
01m0002 10133 640164024433000440000132	        D[MA] ALU[D+1] DEST[MA STRT-WRT] NORM JUMP[. - 1] $
01m0002                               	  .REPEAT NEWMAP [
01m0002                               	        ALU[0] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Enable mapping.
01m0002                               	         ]
01m0002                               	[
01m0002 10134 640705200615000440000000	        ALU[0] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Enable mapping.
01m0002                               	         ]  .REPEAT 1 - NEWMAP [
01m0002                               	        D[IR] MASK[3] DEST[IOD] NORM $
01m0002                               	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
01m0002                               	        MAPF[10] D[CONST 7] DEST[DEV-ADR] C800 $
01m0002                               	         ]
01m0002 10135 640300064171000440000000	TRCX:   D[15] DEST[Q] NORM POPJ $       
01m0002                               	          ;Recover ending status and return.
01m0002                               	
01m0002 10136 640140014171074600000104	TREOF:  D[CONST 60] ROT[30.] DEST[Q]  NORM JUMP[TRDONE] $
01m0002 10137 511140004571014440000141	TRERR:  D[MEM] ROT[6] C550 OBUS<0 JUMP[. + 2] $ 
01m0002                               	          ;Always check hard error if not in NRZI mode.
01m0002 10140 511140040571002440000102	        D[10 + TPMODE] ROT[1] C550 OBUS<0 JUMP[TRCHA] $
01m0002                               	          ;If NRZI, don't check if in kluge mode.
01m0002 10141 640140014171074500000104	        D[CONST 50] ROT[30.] DEST[Q] NORM JUMP[TRDONE] $
01m0002                               	          ;Flag hard read error to progm.
01m0002                               	
01m0002                               	        .PAIR
01m0002                               	 [:. \ 2 + .
01m0003                               	]       UIOTRP[MUUO] 
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

01m0003 10142 010140020571016010002100	[       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0003                               	]$
01m0003                               	TAPEMT: ;OPCODE 726 -- MTAPE FUNCTIONS.
01m0003 10143 640040000571000440000145	        NORM PUSHJ[. + 2] $
01m0003 10144 640140000571000440000000	        NORM JUMP[GOMAIN] $
01m0003                               	
01m0003 10145 510140024171000440000000	        D[MA] DEST[Q] COND[OBUS=0] JUMP[TAPERW] C550 $
01m0003 10146 510040014537000010000000	        D[CONST 1] ALU[D-Q] COND[OBUS=0] PUSHJ[TWREOF] C550 $
01m0003 10147 510040014537000130000000	        D[CONST 13] ALU[D-Q] COND[OBUS=0] PUSHJ[TERASE] C550 $
01m0003 10150 510140014537000500000000	        D[CONST 50] ALU[D-Q] COND[OBUS=0] JUMP[TPSETIND] C550 $
01m0003                               	          ;Code ?, set industry compatable mode.
01m0003 10151 510140014537000510000000	        D[CONST 51] ALU[D-Q] COND[OBUS=0] JUMP[TPSETDMP] C550 $
01m0003                               	          ;Code ?, set PDP-10 dump mode.
01m0003 10152 510140014537000600000000	        D[CONST 60] ALU[D-Q] COND[OBUS=0] JUMP[TPSETNK] C550 $
01m0003                               	          ;Code ?, set NRZI KLUGE mode.
01m0003 10153 510140014537000610000000	        D[CONST 61] ALU[D-Q] COND[OBUS=0] JUMP[TPCLRNK] C550 $
01m0003                               	          ;Code ?, clear NRZI KLUGE mode.
01m0003 10154 510040014537000050000000	        D[CONST 5] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEFR] C550 $
01m0003 10155 510040014537000060000000	        D[CONST 6] ALU[D-Q] COND[OBUS=0] PUSHJ[TAPEBR] C550 $
01m0003 10156 640041000615000443000100	        ALU[0] DEST[4] DEST-A-MEM NORM PUSHJ[TRCHECK] $
01m0003                               	            ;Wait for op. to finish and get ending status in Q.
01m0003                               	            ; The 0 in A-MEM[4] prevents TRCHECK from clearing read buf !
01m0003 10157 640340001555000440000000	        ALU[Q] DEST[AC] NORM JPOP[GOMAIN] $
01m0003                               	            ;Return status to caller in his AC (same as READ)
01m0003                               	
01m0003                               	
01m0003                               	TWREOF:  ;WRITE AN END OF FILE (TAPE MARK)
01m0003 10160 640700014171016010000000	        D[CONST 1] ROT[35. - 28.] DEST[Q] NORM $ 
01m0003                               	          ;Get WFM (WRITE EOF) cmd bit for formatter
01m0003 10161 640144414575032010000000	TERAS1: D[CONST 1] ROT[35. - 22.] ALU[DORQ] DEST[HOLD] NORM JUMP[KNYMTP] $  
01m0003                               	          ;Add WRT CMD bit and start command.
01m0003                               	
01m0003 10162 640140014171014030000161	TERASE: D[CONST 3] ROT[35. - 29.] DEST[Q] NORM JUMP[TERAS1] $
01m0003                               	          ;ERASE A 3.75" GAP ON THE TAPE (get WFM and ERASE bits for formatter)
01m0003                               	
01m0003 10163 640700000571000443600000	KNYMTP: START-OUT NORM $
01m0003                               	          ;Give TP MR to clear mode, error status
01m0003 10164 440040004171000440050023	        MAPF[TP.MR] D[MEM] DEST[Q] C-OUT PUSHJ[KNYGOA] $
01m0003                               	          ;Put command bits in Q and start formatter.
01m0003 10165 640702214571022013600000	        START-OUT D[CONST 1] ROT[35. - 26.] DEST[IOD] NORM $
01m0003                               	                ;Clear all command bits except FORMATTER ENABLE.
01m0003 10166 000300000341000440020000	        MAPF[TP.WF] ALU[-1] DEST[Q] LONG POPJ $
01m0003                               	                ;Put -1 in Q in case we are returning to TAPEMT.
01m0003                               	
01m0003                               	TAPERW: ;REWIND
01m0003 10167 640144414571000240000163	        D[CONST 24] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;RWD AND GO BITS -- KNYGOA WILL DELETE THE GO BIT !
01m0003                               	
01m0003                               	TAPEFR: ;SKIP FORWARD ONE RECORD.
01m0003 10170 640144414571000000000163	        D[CONST 0] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;START A READ, BUT IGNORE THE DATA.
01m0003                               	
01m0003                               	TAPEBR: ;SKIP BACKWARD ONE RECORD.
01m0003 10171 640144414571020010000163	        D[CONST 1] ROT[35. - 27.] DEST[HOLD] NORM JUMP[KNYMTP] $
01m0003                               	          ;JUST A READ BACKWARD, WITH THE DATA IGNORED.
01m0003                               	
01m0003                               	TPSETIND:       ;Set industry compatable mode
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0003 10172 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10173 000140014575106013000000	        D[CONST 1] ROT[35.] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Set appropriate bit and done
01m0003                               	TPSETDMP:       ;Set PDP-10 Dump Mode
01m0003 10174 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10175 000140014675106013000000	        D[CONST 1] ROT[35.] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Clear industry compatable mode and done.
01m0003                               	
01m0003                               	TPSETNK:        ;Enter NRZI KLUGE mode.
01m0003 10176 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10177 000140014575104013000000	        D[CONST 1] ROT[34.] ALU[DORQ] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	          ;Set appropriate bit and done
01m0003                               	TPCLRNK:          ;Leave NRZI KLUGE mode.
01m0003 10200 640700040171000440000000	        D[10 + TPMODE] DEST[Q] NORM $   ;Stupid A-MEM
01m0003 10201 000140014675104013000000	        D[CONST 1] ROT[34.] ALU[-D&Q] DEST[TPMODE] DEST-A-MEM JUMP[GOMAIN] $
01m0003                               	
01m0003                               	TAPERS: ;OPCODE 727 -- READ STATUS BITS FROM TAPE DRIVE.
01m0003                               	
01m0003                               	.DEFINE TSS[A B]   
01m0003                               	[  ;MOVE BIT A OF AR TO BIT B OF Q.
01m0003                               	        D[AR] ROT[1 + A] MASK[1] DEST[HOLD] NORM $
01m0003                               	        D[MEM] ROT[35. - B] ALU[DORQ] DEST[Q] NORM $ ]
01m0003                               	
01m0003 10202 640702200615000443600000	        START-OUT ALU[0] DEST[IOD] NORM $
01m0003                               	          ;CLEAR THE MODE CTRL REGISTER.
01m0003                               	        MAPF[TP.WM] START-OUT 
01m0003 10203 440702214571022013640000	         D[CONST 1] ROT[35. - 26.] DEST[IOD] C-OUT $
01m0003                               	          ;ENABLE THE FORMATTER.
01m0003 10204 240700000215000443420000	        MAPF[TP.WF] START-IN ALU[0] DEST[Q] C800 $
01m0003                               	          ;READ STATUS BITS.
01m0003 10205 240710030771000440040000	        MAPF[TP.RS] D[IOD] ALU[NOTD] DEST[AR] C800 $
01m0003                               	          ;NOW RE-ARRANGE THE BITS
01m0003                               	        TSS[ 3 30. ]       
01m0003                               	[  ;MOVE BIT 3 OF AR TO BIT 30. OF Q.
01m0003 10206 640704400571010010000000	        D[AR] ROT[1 + 3] MASK[1] DEST[HOLD] NORM $
01m0003 10207 640700004175012440000000	        D[MEM] ROT[35. - 30.] ALU[DORQ] DEST[Q] NORM $ ];ON LINE
01m0003                               	        TSS[ 11. 31. ]     
01m0003                               	[  ;MOVE BIT 11. OF AR TO BIT 31. OF Q.
01m0003 10210 640704400571030010000000	        D[AR] ROT[1 + 11.] MASK[1] DEST[HOLD] NORM $
01m0003 10211 640700004175010440000000	        D[MEM] ROT[35. - 31.] ALU[DORQ] DEST[Q] NORM $ ];REWINDING
01m0003                               	        TSS[ 4 32. ]       
01m0003                               	[  ;MOVE BIT 4 OF AR TO BIT 32. OF Q.
01m0003 10212 640704400571012010000000	        D[AR] ROT[1 + 4] MASK[1] DEST[HOLD] NORM $
01m0003 10213 640700004175006440000000	        D[MEM] ROT[35. - 32.] ALU[DORQ] DEST[Q] NORM $ ];FILE PROTECT
01m0003                               	        TSS[ 12. 33. ]     
01m0003                               	[  ;MOVE BIT 12. OF AR TO BIT 33. OF Q.
01m0003 10214 640704400571032010000000	        D[AR] ROT[1 + 12.] MASK[1] DEST[HOLD] NORM $
01m0003 10215 640700004175004440000000	        D[MEM] ROT[35. - 33.] ALU[DORQ] DEST[Q] NORM $ ];LOAD POINT
01m0003                               	        TSS[ 10. 34. ]     
01m0003                               	[  ;MOVE BIT 10. OF AR TO BIT 34. OF Q.
01m0003 10216 640704400571026010000000	        D[AR] ROT[1 + 10.] MASK[1] DEST[HOLD] NORM $
01m0003 10217 640700004175002440000000	        D[MEM] ROT[35. - 34.] ALU[DORQ] DEST[Q] NORM $ ];READY
01m0003                               	        TSS[ 34. 35. ]     
01m0003                               	[  ;MOVE BIT 34. OF AR TO BIT 35. OF Q.
01m0003 10220 640704400571106010000000	        D[AR] ROT[1 + 34.] MASK[1] DEST[HOLD] NORM $
01m0003 10221 640700004175000440000000	        D[MEM] ROT[35. - 35.] ALU[DORQ] DEST[Q] NORM $ ];END OF TAPE
01m0003                               	        ALU[Q] DEST[MEMSTO] NORM
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0003 10222 662104200555000440000000	                COND[-MA-AC] LBJUMP[HIGHSMAIN] $
01m0003                               	
01m0003                               	
01m0003                               	        .PAIR
01m0003                               	 [:. \ 2 + .
01m0004                               	]       UIOTRP[MUUO] 
01m0004 10224 010140020571016010002100	[       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0004                               	]$
01m0004                               	TAPENR: ;730, AC/COUNT.  READ WHOLE RECORD, STORING UP TO COUNT WORDS STARTING AT EFF
01m0004                               	 ADR.
01m0004                               	         ;SWAP AC AND IR, THEN DO TAPERX.
01m0004 10225 640140235171000440000000	        D[IR] DEST[O_AC IR-ADR] ACSEL[AC]  NORM JUMP[TAPERX] $ 
01m0004                               	
01m0004                               	        .PAIR
01m0004                               	 [:. \ 2 + .
01m0005                               	]       UIOTRP[MUUO] 
01m0005 10226 010140020571016010002100	[       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0005                               	]$
01m0005                               	TAPERX: ;732 - (AC) IS START ADDR., E IS # OF WORDS TO READ.
01m0005 10227 640040000571000440000017	        NORM PUSHJ[KNYRGO] $ ;GET TAPE STARTED.
01m0005 10230 640041000551000443000075	        ALU[AC] ACSEL[AC] DEST[4] DEST-A-MEM PUSHJ[TRP2] NORM $ ;READ REC.
01m0005 10231 031140000571040440000000	        D[AR] ROT[16.] -OBUS<0 JUMP[TNRP3] $
01m0005                               	                ;Was record longer than word count ?
01m0005                               	                ;Jump unless FIFO RDY FOR BUF is on, indicating
01m0005                               	                ;  that tape supplied more bytes after count ran out.
01m0005 10232 640700014175074440000000	        D[CONST 44] ROT[30.] ALU[DORQ] DEST[Q] NORM $ ;YES, SET BIT 3.
01m0005 10233 640340001555000440000000	TNRP3:  ALU[Q] DEST[AC] ACSEL[AC] JPOP[GOMAIN] NORM $  ;NO, NOT TOO LONG.
01m0005                               	                ;MOVE STATUS INTO AC.
01m0005                               	
01m0005                               	
01m0005                               	UTAPWR: UIOTRP[MUUO] 
01m0005 10234 010140020571016010002100	[       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0005                               	]$
01m0005                               	
01m0005                               	TAPEWR: ;731, AC/ADR, E/+COUNT.  WRITE RECORD OF +COUNT
01m0005                               	        ; WORDS, DATA FROM ADR.
01m0005                               	        ;SET AC:=0 IF OPERATION COMPLETED SUCCESSFULLY.
01m0005                               	        ; SET AC:=<SETZ> + HIGHEST ADR READ IF REACHED
01m0005                               	        ; EOT DURING OPERATION (CURRENTLY THIS IS THE ONLY
01m0005                               	        ; ERROR CONDITION.)  OPERATION IS COMPLETED EVEN
01m0005                               	        ; IF EOT IS PASSED.
01m0005                               	
01m0005 10235 640701614571000123000000	        D[CONST 10.] DEST[7] DEST-A-MEM NORM $
01m0005                               	          ;SET UP ERROR RETRY COUNT.
01m0005 10236 640040000571000440000010	TWRTRY: NORM PUSHJ[TPINIT] $
01m0005                               	                ;Init. the data channel
01m0005 10237 640710040571002010000000	        D[10 + TPMODE]  ROT[1] MASK[1] DEST[AR] NORM $
01m0005                               	                ;Get the 32-bit mode flag.
01m0005 10240 640700000171014440000000	        D[AR] ROT[35. - 29.] DEST[Q] NORM $
01m0005                               	                ;Position it for the hardware.
01m0005 10241 640702214575016013600000	        START-OUT D[CONST 1] ROT[35. - 28.] ALU[DORQ] DEST[IOD] NORM $
01m0005                               	                ;Set the OUT bit.
01m0005 10242 000040014171032010040023	        MAPF[TP.WM] D[CONST 1] ROT[35. - 22.] DEST[Q] PUSHJ[KNYGOA] $
01m0005                               	                ;Issue WRITE command to formatter.
01m0005 10243 640041000551000443000045	        ALU[AC] DEST[4] DEST-A-MEM NORM PUSHJ[STRTDC] $
01m0005                               	                ;Get word count and start the channel.
01m0005 10244 031140004571100440000000	        D[MEM] ROT[32.] -OBUS<0 JUMP[TWERR] $ ;Test HARD ERR.
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0005 10245 640700001615000440000000	        ALU[0] DEST[AC] NORM $ ;We return 0 in AC if no EOT.
01m0005 10246 511140004571104440000000	        D[MEM] ROT[34.] C550 OBUS<0 JUMP[GOMAIN] $
01m0005                               	         ;If no EOT seen, all done.
01m0005 10247 640140015561074600000000	        D[CONST 60] ROT[35. - 5] ALU[DORAC] DEST[AC] NORM JUMP[GOMAIN] $
01m0005                               	         ;Turn on bit 0 to indicate EOT seen during operation.
01m0005                               	
01m0005                               	TWERR:  ;;Error occurred during write. Backspace, erase gap, and retry.
01m0005 10250 640040000571000440000001	        NORM PUSHJ[KNYRS1] $ 
01m0005                               	          ;Blast the tape formatter and drive 
01m0005 10251 531140074131000440000000	        D[17] ALU[D-1] DEST[Q] C550 -OBUS<0 JUMP[TWER1] $
01m0005                               	          ;See if we have had to many retry's already...
01m0005 10252 000140015571074500000000	        D[CONST 50] ROT[30.] DEST[AC] JUMP[GOMAIN] $
01m0005                               	           ;Hopeless. Give error return to prgm.
01m0005 10253 640041600555000443000171	TWER1:  ALU[Q] DEST[7] DEST-A-MEM NORM PUSHJ[TAPEBR] $
01m0005                               	         ;Start a BACKSPACE RECORD command.
01m0005 10254 640040000571000443400030	        START-IN NORM PUSHJ[FMNBWT] $ 
01m0005                               	         ;Wait for completion.
01m0005 10255 000040000571000440000162	        PUSHJ[TERASE] $
01m0005                               	         ;Start erasing a 3.75" gap.
01m0005 10256 640040000571000443400030	        START-IN NORM PUSHJ[FMNBWT] $ 
01m0005                               	         ;Wait for completion.
01m0005 10257 640140000571000440000236	        NORM JUMP[TWRTRY] $
01m0005                               	          ;Start write op again.
01m0005                               	
01m0005                               	
01m0005                               	;BOOTSTRAP LOADER FOR MACROCODE.
01m0005                               	
01m0005                               	 .ORG[5000]
01m0005                               	 [ XLIST
01m0006                               	 LIST ]
01m0006 05000 000340000571000440005001	MBOOT:  JPOP[. + 1] $
01m0006                               	         ;The . + 1 is to make the lights look familiar for the operator...
01m0006 05001 000140000571000440000000	        JUMP[MBOOTA] $
01m0006                               	         ;MBOOTA takes us to MBOOTH, whether or not that is in high u-mem.
01m0006                               	
01m0006                               	.REPEAT XUCODE [ ;If 8K u-mem, put this code in upper 4K
01m0006                               	AREA50 = .
01m0006                               	 .USE[HIGHMEM]
01m0006                               	 ] [ ;If 8K u-mem, put this code in upper 4K
01m0006       5002	AREA50 = .
01m0006                               	 .USE[HIGHMEM]
01m0006                               	 [ XLIST
01m0006                               	 LIST ] ];XUCODE
01m0006                               	
01m0006 10260 000041614571000070000001	MBOOTH: D[CONST 7] DEST[DEV-ADR] PUSHJ[KNYCLR] $ ;RESET TAPE CTRL
01m0006 10261 640042600615000440000000	        ALU[0] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
01m0006 10262 640042614571044010000000	        D[CONST 1] ROT[18.] DEST[HI-ABS-MA] PUSHJ[CCLR] NORM $
01m0006 10263 000041614571000070000017	        D[CONST 7] DEST[DEV-ADR] CYLEN[LONG] PUSHJ[KNYRGO] $
01m0006                               	                ;SELECT DEVICE 7, START READ.
01m0006 10264 640040000571000440000000	        NORM PUSHJ[KNYWAIT] $
01m0006 10265 240044430771000443420000	        MAPF[TP.RC] START-IN D[IOD] ALU[NOTD] DEST[HOLD] C800 PUSHJ[MBTBYX] $ 
01m0006                               	                ;Read 1st byte of new record.
01m0006 10266 640162600615000440000000	        ALU[0] DEST[MA HI-ABS-MA] NORM JUMP[P2A] $
01m0006                               	                ;Clear high-order MA and enter reading loop.
01m0006                               	
01m0006 10267 640060024433000440000000	P2:     D[MA] ALU[D+1] DEST[MA] PUSHJ[MBTBYTE] NORM $
01m0006 10270 640040004171070440000000	P2A:    D[MEM] ROT[34] DEST[Q] PUSHJ[MBTBYTE] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0006 10271 640040004175050440000000	        D[MEM] ROT[24] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10272 640040004175030440000000	        D[MEM] ROT[14] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10273 640040004175010440000000	        D[MEM] ROT[4] ALU[DORQ] DEST[Q] PUSHJ[MBTBYTE] NORM $
01m0006 10274 640144204575000040000267	        D[MEM] MASK[4]  ALU[DORQ] DEST[MEMSTO] NORM JUMP[P2] $
01m0006                               	
01m0006 10275 640720000615000440000000	CCLR:   ALU[0] DEST[MA] NORM $
01m0006 10276 640704200615000440000000	        ALU[0] DEST[MEMSTO] NORM $
01m0006 10277 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
01m0006 10300 470140024571000220000276	        D[MA] MASK[18.] COND[-OBUS=0] JUMP[. - 2] C600 $
01m0006 10301 640300000571000440000000	        POPJ NORM $
01m0006                               	
01m0006                               	MBTBYTE:
01m0006 10302 640740014571002353400000	        START-IN D[CONST 35] ROT[1] LLOAD NORM $
01m0006                               	                ;Ask tape for a byte and status thereof
01m0006                               	                ;Set loop counter to do timeout
01m0006                               	                ;(TIMEOUT ABOUT 78 USEC)
01m0006 10303 240244430571000440020000	MBTBY1: MAPF[TP.RC] D[IOD] DEST[HOLD] C800 LOOP[MBTBY2] $
01m0006                               	                ;Read byte and status.  Byte comes complemented.
01m0006                               	                ;Result is put in HOLD to avoid synchronizer problems
01m0006                               	                ;Do timeout check and branch if still waiting
01m0006 10304 640040000571000443400000	        START-IN NORM PUSHJ[MBTCHECK] $
01m0006                               	                ;Byte wasn't ready in time.  Go find out why
01m0006 10305 000040000571000440000017	        PUSHJ[KNYRGO] $ ;START NEXT RECORD.
01m0006 10306 640040000571000440000000	        NORM PUSHJ[KNYWAIT] $
01m0006 10307 240044430771000443420000	        MAPF[TP.RC] START-IN D[IOD] ALU[NOTD] DEST[HOLD] C800 PUSHJ[MBTBYX] $ 
01m0006                               	                ;Read 1st byte of new record.
01m0006 10310 640340000571000440000270	        NORM JPOP[P2A] $
01m0006                               	                ;Go for another record
01m0006                               	;       ---
01m0006                               	MBTBY2:
01m0006 10311 531140004571064443400303	        START-IN D[MEM] ROT[26.] -OBUS<0 C550 JUMP[MBTBY1] $
01m0006                               	                ;Check for byte ready (this is a two instruction loop)
01m0006                               	                ;Start getting byte and status again in case we have
01m0006                               	                ;  to loop
01m0006 10312 240704430771000443420000	        START-IN MAPF[TP.RC] D[IOD] ALU[NOTD] DEST[HOLD] C800 $
01m0006                               	                ;READ THE DATA AGAIN (NOW THAT IT'S STABLE !)
01m0006 10313 500304404571000100010000	MBTBYX: MAPF[1] D[MEM] MASK[10] DEST[HOLD] C550 POPJ $
01m0006                               	                ;MAPF[1] clears byte ready
01m0006                               	                ;Extract data byte from other status information
01m0006                               	
01m0006                               	;       ---
01m0006                               	
01m0006                               	KNYWAIT: ;Wait for first byte of read data (BOOTSTRAP mode only)
01m0006 10314 640700000571000443400000	        START-IN SHORT $
01m0006 10315 640710014571030773410000	        MAPF[1] START-IN D[CONST 77] ROT[12.] DEST[AR] NORM $
01m0006                               	                ;Clear read data ready flag
01m0006 10316 440704430571000440020000	KNYW1:  MAPF[TP.RC] D[IOD] DEST[HOLD] C600 $
01m0006 10317 511300004571064443400000	        START-IN D[MEM] ROT[26.] OBUS<0 POPJ C550 $
01m0006                               	                ;Return if READ DATA RDY is now on.
01m0006 10320 530150000531000443400316	        START-IN D[AR] ALU[D-1] DEST[AR] C550 -OBUS=0 JUMP[KNYW1] $
01m0006 10321 640300000571000440000000	        NORM POPJ $
01m0006                               	
01m0006 10322 640040000571000443400030	MBTCHECK:       START-IN NORM PUSHJ[FMNBWT] $
01m0006                               	          ;WAIT FOR FORMATTER IDLE.
01m0006 10323 531140004571100440000000	        D[MEM] ROT[32.] C550 -OBUS<0 JUMP[MBTERR] $
01m0006                               	          ;CHECK FOR ERROR STATUS.
01m0006 10324 511300004571102440000000	        D[MEM] ROT[33.] C550 OBUS<0 POPJ $
SLOE   Jan ***, 1859 00:00:03  file DSK:TAPE.SLO  --  of -- f2x

01m0006                               	          ;IF END OF FILE NOT SEEN, RETURN FOR MORE, ELSE DONE.
01m0006 10325 640700000215000440000000	        ALU[0] DEST[Q] NORM $ ;CLEAR LIGHTS TO INDICATE NO ERRORS.
01m0006 10326 000341600615000443600327	MBTDNX: START-OUT ALU[0] DEST[DEV-ADR] JPOP[. + 1] $
01m0006                               	                ;Setup to display code in lights
01m0006 10327 000340000555000443620330	        START-OUT MAPF[2] ALU[Q] JPOP[. + 1] $  ;LOAD LIGHTS FROM Q, CLR SW FF'S
01m0006 10330 000700000571000443440000	D1:     MAPF[4] START-IN $
01m0006                               	           ;CHECK START AND CONT SWITCHES.  RD NEXT FILE ON CONT
01m0006 10331 000710030571000440040000	        MAPF[4] D[IOD] DEST[AR] $
01m0006                               	        D[AR]  ROT[5] MASK[2] DEST[AR]
01m0006 10332 010150000571012020000330	                COND[OBUS=0] JUMP[D1] CYLEN[LONG] $
01m0006                               	                ;WAIT FOR A SWITCH.
01m0006 10333 530140000571000010000000	        D[AR] MASK[1] COND[-OBUS=0] JUMP[GOMSTART] C550 $
01m0006                               	           ;  ... START MAIN MICROCODE ON START SWITCH.
01m0006 10334 640700000571000443600000	        START-OUT NORM $  ;CLEAR SWITCH FF'S
01m0006 10335 000340000571000440040260	        MAPF[4] JPOP[MBOOTH] CYLEN[LONG] $
01m0006                               	
01m0006                               	GOMSTART: ;Branch to MSTART
01m0006                               	        GETADR[MSTART]  [  ;Place the 12-bit value of MSTART in Q.
01m0006 10336 640700014171014400000000	        D[CONST (77 & (MSTART / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
01m0006 10337 440140014175000000000000	        D[CONST (MSTART \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOLOW] $
01m0006                               	
01m0006 10340 000140014371000000000326	MBTERR: D[CONST 0] ALU[NOTD] DEST[Q] JUMP[MBTDNX] $
01m0006                               	;       ---
01m0006                               	
01m0006                               	  .ORG[2150]
01m0006                               	 [ XLIST
01m0007                               	 LIST ]
01m0007 02150 000140000571000440002150	        JUMP[.] $       ;Hang if any interrupts from device 7 occur.
01m0007                               	
01m0007                               	    .USE[OTHER]  [ XLIST
01m0007                               	 LIST ] ;RETURN TO OLD LOC. CTR.
01m0007                               	
01m0007                               	MBOOTA: GETADR[MBOOTH]  [  ;Place the 12-bit value of MBOOTH in Q.
01m0007 06220 640700014171014020000000	        D[CONST (77 & (MBOOTH / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
01m0007 06221 440140014175000600000000	        D[CONST (MBOOTH \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH] $
01m0007                               	        

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

33m0150                               	  ]
33m0150                               	  ];NTP
33m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

34m0150                               	.REPEAT KNYTAPE [ ;KENNEDY TAPE CONTROL UCODE
34m0150                               	.INSERT CFKNYP.SLO
34m0150                               	 ] ;ENDX OF KENNEDY TAPE CODE
34m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

35m0150                               	.REPEAT TLXTAPE [ ;TELEX TAPE CONTROL UCODE
35m0150                               	.INSERT CFTLX.SLO
35m0150                               	] ;ENDX OF TELEX TAPE CODE
35m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

36m0150                               	.REPEAT SLOWTAPE [ ;UCODE FOR BARE 800 BPI TAPE DRIVE
36m0150                               	.INSERT CFBARE.SLO
36m0150                               	   ] ;END OF SLOW TAPE CODE
36m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

37m0150                               	.REPEAT 125TAPE [ ;UCODE FOR BARE 800 BPI, 125 IPS TAPE DRIVE
37m0150                               	.INSERT CFB125.SLO
37m0150                               	] ;END OF SLOW 125 IPS TAPE CODE
37m0150                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

38m0150                               	;TAPE DISPATCH
38m0150                               	
38m0150                               	 .REPEAT 1 - XUCODE [ ;If we have extended ucode memory, these are different.
38m0150                               	
38m0150                               	.OPCODE[725]    ;TAPE IOTS
38m0150                               	
38m0150                               	;725 - Obsolete version of read (no word count, E = core address.)
38m0150                               	        D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPERD] $
38m0150                               	         NOP $
38m0150                               	;726 - MTAPE
38m0150                               	        D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPEMT] $    
38m0150                               	         NOP $
38m0150                               	;727 - READ STATUS
38m0150                               	        D[CONST 7] DEST[DEV-ADR] NORM JUMP[TAPERS] $    
38m0150                               	         NOP $
38m0150                               	;730 - READ 1 RECORD, STORE UP TO (AC) WORDS STARTING E.
38m0150                               	        D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPENR] $
38m0150                               	         NOP $
38m0150                               	;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
38m0150                               	        D[CONST 7] DEST[DEV-ADR] NORM COND[USER] JUMP[UTAPWR] $
38m0150                               	         NORM JUMP[TAPEWR] $
38m0150                               	;732 - READ 1 record, store up to E words starting at (AC).
38m0150                               	        D[CONST 7] DEST[DEV-ADR] NORM COND[-USER] LBJUMP[TAPERX] $
38m0150                               	         NOP $
38m0150                               	  ] ;1 - XUCODE
38m0150                               	
38m0150                               	
38m0150                               	 .REPEAT XUCODE [ ;If we don't have extended ucode memory, these are different.
38m0150                               	
38m0150                               	.OPCODE[725]    ;TAPE IOTS
38m0150                               	
38m0150                               	;725 - Obsolete version of read (no word count, E = core address.)
38m0150                               	        GETADR[TAPERD] JUMP[TAPDSP] $
38m0150                               	;726 - MTAPE
38m0150                               	        GETADR[TAPEMT] JUMP[TAPDSP] $
38m0150                               	;727 - READ STATUS
38m0150                               	        GETADR[TAPERS] JUMP[TAPDSP] $
38m0150                               	;730 - OBSOLETE ! --read 1 record, store up to (AC) words starting at E.
38m0150                               	        GETADR[TAPENR] JUMP[TAPDSP] $
38m0150                               	;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
38m0150                               	        GETADR[TAPEWR] JUMP[TAPDSP] $
38m0150                               	;732 - READ 1 record, store up to E words starting at (AC).
38m0150                               	        GETADR[TAPERX] JUMP[TAPDSP] $
38m0150                               	
38m0150                               	  ] [ ;If we don't have extended ucode memory, these are different.
38m0150                               	
38m0150                               	.OPCODE[725]     [XLIST 
38m0150                               	 LIST            ];TAPE IOTS
38m0150                               	
38m0150                               	;725 - Obsolete version of read (no word count, E = core address.)
38m0150                               	        GETADR[TAPERD]  [  ;Place the 12-bit value of TAPERD in Q.
38m0150 03652 640700014171014000000000	        D[CONST (77 & (TAPERD / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03653 440140014175000050000000	        D[CONST (TAPERD \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;726 - MTAPE
38m0150                               	        GETADR[TAPEMT]  [  ;Place the 12-bit value of TAPEMT in Q.
38m0150 03654 640700014171014010000000	        D[CONST (77 & (TAPEMT / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03655 440140014175000430000000	        D[CONST (TAPEMT \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

38m0150                               	;727 - READ STATUS
38m0150                               	        GETADR[TAPERS]  [  ;Place the 12-bit value of TAPERS in Q.
38m0150 03656 640700014171014020000000	        D[CONST (77 & (TAPERS / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03657 440140014175000020000000	        D[CONST (TAPERS \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;730 - OBSOLETE ! --read 1 record, store up to (AC) words starting at E.
38m0150                               	        GETADR[TAPENR]  [  ;Place the 12-bit value of TAPENR in Q.
38m0150 03660 640700014171014020000000	        D[CONST (77 & (TAPENR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03661 440140014175000250000000	        D[CONST (TAPENR \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;731 - WRITE 1 record of E words starting from CORE LOC IN AC.
38m0150                               	        GETADR[TAPEWR]  [  ;Place the 12-bit value of TAPEWR in Q.
38m0150 03662 640700014171014020000000	        D[CONST (77 & (TAPEWR / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03663 440140014175000350000000	        D[CONST (TAPEWR \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	;732 - READ 1 record, store up to E words starting at (AC).
38m0150                               	        GETADR[TAPERX]  [  ;Place the 12-bit value of TAPERX in Q.
38m0150 03664 640700014171014020000000	        D[CONST (77 & (TAPERX / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
38m0150 03665 440140014175000270000000	        D[CONST (TAPERX \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[TAPDSP] $
38m0150                               	
38m0150                               	  ];XUCODE
38m0150                               	
38m0150                               	.RELOC
38m0150                               	 [.USE[OTHER]
38m0150                               	 [ XLIST
38m0151                               	 LIST ]]
38m0151 06222 025141614571000070000000	TAPDSP: D[CONST 7] DEST[DEV-ADR] COND[-USER] JUMP[GOHIGH] $
38m0151                               	         ;Load device code for tape, test for user mode.
38m0151                               	        UIOTRP[MUUO] 
38m0151 06223 010140020571016010002100	[       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
38m0151                               	]$
38m0151                               	         ;In user mode-- trap unless IOT USER
38m0151                               	
38m0151                               	GOHIGH:  ;Jump into high part of umemory, using 12-bit addr. in Q
38m0151 06224 440540014433022120000000	        D[CONST (XUCODE * 10) + 2] ROT[9.] ALU[D+1] C600 SDISP $
38m0151                               	          ;This takes us to loc. 2001 and pre-sets the 10000 bit.
38m0151                               	 .ORG[2001]
38m0151                               	 [ XLIST
38m0152 02001 000540014575030010000000	 LIST ] D[CONST XUCODE] ROT[12.] ALU[DORQ] SDISP $
38m0152                               	          ;This finally takes us to loc. 10000+[Q] 
38m0152                               	
38m0152                               	 .RELOC
38m0152                               	 [.USE[OTHER]
38m0152                               	 [ XLIST
38m0153                               	 LIST ]]
38m0153                               	  .REPEAT XUCODE [
38m0153                               	.USE[HIGHMEM] $
38m0153                               	     ]
38m0153                               	[
38m0153                               	.USE[HIGHMEM]  [ XLIST
38m0153                               	 LIST ]$
38m0153                               	     ]
38m0153                               	 .PAIR
38m0153                               	 [:. \ 2 + .
38m0154                               	]HIGHSMAIN:
38m0154 10342 640140005570400440000000	        D[MEM] ACSEL[MA] DEST[AC] NORM JUMP[GOMAIN] $
38m0154 10343 640140000571000440000000	        NORM JUMP[GOMAIN] $
38m0154                               	
38m0154                               	GOMAIN: GETADR[MAIN]  [  ;Place the 12-bit value of MAIN in Q.
38m0154 10344 640700014171014200000000	        D[CONST (77 & (MAIN / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

38m0154 10345 440700014175000260000000	        D[CONST (MAIN \ 100)] ALU[DORQ] DEST[Q] C600 ] $        ;Do extended mode jump to
38m0154                               	 MAIN.
38m0154                               	
38m0154                               	GOLOW:   ;Jump to loc. in lower 4K indicated by contents of Q.
38m0154                               	
38m0154                               	   .REPEAT XUCODE [
38m0154                               	        ALU[0] C600 SDISP $
38m0154                               	         ;This goes to loc. 10000 and pre-clears the 10000 bit.
38m0154                               	 .ORG[10000]
38m0154                               	   ] [
38m0154 10346 440540000615000440000000	        ALU[0] C600 SDISP $
38m0154                               	         ;This goes to loc. 10000 and pre-clears the 10000 bit.
38m0154                               	 .ORG[10000]
38m0154                               	 [ XLIST
38m0154                               	 LIST ]   ];XUCODE
38m0154                               	
38m0154 10000 440540000555000440000000	        C600 ALU[Q] SDISP $
38m0154                               	         ;Now we actually go to low u-mem.
38m0154                               	
38m0154                               	.USE[OTHER]
38m0154                               	 [ XLIST
38m0155                               	 LIST ]
38m0155                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

39m0155                               	
39m0155                               	
39m0155                               	;------------------------------------------------------------------------------
39m0155                               	;
39m0155                               	;       FooVision
39m0155                               	;
39m0155                               	;------------------------------------------------------------------------------
39m0155                               	.REPEAT VID [
39m0155                               	.INSERT VID.SLO
39m0155                               	];[
39m0155                               	.INSERT VID.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

01m0001                               	COMMENT \               VID.SLO
01m0001                               	
01m0001                               	This is the microcode for vector display i/o.
01m0001                               	There are two basic macro instructions:
01m0001                               	        VIDIN AC,E:     770000,,0
01m0001                               	                        input from VID with i/o sub sel = ac
01m0001                               	                        to contents of effective address.
01m0001                               	        VIDOUT AC,E:    771000,,0
01m0001                               	                        output from contents of effective address
01m0001                               	                        to VID with i/o sub sel = ac
01m0001                               	
01m0001                               	These get dispatched to by 700 series iots
01m0001                               	(although the format is more like a non-iot instruction.)
01m0001                               	
01m0001                               	;OPDEF's for FooVision:
01m0001                               	OPDEF   VIDIN   [770000,,0]     ;In to CPU from FooVision (AC=MAPF)
01m0001                               	OPDEF   VIDOUT  [771000,,0]     ;Out from CPU to FooVision (AC=MAPF)
01m0001                               	OPDEF   VLDDAT  [VIDOUT 1,]     ;36 bit format or B,G,R 8 bits each
01m0001                               	OPDEF   VSYDAT  [VIDIN 1,]      ;Synthesize DATA (also to (E))
01m0001                               	OPDEF   VLDADR  [VIDOUT 2,]     ;16 bits right justified
01m0001                               	OPDEF   VSYADR  [VIDIN 2,]      ;Synthesize ADR (also to (E))
01m0001                               	OPDEF   VLDBAK  [VIDOUT 3,]     ;IOB 4-11 (of 36 bit word, 0=MSB)
01m0001                               	OPDEF   VOEVID  [VIDIN 4,]      ;36 bit format palette(3),(11*PIXEL(3))
01m0001                               	OPDEF   VOECOL  [VIDIN 5,]      ;B,G,R 8 bits each right justified
01m0001                               	OPDEF   VWECOL  [VIDIN 6,]      ;Write enable color map - (E) trashed
01m0001                               	OPDEF   VWEVID  [VIDIN 7,]      ;Write enable video buffer - (E) trashed
01m0001                               	OPDEF   VLDCOL  [VIDOUT 10,]    ;36 bit mask XORed with synthesized data
01m0001                               	OPDEF   VLDSIZ  [VIDOUT 11,]    ;OFFSET,,SIZE (in WDS/FLD (11 PXLS/WD))
01m0001                               	OPDEF   VLDCTR  [VIDOUT 12,]    ;B0=video resolution (vs. high res B/W)
01m0001                               	                                ;B1=add (don't overwrite)
01m0001                               	                                ;B2=carry
01m0001                               	                                ;B3=interlace
01m0001                               	                                ;B4=NTSC color
01m0001                               	OPDEF   VLDPIX  [VIDOUT 13,]    ;Inten.(3 bit),line (9 bit),,pixel(10 bit)
01m0001                               	OPDEF   VLDOFF  [VIDOUT 14,]    ;Y offset,,X offset
01m0001                               	OPDEF   VWEDIV  [VIDIN 16,]     ;Write enable divide table - (E) trashed
01m0001                               	OPDEF   VWENTS  [VIDIN 17,]     ;Write enable NTSC table - (E) trashed
01m0001                               	
01m0001                               	There are three additional instructions which simulate part of the
01m0001                               	Stanford-III vector display:
01m0001                               	
01m0001                               	OPDEF   DPYINI  [772000,,0]     ;Initialize display
01m0001                               	OPDEF   DPYOUT  [773000,,0]     ;Interpret Stanford-III display format
01m0001                               	OPDEF   DPYADD  [767000,,0]     ;Append Stanford-III display format
01m0001                               	
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

02m0001                               	        DPYINI POGB     ;Take a block of 64 words at E (which contain
02m0001                               	                        ;pointers to "shadow" pieces-of-glass, fonts,
02m0001                               	                        ;and various other state (used in interrupts)).
02m0001                               	                        ;Zero all POG lengths, and blank screen.
02m0001                               	
02m0001                               	POGB:   <POG0 BACKGROUND(3 bits LJ),LENGTH(15 bits RJ),,BEGINING-POG-BUFFER>
02m0001                               	POGB+1: <POG1 BACKGROUND(3 bits LJ),LENGTH(15 bits RJ),,BEGINING-POG-BUFFER>
02m0001                               	        ...
02m0001                               	POGB+15:<POG15 BACKGROUND(3 bits LJ),LENGTH(15 bits RJ),,BEGINING-POG-BUFFER>
02m0001                               	                                ;These are pointers to blocks of memory where
02m0001                               	                                ;the display list for the previous piece of
02m0001                               	                                ;glass is copied. This data is subtracted
02m0001                               	                                ;(with the BACKGROUND color) from the image
02m0001                               	                                ;by DPYOUT before adding the new display list.
02m0001                               	
02m0001                               	POGB+16:<POG0 XMAX,,XMIN>       ;Window boundaries
02m0001                               	POGB+17:<POG1 XMAX,,XMIN>
02m0001                               	        ...
02m0001                               	POGB+31:<POG15 XMAX,,XMIN>
02m0001                               	
02m0001                               	POGB+32:<POG0 YMAX,,YMIN>
02m0001                               	POGB+33:<POG1 YMAX,,YMIN>
02m0001                               	        ...
02m0001                               	POGB+47:<POG15 YMAX,,YMIN>
02m0001                               	
02m0001                               	POGB+48:<LAST COLOR,,LAST FONT> ;Pointers to fonts (2K each)
02m0001                               	POGB+49:<FONT 1>
02m0001                               	POGB+50:<FONT 2>
02m0001                               	        ...
02m0001                               	POGB+55:<FONT 7>
02m0001                               	
02m0001                               	POGB+56:<REMAINING LENGTH>      ;State for interrupt recovery
02m0001                               	POGB+57:<DISPLAY BUFFER POINTER,,PIECE OF GLASS POINTER>
02m0001                               	POGB+58:<MICRO RETURN ADDRESS>
02m0001                               	POGB+59:<COLOR MASK,,MASK>      ;Non VIC2 only
02m0001                               	POGB+60:<INTERLACED LINE 000000>;Non VIC2 only
02m0001                               	POGB+61:<X0,,X1>
02m0001                               	POGB+62:<Y0,,Y1>
02m0001                               	POGB+63:
02m0001                               	
02m0001                               	POGB+64:<AMEM[0]>
02m0001                               	POGB+65:<AMEM[1]>
02m0001                               	        ...
02m0001                               	POGB+71:<AMEM[7]>
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

03m0001                               	        DPYOUT POG,E    ;Similar to the stanford instruction. Takes
03m0001                               	       (DPYADD)         ;a pointer and length for the display list
03m0001                               	                        ;for the piece of glass and puts it on the
03m0001                               	                        ;screen, deleting (or adding to) the previous
03m0001                               	                        ;contents of that piece of glass.
03m0001                               	
03m0001                               	E:      <BEGINING>
03m0001                               	E+1:    <LENGTH>
03m0001                               	
03m0001                               	Below are the two objects (vectors and characters) implemented from
03m0001                               	the Stanford-III display system:
03m0001                               	
03m0001                               	Long Word Vector:
03m0001                               	!00 10!11 21!22 24!25  27!28!29!30 31!32  35!
03m0001                               	!  X  !  Y  ! BRT ! SIZE !  !M !  T  ! 0010 !
03m0001                               	BRT(color):             SIZE:           M:              T:
03m0001                               	0=no change             0=no change     0=relative      0=visible
03m0001                               	1=red                   1=smallest font 1=absolute      1=end point
03m0001                               	2=yellow                .                               2=invisible
03m0001                               	3=green                 .                               3=undefined
03m0001                               	4=cyan                  .                                 (end point)
03m0001                               	5=blue                  .
03m0001                               	6=magenta               .
03m0001                               	7=white                 7=largest font
03m0001                               	
03m0001                               	CHaRacter:
03m0001                               	!00 06!07 13!14 20!21 27!28 34!35!
03m0001                               	! CH1 ! CH2 ! CH3 ! CH4 ! CH5 !1 !
03m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

04m0001                               	Vector algorithms:
04m0001                               	X(Y)=X(Y-1)+DXDY
04m0001                               	INTEN(Y,INT(X(Y)))=     3*(1-FRACT(X))          if A3DYDX GEQ 3
04m0001                               	                        3-A3DYDX*FRACT(X)       if A3DYDX < 3
04m0001                               	INTEN(Y,INT(X(Y))+1)=   3*FRACT(X)              if A3DYDX GEQ 3
04m0001                               	                        3-A3DYDX*(1-FRACT(X))   if A3DYDX < 3
04m0001                               	INTEN(Y,INT(X(Y))-K)=INTEN(Y,INT(X(Y))-(K-1))-A3DYDX
04m0001                               	INTEN(Y,INT(X(Y))+K)=INTEN(Y,INT(X(Y))+(K-1))-A3DYDX
04m0001                               	where:
04m0001                               	FRACT(X)        =fractional part of X
04m0001                               	INT(X)          =integer part of X
04m0001                               	X(Y)            =X(growing left to right) position as a function of
04m0001                               	                        Y(growing top to bottom)
04m0001                               	INTEN(Y,X)      =intensity as a function of position
04m0001                               	DXDY            =slope of X vs. Y
04m0001                               	A3DYDX          =three times the absolute value of the slope of Y vs. X
04m0001                               	\
04m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

05m0001                               	;Note that VIDTAB (the dispatch table) must appear before VIDIN
05m0001                               	;and VIDOUT due to forward referencing problems.
05m0001                               	
05m0001       0	        %VIDFOO = 0
05m0001                               	
05m0001                               	VIDTAB:         ;dispatch table used by both VIDIN and VIDOUT.
05m0001                               	.REPEAT 16.
05m0001                               	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001                               	        %VIDFOO = %VIDFOO + 1
05m0001                               	]       
05m0001 06225 240144430571000440000000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       1	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06226 240144430571000440010000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       2	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06227 240144430571000440020000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       3	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06230 240144430571000440030000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       4	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06231 240144430571000440040000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       5	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06232 240144430571000440050000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       6	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06233 240144430571000440060000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       7	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06234 240144430571000440070000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       10	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06235 240144430571000440100000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       11	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06236 240144430571000440110000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       12	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06237 240144430571000440120000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       13	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06240 240144430571000440130000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       14	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06241 240144430571000440140000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       15	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06242 240144430571000440150000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       16	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06243 240144430571000440160000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       17	        %VIDFOO = %VIDFOO + 1
05m0001                               	]
05m0001 06244 240144430571000440170000	[       MAPF[%VIDFOO] D[IOD] DEST[HOLD] JUMP[VIDCOM] C800$
05m0001       20	        %VIDFOO = %VIDFOO + 1
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

05m0001                               	]       ;i/o sub sel = ac. input data and hold for memory write.
05m0001                               	
05m0001 06245 640700014171014620000000	VIDIN:  D[CONST (VIDTAB / 100)] ROT[6] DEST[Q] NORM$
05m0001                               	                ;form high order 6 bits of table dispatch.
05m0001 06246 640700014175000250000000	        D[CONST (VIDTAB \ 100)] ALU[DORQ] DEST[Q] NORM$
05m0001                               	                ;or in low order 6 bits of table dispatch.
05m0001 06247 440540034435032043400000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] SDISP START-IN C600$
05m0001                               	                ;add ac field and dispatch. start input.
05m0001                               	
05m0001 06250 640702204571000440000000	VIDOUT: D[MEM] DEST[IOD] NORM$
05m0001                               	                ;put contents effective address into iod output register.
05m0001 06251 640700014171014620000000	        D[CONST (VIDTAB / 100)] ROT[6] DEST[Q] NORM$
05m0001                               	                ;form high order 6 bits of table dispatch.
05m0001 06252 640700014175000250000000	        D[CONST (VIDTAB \ 100)] ALU[DORQ] DEST[Q] NORM$
05m0001                               	                ;or in low order 6 bits of table dispatch.
05m0001 06253 440540034435032043600000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] SDISP START-OUT C600$
05m0001                               	                ;add ac field and dispatch. start output.
05m0001                               	
05m0001                               	VIDCOM:         ;common completion.
05m0001 06254 451140034571020440002026	        D[IR] ROT[8]    COND[OBUS<0] JUMP[MAIN] C600$
05m0001                               	                ;if VIDOUT, done. jump main.
05m0001 06255 662104000571000440002032	        STRT-WRT MEMST$ [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]
05m0001                               	                ;if VIDIN, write as in movem.
05m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

06m0001                               	;Main A-MEM:
06m0001       1	        INTEN,,FRACT    = 1     ;For storage of vector display word
06m0001       7	        POG,,POGB       = 7     ;Left by DPYINI
06m0001                               	
06m0001                               	.REPEAT XUCODE [
06m0001                               	        .USE[HIGHMEM]   ;If 8K u-mem present, put video code there.
06m0001                               	]
06m0001                               	[
06m0001                               	        .USE[HIGHMEM]    [ XLIST
06m0001                               	 LIST ];If 8K u-mem present, put video code there.
06m0001                               	]
06m0001                               	;This macro saves the address given as its argument so that returns
06m0001                               	;from interrupts can resume operation there. Jumps to VIDINT, which
06m0001                               	;saves AMEM, then goes to MAIN.
06m0001                               	
06m0001                               	;WARNING! WARNING !WARNING
06m0001                               	;THIS PIECE-OF-SHIT ASSEMBLER WON'T ACCEPT COMPOUND MACRO ARGUMENTS.
06m0001                               	;I.E., YOU MUST EVALUATE ARGUMENTS BEFORE INVOKING A MACRO.
06m0001                               	
06m0001                               	;ALSO, IF YOU CHANGE THE LENGTH OF THIS MACRO, REMEMBER TO ALTER THE
06m0001                               	;JUMP[. + 9]'S IN VIDRGT AND VIDLFT.
06m0001                               	
06m0001                               	.DEFINE VIDSAV[%ADR]
06m0001                               	[       D[CONST (%ADR / 10000)] ROT[12.] DEST[Q] NORM $
06m0001                               	                ;Q=high bit (SDISP loads all 16 bits)
06m0001                               	        D[CONST (77 & (%ADR / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
06m0001                               	                ;Q=next 6 ADR bits
06m0001                               	        D[CONST (%ADR \ 100)] ALU[QORD] DEST[HOLD] NORM $
06m0001                               	                ;Q=SAVE ADR
06m0001                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
06m0001                               	                ;Q=POGB
06m0001                               	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
06m0001                               	                ;MA=POGB+58     write SAVE ADR
06m0001                               	]
06m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

07m0001                               	;DPYINI
07m0001                               	;Save the POG block pointer for use by DPYOUT.
07m0001 10347 640701614571000360000000	VIDDPI: D[CONST 36] DEST[DEV-ADR] NORM $
07m0001                               	                ;DEV-ADR=36
07m0001 10350 640701634571000223000000	        D[IR] MASK[18.] DEST[POG,,POGB] DEST-A-MEM NORM $
07m0001                               	                ;POG,,POGB=0,,E
07m0001                               	
07m0001                               	;Zero all lengths.
07m0001 10351 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
07m0001                               	                ;Q=POGB.
07m0001 10352 640704400615000440000000	        ALU[0] DEST[HOLD] NORM $
07m0001                               	                ;HOLD=0
07m0001 10353 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
07m0001                               	                ;MA=POGB+56.    write (0) 
07m0001 10354 640746214571000170020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-WRT] D[CONST 15.] LLOAD NORM $
07m0001                               	                ;Touch          Loop 16 times
07m0001 10355 640720000555000440000000	VIDIN1: ALU[Q] DEST[MA] NORM $
07m0001                               	                ;MA=Q           read
07m0001 10356 640706000017000440020000	        MAPF[NORM-RD] ALU[Q+1] DEST[Q FIXMAC-MAPF-RD] CYLEN[FIXM] $
07m0001                               	                ;Q=Q+1          touch
07m0001 10357 640710004571006250000000	        D[MEM] ROT[3] MASK[21.] DEST[AR] NORM $
07m0001                               	                ;AR=BACKGROUND,LENGTH,,BEGINING LSH 3 MASK 21 (LENGTH=0)
07m0001 10360 640244200571102440000355	        D[AR] ROT[36. - 3] DEST[MEMSTO] LOOP[VIDIN1] NORM $
07m0001                               	                ;HOLD=BACKGROUND,0,,BEGINING    write and loop
07m0001                               	
07m0001                               	;Clear screen.
07m0001                               	        D[CONST 44] ROT[30.] DEST[IOD] START-OUT 
07m0001 10361 656142214571074443600000	                COND[HALF] JUMP[VIDNTR] NORM $
07m0001                               	                ;IOD=440000,,000000     Check HALF
07m0001 10362 240700014171014070120000	VIDHER: MAPF[12] D[CONST 7] ROT[6] DEST[Q] C800 $
07m0001                               	                ;VLDCTR (overwrite)     Q=7*64 (past vert. sync)
07m0001 10363 640710014571006360000000	        D[CONST 30.] ROT[3] DEST[AR] NORM $
07m0001                               	                ;AR=240. (major loops)
07m0001 10364 640740014571000710000000	VIDIN2: D[CONST 57.] LLOAD NORM $
07m0001                               	                ;Loop 58. times
07m0001 10365 640700014035000060000000	        D[CONST 6] ALU[Q+D] DEST[Q] NORM $
07m0001                               	                ;Q=Q+6 (past horiz. sync)
07m0001 10366 240702200555000443600000	VIDIN3: ALU[Q] DEST[IOD] START-OUT C800 $
07m0001                               	                ;IOD=Q
07m0001 10367 240700000571000440020000	        MAPF[2] C800 $
07m0001                               	                ;VLDADR
07m0001 10370 240702214571102073600000	        D[CONST 7] ROT[33.] DEST[IOD] START-OUT C800 $
07m0001                               	                ;IOD=700000,,000000
07m0001 10371 240700000571000443410000	        MAPF[1] START-IN C800 $
07m0001                               	                ;VLDDAT (blank)
07m0001 10372 240700000571000440070000	        MAPF[7]  C800 $
07m0001                               	                ;VWEVID
07m0001 10373 240700000571000440000000	        C800 $
07m0001                               	                ;WAIT
07m0001 10374 240702214435034013600000	        D[CONST 1] ROT[14.] ALU[Q+D] DEST[IOD] START-OUT C800 $
07m0001                               	                ;IOD=Q+1 FIELD
07m0001 10375 240700000571000440020000	        MAPF[2] C800 $
07m0001                               	                ;VLDADR
07m0001 10376 240702214571102073600000	        D[CONST 7] ROT[33.] DEST[IOD] START-OUT C800 $
07m0001                               	                ;IOD=700000,,000000
07m0001 10377 240700000571000443410000	        MAPF[1] START-IN C800 $
07m0001                               	                ;VLDDAT (blank)
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

07m0001                               	        MAPF[7] ALU[Q+1] DEST[Q]
07m0001 10400 241140000017000440070000	                COND[INTRPT] JUMP[VIDNTI] C800 $
07m0001                               	                ;VWEVID         Q=Q+1   If interrupt, save state
07m0001 10401 240240000571000440000366	VIDIN4: LOOP[VIDIN3] C800 $
07m0001                               	                ;loop
07m0001                               	        D[AR] ALU[D-1] DEST[AR]
07m0001 10402 470150000531000440000364	                COND[-OBUS=0] JUMP[VIDIN2] C600 $
07m0001                               	                ;AR=AR-1        if 0, done.
07m0001                               	
07m0001                               	;Done.
07m0001 10403 640141600615000442200344	        ALU[0] DEST[DEV-ADR] SPEC[CLR-HALF] JUMP[GOMAIN] NORM $
07m0001                               	                ;Reset device address, clear HALF
07m0001                               	
07m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

08m0001                               	;Interrupt init
08m0001 10404 640704400555000440000000	VIDNTI: ALU[Q] DEST[HOLD] NORM $
08m0001                               	                ;HOLD=Q
08m0001 10405 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
08m0001                               	                ;Q=POGB
08m0001 10406 640724014435014010000000	        D[CONST 1] ROT[6] ALU[Q+D] DEST[MA] STRT-WRT NORM $
08m0001                               	                ;MA=POGB+64.    write old Q
08m0001 10407 640706200571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] $
08m0001                               	                ;TOUCH
08m0001 10410 640704400571000440000000	        D[AR] DEST[HOLD] NORM $
08m0001                               	                ;HOLD=AR
08m0001 10411 640724014437014010000000	        D[CONST 1] ROT[6] ALU[D+Q+1] DEST[MA] STRT-WRT NORM $
08m0001                               	                ;MA=POGB+65.    write old AR
08m0001 10412 640706200571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-WRT] CYLEN[FIXM] $
08m0001                               	                ;TOUCH
08m0001 10413 640700014171076010000000	        D[CONST 1] ROT[35. - 4] DEST[Q] NORM $
08m0001                               	                ;Q=BIT 4 ON
08m0001 10414 640704620531000440000000	        D[PC] ALU[D-1] DEST[PC] NORM $
08m0001                               	                ;PC=PC-1
08m0001 10415 640705420575000440000000	        D[PC] ALU[DORQ] DEST[CRYOV] NORM $
08m0001                               	                ;Set HALF flag
08m0001 10416 640141600615000440000344	        ALU[0] DEST[DEV-ADR] JUMP[GOMAIN] NORM $
08m0001                               	                ;Reset dev and disp to intrpt
08m0001                               	
08m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

09m0001                               	;Return from init interupt.
09m0001 10417 240700074171000220120000	VIDNTR: MAPF[12] D[10 + POG,,POGB] MASK[18.] DEST[Q] C800 $
09m0001                               	                ;VLDCTR         Q=POGB
09m0001 10420 640720014437014010000000	        D[CONST 1] ROT[6] ALU[D+Q+1] DEST[MA] NORM $
09m0001                               	                ;MA=POGB+65.    read old AR
09m0001                               	        MAPF[NORM-RD] D[CONST 30.] ROT[3] DEST[Q FIXMAC-MAPF-RD]
09m0001 10421 640706014171006360020000	                CYLEN[FIXM] $
09m0001                               	                ;TOUCH          Q=240.
09m0001                               	        D[MEM] MASK[18.] ALU[Q-D]
09m0001 10422 451140004477000220000362	                COND[OBUS<0] JUMP[VIDHER] C600 $
09m0001                               	                ;Check for half word error (i.e. HALF left from another inst)
09m0001 10423 640710004571000220000000	        D[MEM] MASK[18.] DEST[AR] NORM $
09m0001                               	                ;Restore AR
09m0001 10424 240700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] C800 $
09m0001                               	                ;Q=POGB
09m0001 10425 640720014435014010000000	        D[CONST 1] ROT[6] ALU[Q+D] DEST[MA] NORM $
09m0001                               	                ;MA=POGB+64.    read old Q
09m0001 10426 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
09m0001                               	                ;TOUCH
09m0001                               	        D[MEM] MASK[6] DEST[Q]
09m0001 10427 530140004171000060000000	                COND[-OBUS=0] JUMP[VIDNR1] C550 $
09m0001                               	                ;Old Q mod 6.
09m0001 10430 640700014171014010000000	        D[CONST 1] ROT[6] DEST[Q] NORM $
09m0001                               	                ;If Q=0, Q=64.
09m0001 10431 640740014537014010000000	VIDNR1: D[CONST 1] ROT[6] ALU[D-Q] LLOAD NORM $
09m0001                               	                ;Count=remaining till end of line
09m0001 10432 640140004171000440000401	        D[MEM] DEST[Q] JUMP[VIDIN4] NORM $
09m0001                               	                ;Restore Q and resume from interrupt
09m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

10m0001                               	;DPYOUT (DPYADD) main loop
10m0001 10433 640700014171076010000000	VIDDPA: D[CONST 1] ROT[35. - 4] DEST[Q] NORM $
10m0001                               	                ;Q=BIT 4 ON
10m0001 10434 640705420575000440000000	        D[PC] ALU[DORQ] DEST[CRYOV] NORM $
10m0001                               	                ;SET HALF FLAG
10m0001                               	
10m0001                               	;FooVision device address (also AMEM block)
10m0001 10435 640701614571000360000000	VIDDPO: D[CONST 36] DEST[DEV-ADR] NORM $
10m0001                               	                ;DEV-ADR=36
10m0001                               	
10m0001                               	;Save AC=POG in AMEM
10m0001 10436 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10437 640710034571032040000000	        D[IR] ROT[13.] MASK[4] DEST[AR] NORM $
10m0001                               	                ;AR=POG=AC
10m0001 10440 640701600575044443000000	        D[AR] ROT[18.] ALU[DORQ] DEST[POG,,POGB] DEST-A-MEM NORM $
10m0001                               	                ;POG,,POGB=AC,,POGB
10m0001                               	
10m0001                               	;"Touch" the first and last words of the POG block, so we don't
10m0001                               	;have to worry about map faulting on them later.
10m0001 10441 640720074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q MA] NORM $
10m0001                               	                ;Q,MA=POGB
10m0001 10442 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH FIRST WORD
10m0001 10443 640710014531006110000000	        D[CONST 11] ROT[3] ALU[D-1] DEST[AR] NORM $
10m0001                               	                ;AR=71.
10m0001 10444 640720000435000440000000	        D[AR] ALU[D+Q] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+71.
10m0001 10445 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH LAST WORD
10m0001                               	
10m0001                               	;Touch E and E+1. If E+1(=length of display list)=0, don't bother to
10m0001                               	;touch display list.
10m0001 10446 640720034571000220000000	        D[IR] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=E
10m0001 10447 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH
10m0001 10450 640710004571000440000000	        D[MEM] DEST[AR] NORM $
10m0001                               	                ;AR=BEGINING
10m0001 10451 640720034433000220000000	        D[IR] MASK[18.] ALU[D+1] DEST[MA] NORM $
10m0001                               	                ;MA=E+1
10m0001 10452 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH
10m0001 10453 510140004571000440000000	        D[MEM] COND[OBUS=0] JUMP[VIDTDE] C550 $
10m0001                               	                ;If LENGTH=0, don't touch (but do continue)
10m0001                               	
10m0001                               	;Touch the display list. Start with the first word, touch every
10m0001                               	;512.th word until run off end. Then touch last word.
10m0001 10454 640720000171000440000000	VIDTDL: D[AR] DEST[Q MA] NORM $
10m0001                               	                ;Q,MA=AR (initially begining of display list)
10m0001                               	        MAPF[NORM-RD] D[CONST 1] ROT[9.] ALU[Q+D]
10m0001 10455 640716014035022010020000	                DEST[AR Q FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;AR,Q=AR+1 PAGE         touch (post inc)
10m0001 10456 640720034571000220000000	        D[IR] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=E
10m0001 10457 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

10m0001 10460 640700004077000440000000	        D[MEM] ALU[Q-D] DEST[Q] NORM $
10m0001                               	                ;Q=AR-BEGINING
10m0001 10461 640720034433000220000000	        D[IR] MASK[18.] ALU[D+1] DEST[MA] NORM $
10m0001                               	                ;MA=E+1
10m0001 10462 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001                               	        D[MEM] ALU[D-Q-1] DEST[Q]
10m0001 10463 471140004135000440000454	                COND[-OBUS<0] JUMP[VIDTDL] C600 $
10m0001                               	                ;Q=LENGTH-(AR-BEGINING)-1       if<0 done
10m0001 10464 640720000435000440000000	        D[AR] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=BEGINING+LENGTH-1
10m0001 10465 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH LAST PAGE
10m0001                               	
10m0001                               	;Touch the POG buffer for this POG. Same as for display list.
10m0001                               	;Use maximum of POG buffer length and display list length.
10m0001 10466 640720034433000220000000	VIDTDE: D[IR] MASK[18.] ALU[D+1] DEST[MA] NORM $
10m0001                               	                ;MA=E+1
10m0001 10467 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10470 640710004571044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[AR] NORM $
10m0001                               	                ;AR=LENGTH of display list,,0
10m0001 10471 640720074435044220000000	        D[10 + POG,,POGB] ROT[18.] MASK[18.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG
10m0001 10472 640700000171044440000000	        D[AR] ROT[18.] DEST[Q] NORM $
10m0001                               	                ;Q=LENGTH of display list
10m0001 10473 511140004537044170000000	        D[MEM] ROT[18.] MASK[15.] ALU[D-Q] COND[OBUS<0] JUMP[VIDTD1] C550 $
10m0001                               	                ;If LENGTH of POG buffer-LENGTH of display list<0, skip
10m0001 10474 640710004571044170000000	        D[MEM] ROT[18.] MASK[15.] DEST[AR] NORM $
10m0001                               	                ;AR=LENGTH of POG buffer
10m0001 10475 640710000571044440000000	        D[AR] ROT[18.] DEST[AR] NORM $
10m0001                               	                ;AR=LENGTH of POG buffer,,0
10m0001 10476 640700000171000440000000	VIDTD1: D[AR] DEST[Q] NORM $
10m0001                               	                ;Q=LENGTH of maximum,,0
10m0001 10477 640710204575000223000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[AR INTEN,,FRACT] DEST-A-MEM NORM $
10m0001                               	                ;INTEN,,FRACT,AR=LENGTH,,BEGINING POG
10m0001 10500 640720000171000440000000	VIDTNL: D[AR] DEST[Q MA] NORM $
10m0001                               	                ;Q,MA=AR
10m0001                               	        MAPF[NORM-RD] D[CONST 1] ROT[9.] ALU[Q+D]
10m0001 10501 640706014035022010020000	                DEST[Q FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;AR,Q=AR+1 PAGE         touch (post inc)
10m0001 10502 640710014477066010000000	        D[CONST 1] ROT[18. + 9.] ALU[Q-D] DEST[AR] NORM $
10m0001                               	                ;AR=AR+(-1000,,1000)
10m0001 10503 640700000171000000200000	        D[AR] SPEC[LEFT] DEST[Q] NORM $
10m0001                               	                ;Q=REMAINING LENGTH,,0
10m0001                               	        D[CONST 1] ROT[18.] ALU[Q-D]
10m0001 10504 471140014477044010000500	                COND[-OBUS<0] JUMP[VIDTNL] C600 $
10m0001                               	                ;If LENGTH LEQ 0, done
10m0001 10505 640700044131044170000000	        D[10 + INTEN,,FRACT] ROT[18.] MASK[15.] ALU[D-1] DEST[Q] NORM $
10m0001                               	                ;Q=LENGTH-1
10m0001 10506 640720044435000220000000	        D[10 + INTEN,,FRACT] MASK[18.] ALU[D+Q] DEST[MA] NORM $
10m0001                               	                ;MA=BEGINING+LENGTH-1
10m0001 10507 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH LAST WORD
10m0001                               	
10m0001                               	;Touch all 7 fonts. Same as above.
10m0001                               	VIDTNE:
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

10m0001 10510 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10511 640710014435000600000000	        D[CONST 48.] ALU[Q+D] DEST[AR] NORM $
10m0001                               	                ;AR=POGB+48
10m0001 10512 640740014571000060000000	        D[CONST 6] LLOAD NORM $
10m0001                               	                ;LOOP 7 TIMES
10m0001 10513 640730000433000440000000	VIDTFL: D[AR] ALU[D+1] DEST[MA AR] NORM $
10m0001                               	                ;MA,AR=AR+1
10m0001 10514 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10515 640720004171000220000000	        D[MEM] MASK[18.] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=FONT 1
10m0001 10516 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001                               	.REPEAT 3
10m0001                               	[       D[CONST 1] ROT[9.] ALU[Q+D] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=Q+1 PAGE
10m0001                               	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001                               	]
10m0001                               	
10m0001 10517 640720014035022010000000	[       D[CONST 1] ROT[9.] ALU[Q+D] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=Q+1 PAGE
10m0001 10520 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001                               	]
10m0001 10521 640720014035022010000000	[       D[CONST 1] ROT[9.] ALU[Q+D] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=Q+1 PAGE
10m0001 10522 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001                               	]
10m0001 10523 640720014035022010000000	[       D[CONST 1] ROT[9.] ALU[Q+D] DEST[MA Q] NORM $
10m0001                               	                ;MA,Q=Q+1 PAGE
10m0001 10524 640706000571000440020000	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE
10m0001 10525 640700014131022010000000	]       D[CONST 1] ROT[9.] ALU[D-1] DEST[Q] NORM $
10m0001                               	                ;Q=1 PAGE - 1 WORD
10m0001 10526 640720024435000440000000	        D[MA] ALU[D+Q] DEST[MA] NORM $
10m0001                               	                ;MA=LAST WORD OF FONT
10m0001 10527 640246000571000440020513	        MAPF[NORM-RD] DEST[FIXMAC-MAPF-RD] LOOP[VIDTFL] CYLEN[FIXM] $
10m0001                               	                ;TOUCH PAGE     LOOP
10m0001                               	
10m0001                               	;If length rememaining not 0, return from interrupt.
10m0001 10530 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10531 640720014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+56.    read LENGTH REMAINING
10m0001 10532 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10533 530140004571000440000000	        D[MEM] COND[-OBUS=0] JUMP[VIDRET] C550 $
10m0001                               	                ;If LENGTH REMAINING NEQ 0, return from interrupt
10m0001                               	
10m0001                               	;Check HALF flag to see if DPYADD.
10m0001 10534 676140000571000440000000	        COND[-HALF] JUMP[VIDMHL] NORM $
10m0001                               	                ;If HALF, DPYADD
10m0001                               	
10m0001                               	;Form the display list and POG buffer pointers.
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

10m0001 10535 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10536 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG    read LENGTH,,BEGINING
10m0001 10537 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10540 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=0,,BEGINING
10m0001 10541 640700004035044170000000	        D[MEM] ROT[18.] MASK[15.] ALU[Q+D] DEST[Q] NORM $
10m0001                               	                ;Q=0,,BEGINING+LENGTH
10m0001 10542 640720034571000440000000	        D[IR] DEST[MA] NORM $
10m0001                               	                ;MA=E   read BEGINING
10m0001 10543 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10544 640704404575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=DISP BEGINING,,POG BEGINING+LENGTH
10m0001 10545 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10546 640724014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+57.    write DISP BEGINING,,POG BEGINING
10m0001                               	
10m0001                               	;Get length of display list and load control register
10m0001                               	;with code for addition. Add to length in POG.
10m0001 10547 640720034433000220000000	        D[IR] MASK[18.] ALU[D+1] DEST[MA] NORM $
10m0001                               	                ;MA=E+1         read LENGTH
10m0001 10550 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10551 640714404571000170000000	        D[MEM] MASK[15.] DEST[AR HOLD] NORM $
10m0001                               	                ;AR,HOLD=LENGTH
10m0001 10552 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+56.    write LENGTH
10m0001 10553 640702214571074643600000	        D[CONST 64] ROT[30.] DEST[IOD] START-OUT NORM $
10m0001                               	                ;IOD=640000,,000000
10m0001 10554 640720074435044220120000	        MAPF[12] D[10 + POG,,POGB] ROT[18.] MASK[18.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;VLDCTR (add)   MA=POGB+POG     read BACK,LENGTH,,BEGIN
10m0001 10555 640700000171044440000000	        D[AR] ROT[18.] DEST[Q] NORM $
10m0001                               	                ;Q=LENGTH,,0
10m0001 10556 640144204435000440000000	        D[MEM] ALU[D+Q] DEST[MEMSTO] JUMP[VIDMLL] NORM $
10m0001                               	                ;HOLD=BACK,LENGTH+LENGTH,,BEGIN write
10m0001                               	
10m0001                               	;This is the outermost loop. It is gone through twice, once with
10m0001                               	;first-half-done off subtracting the previous POG buffer, then with
10m0001                               	;first-half-done on adding the display list and copying into the
10m0001                               	;POG buffer.
10m0001                               	
10m0001                               	;Form the display list and POG buffer pointers.
10m0001 10557 640700074171000220000000	VIDMHL: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10560 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG    read LENGTH,,BEGINING
10m0001 10561 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10562 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=0,,BEGINING
10m0001 10563 640720034571000440000000	        D[IR] DEST[MA] NORM $
10m0001                               	                ;MA=E   read BEGINING
10m0001 10564 640700000571000440000000	        NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

10m0001                               	                ;WAIT
10m0001 10565 640704404575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=DISP BEGINING,,POG BEGINING
10m0001 10566 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10567 640724014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+57.    write DISP BEGINING,,POG BEGINING
10m0001                               	
10m0001                               	;Check for first half done.
10m0001 10570 656140000571000440000000	        COND[HALF] JUMP[VIDMHH] NORM $
10m0001                               	                ;IF -HALF:
10m0001                               	
10m0001                               	;If first half not done, get length of POG buffer and load the control
10m0001                               	;register with the code for subtraction.
10m0001 10571 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10572 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+POG    read LENGTH,,BEGINING
10m0001 10573 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10574 640704404571044170000000	        D[MEM] ROT[18.] MASK[15.] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=LENGTH
10m0001 10575 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+56.    write LENGTH
10m0001 10576 640702214571074743600000	        D[CONST 74] ROT[30.] DEST[IOD] START-OUT NORM $
10m0001                               	                ;IOD=740000,,000000
10m0001 10577 240140000571000440120000	        MAPF[12] JUMP[VIDMLL] C800 $
10m0001                               	                ;VLDCTR (subtract)
10m0001                               	
10m0001                               	;If first half done, get length of display list and load control register
10m0001                               	;with code for addition. Put length in POG.
10m0001 10600 640720034433000220000000	VIDMHH: D[IR] MASK[18.] ALU[D+1] DEST[MA] NORM $
10m0001                               	                ;MA=E+1         read LENGTH
10m0001 10601 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10602 640714404571000170000000	        D[MEM] MASK[15.] DEST[AR HOLD] NORM $
10m0001                               	                ;AR,HOLD=LENGTH
10m0001 10603 640724014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POGB+56.    write LENGTH
10m0001 10604 640702214571074643600000	        D[CONST 64] ROT[30.] DEST[IOD] START-OUT NORM $
10m0001                               	                ;IOD=640000,,000000
10m0001 10605 640720074435044220120000	        MAPF[12] D[10 + POG,,POGB] ROT[18.] MASK[18.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;VLDCTR (add)   MA=POGB+POG     read BACK,LENGTH,,BEGIN
10m0001 10606 640700000171044440000000	        D[AR] ROT[18.] DEST[Q] NORM $
10m0001                               	                ;Q=LENGTH,,0
10m0001 10607 640710004571006250000000	        D[MEM] ROT[3] MASK[21.] DEST[AR] NORM $
10m0001                               	                ;AR=BACK,LENGTH,,BEGIN LSH3 ROT21 (LENGTH=0)
10m0001 10610 000704200575102440000000	        D[AR] ROT[36. - 3] ALU[DORQ] DEST[MEMSTO] $
10m0001                               	                ;HOLD=BACK,LENGTH,,BEGIN        write
10m0001                               	
10m0001                               	;This is the display list or POG buffer loop. It extracts words and
10m0001                               	;determines whether they are characters or vectors.
10m0001                               	
10m0001                               	;If length = 0, go to end of half-done loop.
10m0001 10611 640700074171000220000000	VIDMLL: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10612 640720014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

10m0001                               	                ;MA=POGB+56.    read LENGTH
10m0001 10613 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10614 510140004571000220000000	        D[MEM] MASK[18.] COND[OBUS=0] JUMP[VIDMHE] C550 $
10m0001                               	                ;If LENGTH=0, end
10m0001                               	
10m0001                               	;Read pointers and chech half.
10m0001 10615 640720014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+57.    read DISP LIST PTR,,POG BUFF PTR
10m0001 10616 656140000571000440000000	        COND[HALF] JUMP[VIDMLH] NORM $
10m0001                               	                ;If -HALF
10m0001                               	
10m0001                               	;If first half not done, read from POG buffer.
10m0001 10617 640720004571000220000000	        D[MEM] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=POG BUFF PTR        read POG WORD
10m0001 10620 640140000571000440000000	        JUMP[VIDMLE] NORM $
10m0001                               	                ;WAIT
10m0001                               	
10m0001                               	;If first half done, read from display list and copy into POG buffer.
10m0001 10621 640720004571044220000000	VIDMLH: D[MEM] ROT[18.] MASK[18.] DEST[MA] NORM $
10m0001                               	                ;MA=DISP LIST PTR       read DISPLAY WORD
10m0001 10622 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10623 640710004571000440000000	        D[MEM] DEST[AR] NORM $
10m0001                               	                ;AR=DISPLAY WORD
10m0001 10624 640720014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+57.    read DISP LIST PTR,,POG BUFF PTR
10m0001 10625 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10626 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q]  NORM $
10m0001                               	                ;Q=POG BUFF PTR
10m0001 10627 640704400571000440000000	        D[AR] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=DISPLAY WORD
10m0001 10630 640724000555000440000000	        ALU[Q] DEST[MA] STRT-WRT NORM $
10m0001                               	                ;MA=POG BUFF PTR        write DISPLAY WORD
10m0001 10631 640704400571000440000000	        D[AR] DEST[HOLD] NORM $
10m0001                               	                ;HOLD=DISPLAY WORD
10m0001                               	;;;Please note the above kludge. This is necessary because HOLD
10m0001                               	;;;forgets its data whenever MA changes, even on a write (contrary
10m0001                               	;;;to the explanation in the microcode manual).
10m0001                               	
10m0001                               	;Decode opcode of display word (character or vector).
10m0001 10632 640700204571000443000000	VIDMLE: D[MEM] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
10m0001                               	                ;INTEN,,FRACT=NEXT WORD
10m0001                               	        D[MEM] MASK[1]
10m0001 10633 530140004571000010000000	                COND[-OBUS=0] JUMP[VIDCHI] C550 $
10m0001                               	                ;If bit 35=1, character
10m0001 10634 640700004171000040000000	        D[MEM] MASK[4] DEST[Q] NORM $
10m0001                               	                ;Q=4 LSB'S
10m0001                               	        D[CONST 02] ALU[Q#D]
10m0001 10635 510140014735000020000000	                COND[OBUS=0] JUMP[VIDVCI] C550 $
10m0001                               	                ;If 4 lsb's=0010, vector
10m0001                               	
10m0001                               	;Decrement length, and increment pointers.
10m0001 10636 640700074171000220000000	VIDDON: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
10m0001                               	                ;Q=POGB
10m0001 10637 640720014435000700000000	        D[CONST 56.] ALU[Q+D] DEST[MA] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

10m0001                               	                ;MA=POGB+56.    read LENGTH
10m0001 10640 640700000571000440000000	        NORM $
10m0001                               	                ;WAIT
10m0001 10641 640704204531000440000000	        D[MEM] ALU[D-1] DEST[MEMSTO] NORM $
10m0001                               	                ;HOLD=LENGTH-1  write LENGTH
10m0001 10642 640720014435000710000000	        D[CONST 57.] ALU[Q+D] DEST[MA] NORM $
10m0001                               	                ;MA=POGB+57.    read DISP LIST PTR,,POG BUFF PTR
10m0001 10643 640700014171001000000000	        D[CONST 1,,1] DEST[Q] NORM $
10m0001                               	                ;Q=1,,1
10m0001 10644 640144204435000440000611	        D[MEM] ALU[D+Q] DEST[MEMSTO] JUMP[VIDMLL] NORM $
10m0001                               	                ;HOLD=DISP LIST PTR,,POG BUFF PTR + 1,,1        write
10m0001                               	
10m0001                               	;If first half done, terminate. If not, set HALF flag and loop
10m0001 10645 656140000571000440000000	VIDMHE: COND[HALF] JUMP[VIDEND] NORM $
10m0001                               	                ;If HALF, end
10m0001 10646 640700014171076010000000	        D[CONST 1] ROT[35. - 4] DEST[Q] NORM $
10m0001                               	                ;Q=bit 4 on
10m0001 10647 640145420575000440000557	        D[PC] ALU[DORQ] DEST[CRYOV] JUMP[VIDMHL] NORM $
10m0001                               	                ;Set HALF flag and loop
10m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

11m0001                               	;Interrupt and End
11m0001                               	;Save AMEM and go to MAIN to take interrupt.
11m0001 10650 640144620531000440000000	VIDINT: D[PC] ALU[D-1] DEST[PC] JUMP[VIDSAM] NORM $
11m0001                               	                ;PC=PC-1
11m0001 10651 640700000571000442200000	VIDEND: SPEC[CLR-HALF] NORM $
11m0001                               	                ;Clear HALF
11m0001 10652 640700074171000220000000	VIDSAM: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
11m0001                               	                ;Q=POGB
11m0001 10653 640700014035014010000000	        D[CONST 1] ROT[6] ALU[Q+D] DEST[Q] NORM $
11m0001                               	                ;Q=POGB+64.
11m0001       0	        %VIDFOO = 0
11m0001                               	.REPEAT 8.
11m0001                               	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001                               	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001                               	        %VIDFOO = %VIDFOO + 1
11m0001                               	]
11m0001                               	
11m0001 10654 640704440571000440000000	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10655 640724014435000000000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       1	        %VIDFOO = %VIDFOO + 1
11m0001                               	]
11m0001 10656 640704444571000440000000	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10657 640724014435000010000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       2	        %VIDFOO = %VIDFOO + 1
11m0001                               	]
11m0001 10660 640704450571000440000000	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10661 640724014435000020000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       3	        %VIDFOO = %VIDFOO + 1
11m0001                               	]
11m0001 10662 640704454571000440000000	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10663 640724014435000030000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       4	        %VIDFOO = %VIDFOO + 1
11m0001                               	]
11m0001 10664 640704460571000440000000	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10665 640724014435000040000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       5	        %VIDFOO = %VIDFOO + 1
11m0001                               	]
11m0001 10666 640704464571000440000000	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10667 640724014435000050000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       6	        %VIDFOO = %VIDFOO + 1
11m0001                               	]
11m0001 10670 640704470571000440000000	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

11m0001 10671 640724014435000060000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       7	        %VIDFOO = %VIDFOO + 1
11m0001                               	]
11m0001 10672 640704474571000440000000	[       D[10 + %VIDFOO] DEST[HOLD] NORM $
11m0001                               	                ;HOLD=AMEM[%VIDFOO]
11m0001 10673 640724014435000070000000	        D[CONST %VIDFOO] ALU[Q+D] DEST[MA] STRT-WRT NORM $
11m0001                               	                ;MA=POGB+64.+%VIDFOO    write
11m0001       10	        %VIDFOO = %VIDFOO + 1
11m0001 10674 640141600615000440000344	]       ALU[0] DEST[DEV-ADR] JUMP[GOMAIN] NORM $
11m0001                               	                ;Reset device address, dispatch to interrupt or next instr.
11m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

12m0001                               	;Recovery
12m0001                               	;Restore AMEM.
12m0001 10675 640700074171000220000000	VIDRET: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
12m0001                               	                ;Q=POGB
12m0001 10676 640700014035014010000000	        D[CONST 1] ROT[6] ALU[Q+D] DEST[Q] NORM $
12m0001                               	                ;Q=POGB+64.
12m0001       0	        %VIDFOO = 0
12m0001                               	.REPEAT 8.
12m0001                               	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001                               	        NORM $
12m0001                               	                ;WAIT
12m0001                               	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001                               	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001                               	
12m0001 10677 640720014435000000000000	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10700 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10701 640700004571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       1	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001 10702 640720014435000010000000	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10703 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10704 640700204571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       2	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001 10705 640720014435000020000000	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10706 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10707 640700404571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       3	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001 10710 640720014435000030000000	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10711 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10712 640700604571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       4	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001 10713 640720014435000040000000	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10714 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10715 640701004571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       5	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

12m0001 10716 640720014435000050000000	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10717 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10720 640701204571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       6	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001 10721 640720014435000060000000	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10722 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10723 640701404571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       7	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001 10724 640720014435000070000000	[       D[CONST %VIDFOO] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+64.+%VIDFOO    read
12m0001 10725 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10726 640701604571000443000000	        D[MEM] DEST[%VIDFOO] DEST-A-MEM NORM $
12m0001                               	                ;AMEM[%VIDFOO]=MEM
12m0001       10	        %VIDFOO = %VIDFOO + 1
12m0001                               	]
12m0001                               	;Check for first half done.
12m0001                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q]
12m0001 10727 656140074171000220000000	                COND[HALF] JUMP[VIDRIH] NORM $
12m0001                               	                ;Q=POGB         If -HALF
12m0001                               	
12m0001                               	;If first half not done, default color = background for that POG
12m0001                               	;and xor mask = -1.
12m0001 10730 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[D+Q] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+POG    read BACKGROUND
12m0001 10731 640700014131102010000000	        D[CONST 1] ROT[33.] ALU[D-1] DEST[Q] NORM $
12m0001                               	                ;Q=077777,,777777
12m0001                               	.REPEAT VIC2 [
12m0001                               	        D[MEM] ALU[DORQ] DEST[IOD] START-OUT JUMP[VIDRIE] NORM $
12m0001                               	                ;IOD=BACKGROUND 77777,,777777
12m0001                               	];VIC2
12m0001                               	.REPEAT 1 - VIC2 [
12m0001                               	        D[MEM] ALU[DORQ] DEST[HOLD] NORM $
12m0001                               	                ;MEM=BACKGROUND 77777,,777777
12m0001                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
12m0001                               	                ;Q=POGB
12m0001                               	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDRIE] NORM $
12m0001                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
12m0001                               	];[
12m0001 10732 640704404575000440000000	        D[MEM] ALU[DORQ] DEST[HOLD] NORM $
12m0001                               	                ;MEM=BACKGROUND 77777,,777777
12m0001 10733 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
12m0001                               	                ;Q=POGB
12m0001 10734 640164014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDRIE] NORM $
12m0001                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
12m0001                               	]1-VIC2
12m0001                               	
12m0001                               	;If first half done, default color = last color, and xor mask = 0.
12m0001 10735 640720014435000600000000	VIDRIH: D[CONST 48.] ALU[Q+D] DEST[MA] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

12m0001                               	                ;MA=POGB+48.    read LAST COLOR
12m0001 10736 640710014531102010000000	        D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
12m0001                               	                ;AR=077777,,777777
12m0001 10737 640700004171000440000000	        D[MEM] DEST[Q] NORM $
12m0001                               	                ;Q=LAST COLOR,,LAST FONT
12m0001                               	.REPEAT VIC2 [
12m0001                               	        D[AR] ALU[-D&Q] DEST[IOD] START-OUT NORM $
12m0001                               	                ;IOD=LAST COLOR 00000,,000000
12m0001                               	];VIC2
12m0001                               	.REPEAT 1 - VIC2 [
12m0001                               	        D[AR] ALU[-D&Q] DEST[HOLD] NORM $
12m0001                               	                ;MEM=LAST COLOR 00000,,000000
12m0001                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
12m0001                               	                ;Q=POGB
12m0001                               	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
12m0001                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
12m0001                               	        NORM $
12m0001                               	                ;WAIT
12m0001                               	];[
12m0001 10740 640704400675000440000000	        D[AR] ALU[-D&Q] DEST[HOLD] NORM $
12m0001                               	                ;MEM=LAST COLOR 00000,,000000
12m0001 10741 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
12m0001                               	                ;Q=POGB
12m0001 10742 640724014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
12m0001                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
12m0001 10743 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001                               	]1-VIC2
12m0001                               	
12m0001                               	;Dispatch to saved microcode address to resume from interrupt.
12m0001 10744 240700074171000220100000	VIDRIE: MAPF[10] D[10 + POG,,POGB] MASK[18.] DEST[Q] C800 $
12m0001                               	                ;VLDCOL         Q=POGB
12m0001 10745 640720014435000720000000	        D[CONST 58.] ALU[Q+D] DEST[MA] NORM $
12m0001                               	                ;MA=POGB+58.    read SAVE ADR
12m0001 10746 640700000571000440000000	        NORM $
12m0001                               	                ;WAIT
12m0001 10747 540540004571000440000000	        D[MEM] SDISP C500 $
12m0001                               	                ;Dispatch on SAVE ADR
12m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

13m0001                               	;Character A-MEM:
13m0001                               	
13m0001       0	        WORD,,PIXEL3    = 0
13m0001       1	        YSIZE-1,,FONTPTR = 1
13m0001       2	        XMAX,,XMIN      = 2
13m0001       3	        YMAX,,YMIN      = 3
13m0001       4	        COLOR           = 4
13m0001       5	        XSIZE3,,XSIZE   = 5
13m0001       6	        LINE,,BYTEPTR   = 6
13m0001       7	        POG,,POGB       = 7
13m0001                               	
13m0001                               	;Note: The zeroth word of the font contains HEIGHT,,WIDTH
13m0001                               	;for that font.
13m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

14m0001                               	;Character body
14m0001                               	
14m0001                               	;Get initial word and 3*pixel.
14m0001 10750 640700074171000220000000	VIDCHI: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 10751 640720014435000750000000	        D[CONST 61.] ALU[Q+D] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+61.    read X0,,X1
14m0001 10752 640700014131014050000000	        D[CONST 5] ROT[6] ALU[D-1] DEST[Q] NORM $
14m0001                               	                ;Q=319.
14m0001 10753 640710004035000220000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[Q AR] NORM $
14m0001                               	                ;Q,AR=X1+319. (0=left hand edge)
14m0001 10754 640050000435002440000000	        D[AR] ROT[1] ALU[D+Q] DEST[AR] PUSHJ[VIDD33] NORM $
14m0001                               	                ;AR=3*(corrected X coordinate), divide by 33
14m0001 10755 640700004575044443000000	        D[MEM] ROT[18.] ALU[DORQ] DEST[WORD,,PIXEL3] DEST-A-MEM NORM $
14m0001                               	                ;WORD,,PIXEL3=QUOTIENT,,REMAINDER
14m0001                               	
14m0001                               	;Initialize line and byte pointers.
14m0001 10756 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+62.    read Y0,,Y1
14m0001 10757 640700014171060040000000	        D[CONST 4] ROT[18. + 6] DEST[Q] NORM $
14m0001                               	                ;Q=256,,0
14m0001 10760 640700004035044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=Y1+256.,,0
14m0001 10761 640701414575000073000000	        D[CONST 7] ALU[DORQ] DEST[LINE,,BYTEPTR] DEST-A-MEM NORM $
14m0001                               	                ;LINE,,BYTEPTR=Y1+256.,,7
14m0001                               	
14m0001                               	;Form XMAX,,XMIN
14m0001 10762 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 10763 640700074035044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[Q] NORM $
14m0001                               	                ;Q=POGB+POG
14m0001 10764 640720014435000200000000	        D[CONST 16.] ALU[Q+D] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+16.+POG        read XMAX,,XMIN
14m0001 10765 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 10766 640700404571000443000000	        D[MEM] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
14m0001                               	                ;XMAX,,XMIN
14m0001                               	
14m0001                               	;Form YMAX,,YMIN
14m0001 10767 640700024171000440000000	        D[MA] DEST[Q] NORM $
14m0001                               	                ;Q=MA
14m0001 10770 640720014435000200000000	        D[CONST 16.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+32.+POG        read YMAX,,YMIN
14m0001 10771 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 10772 640700604571000443000000	        D[MEM] DEST[YMAX,,YMIN] DEST-A-MEM NORM $
14m0001                               	                ;YMAX,,YMIN
14m0001                               	
14m0001                               	;Get width and 3*width of character.
14m0001 10773 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 10774 640720014435000600000000	        D[CONST 48.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+48.    read LAST COLOR,,LAST FONT
14m0001 10775 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 10776 640720004571000220000000	        D[MEM] MASK[18.] DEST[MA] NORM $
14m0001                               	                ;MA=0,,LAST FONT        read YSIZE,,XSIZE
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

14m0001 10777 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 11000 640710004171000220000000	        D[MEM] MASK[18.] DEST[AR Q] NORM $
14m0001                               	                ;AR,Q=0,,XSIZE
14m0001 11001 640700000035044440000000	        D[AR] ROT[18.] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=XSIZE,,XSIZE
14m0001 11002 640701200435046443000000	        D[AR] ROT[18. + 1] ALU[D+Q] DEST[XSIZE3,,XSIZE] DEST-A-MEM NORM $
14m0001                               	                ;XSIZE3,,XSIZE=XSIZE*3,,XSIZE
14m0001                               	
14m0001                               	;Test HALF flag.
14m0001                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q]
14m0001 11003 656140074171000220000000	                COND[HALF] JUMP[VIDCHH] NORM $
14m0001                               	                ;Q=POGB         if -HALF
14m0001                               	
14m0001                               	;If not HALF, subtract old image with color=background.
14m0001 11004 640720074435044220000000	        D[10 + POG,,POGB] ROT[18.] MASK[18.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+POG    read BACKGROUND
14m0001 11005 640700014131102010000000	        D[CONST 1] ROT[33.] ALU[D-1] DEST[Q] NORM $
14m0001                               	                ;Q=077777,,777777
14m0001 11006 640141004575000443000000	        D[MEM] ALU[DORQ] DEST[COLOR] DEST-A-MEM JUMP[VIDSCL] NORM $
14m0001                               	                ;COLOR=BACKGROUND 77777,,777777
14m0001                               	
14m0001                               	;If HALF, add new image with last color.
14m0001 11007 640720014435000600000000	VIDCHH: D[CONST 48.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+48.    read LAST COLOR
14m0001 11010 640710014531102010000000	        D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
14m0001                               	                ;AR=077777,,777777
14m0001 11011 640700004171000440000000	        D[MEM] DEST[Q] NORM $
14m0001                               	                ;Q=LAST COLOR,,LAST FONT
14m0001 11012 640701000675000443000000	        D[AR] ALU[-D&Q] DEST[COLOR] DEST-A-MEM NORM $
14m0001                               	                ;COLOR=LAST COLOR 00000,,000000
14m0001                               	
14m0001                               	;This is the character scanning loop.
14m0001                               	
14m0001                               	;Set up font pointer. Flush nulls.
14m0001 11013 640700074171000220000000	VIDSCL: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11014 640720014435000710000000	        D[CONST 57.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+57.    read DISPLAY BUFFER POINTER
14m0001 11015 656140000571000440000000	        COND[HALF] JUMP[VIDSC1] NORM $
14m0001                               	                ;If -HALF
14m0001 11016 640160004571000220000000	        D[MEM] MASK[18.] DEST[MA] JUMP[VIDSC2] NORM $
14m0001                               	                ;MA=POG PTR     read
14m0001 11017 640720004571044220000000	VIDSC1: D[MEM] ROT[18.] MASK[18.] DEST[MA] NORM $
14m0001                               	                ;MA=DISP PTR    read
14m0001 11020 640701270571000440000000	VIDSC2: D[10 + LINE,,BYTEPTR] DEST[ROTR] NORM $
14m0001                               	                ;ROTR=LINE,,BYTEPTR
14m0001                               	        D[MEM] ROT[R] MASK[7] DEST[AR]
14m0001 11021 510150004571200070000000	                COND[OBUS=0] JUMP[VIDSCN] C550 $
14m0001                               	                ;AR=ASCII       if 0, next character
14m0001 11022 640720014435000600000000	        D[CONST 48.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+48.    read LAST FONT
14m0001 11023 640700000171010440000000	        D[AR] ROT[4] DEST[Q] NORM $
14m0001                               	                ;Q=0,,ASCII*16.
14m0001 11024 640700204435000223000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[YSIZE-1,,FONTPTR] DEST-A-MEM NORM $
14m0001                               	                ;YSIZE-1,,FONTPTR=0,,LAST FONT+ASCII*16.
14m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

14m0001                               	;Initialize YSIZE-1
14m0001 11025 640720004571000220000000	        D[MEM] MASK[18.] DEST[MA] NORM $
14m0001                               	                ;MA=LAST FONT   read YSIZE,,XSIZE
14m0001 11026 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 11027 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=YSIZE,,0
14m0001 11030 640700044175000440000000	        D[10 + YSIZE-1,,FONTPTR] ALU[DORQ] DEST[Q] NORM $
14m0001                               	                ;Q=YSIZE,,FONTPTR
14m0001 11031 640700214477044013000000	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[YSIZE-1,,FONTPTR] DEST-A-MEM NORM $
14m0001                               	                ;YSIZE-1,,FONTPTR
14m0001                               	
14m0001                               	;Increment position one character width (right or down).
14m0001 11032 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11033 640720014435000600000000	        D[CONST 48.] ALU[Q+D] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+48.    read last font
14m0001 11034 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 11035 640720004571000220000000	        D[MEM] MASK[18.] DEST[MA] NORM $
14m0001                               	                ;MA=LAST FONT   read YSIZE,,XSIZE
14m0001 11036 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 11037 640710004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q AR] NORM $
14m0001                               	                ;AR,Q=YSIZE,,0
14m0001                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[Q-D]
14m0001 11040 451140004477044000200000	                COND[OBUS<0] JUMP[VIDCCS] C600 $
14m0001                               	                ;If YSIZE-XSIZE<0, sideways
14m0001                               	
14m0001                               	;Update X0,,X1.
14m0001 11041 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11042 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+61.    read X0,,X1
14m0001 11043 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 11044 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=0,,X1
14m0001 11045 640710064435000220000000	        D[10 + XSIZE3,,XSIZE] MASK[18.] ALU[D+Q] DEST[AR] NORM $
14m0001                               	                ;AR=0,,X1+XSIZE
14m0001 11046 640700004171044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=X1,,0
14m0001 11047 640714200575000440000000	        D[AR] ALU[DORQ] DEST[AR MEMSTO] NORM $
14m0001                               	                ;AR,HOLD=X1,,X1+XSIZE   write X0,,X1
14m0001                               	
14m0001                               	;Update Y0,,Y1.
14m0001 11050 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+62.    read Y0,,Y1
14m0001 11051 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 11052 000700004171000220000000	        D[MEM] MASK[18.] DEST[Q] $
14m0001                               	                ;Q=0,,Y1
14m0001 11053 640144204575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] JUMP[VIDCCL] NORM $
14m0001                               	                ;HOLD=Y1,,Y1    write Y0,,Y1
14m0001                               	
14m0001                               	;Update X0,,X1.
14m0001 11054 640700074171000220000000	VIDCCS: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

14m0001                               	                ;Q=POGB
14m0001 11055 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+61.    read X0,,X1
14m0001 11056 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 11057 000700004171000220000000	        D[MEM] MASK[18.] DEST[Q] $
14m0001                               	                ;Q=0,,X1
14m0001 11060 640704204575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] NORM $
14m0001                               	                ;HOLD=X1,,X1    write X0,,X1
14m0001                               	
14m0001                               	;Update Y0,,Y1.
14m0001 11061 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
14m0001                               	                ;MA=POGB+62.    read Y0,,Y1
14m0001 11062 640700000571000440000000	        NORM $
14m0001                               	                ;WAIT
14m0001 11063 640700004171000220000000	        D[MEM] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=0,,Y1
14m0001 11064 640710000477044440000000	        D[AR] ROT[18.] ALU[Q-D] DEST[AR] NORM $
14m0001                               	                ;AR=0,,Y1-YSIZE
14m0001 11065 640700004171044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=Y1,,0
14m0001 11066 640714200575000220000000	        D[AR] MASK[18.] ALU[DORQ] DEST[AR MEMSTO] NORM $
14m0001                               	                ;AR,HOLD=Y1,,Y1-YSIZE   write Y0,,Y1
14m0001                               	
14m0001                               	;Check X limits.
14m0001 11067 640700000171000000200000	VIDCCL: D[AR] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=X0,,0
14m0001                               	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] ALU[Q-D]
14m0001 11070 451140050477044000200000	                COND[OBUS<0] JUMP[VIDCHS] C600 $
14m0001                               	                ;if X0,,0-XMIN,,0<0 skip
14m0001 11071 640700064035044000200000	        D[10 + XSIZE3,,XSIZE] ROT[18.] SPEC[LEFT] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=X0,,0+XSIZE,,0
14m0001                               	        D[10 + XMAX,,XMIN] SPEC[LEFT] ALU[D-Q]
14m0001 11072 451140050537000000200000	                COND[OBUS<0] JUMP[VIDCHS] C600 $
14m0001                               	                ;if XMAX,,0-(X0+XSIZE),,0<0 skip
14m0001                               	
14m0001                               	;Check Y limits.
14m0001 11073 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
14m0001                               	                ;Q=Y0,,0
14m0001                               	        D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] ALU[Q-D]
14m0001 11074 451140054477044000200000	                COND[OBUS<0] JUMP[VIDCHS] C600 $
14m0001                               	                ;if Y0,,0-YMIN,,0<0 skip
14m0001 11075 640700044035000000200000	        D[10 + YSIZE-1,,FONTPTR] SPEC[LEFT] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=Y0,,0+YSIZE-1,,0
14m0001 11076 640700014035044010000000	        D[CONST 1] ROT[18.] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=Y0,,0+YSIZE,,0
14m0001                               	        D[10 + YMAX,,YMIN] SPEC[LEFT] ALU[D-Q]
14m0001 11077 451140054537000000200000	                COND[OBUS<0] JUMP[VIDCHS] C600 $
14m0001                               	                ;if YMAX,,0-(Y0+YSIZE),,0<0 skip
14m0001                               	
14m0001                               	;This is the scan line loop for characters.
14m0001                               	
14m0001                               	;Put up first word of this line for this character.
14m0001 11100 640700044171000220000000	VIDCHL: D[10 + YSIZE-1,,FONTPTR] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=FONTPTR
14m0001 11101 640720044435044220000000	        D[10 + YSIZE-1,,FONTPTR] ROT[18.] MASK[18.] ALU[D+Q] DEST[MA] NORM $
14m0001                               	                ;MA=FONTPTR+YSIZE-1     read DATA
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

14m0001 11102 640700014171000410000000	        D[CONST 33.] DEST[Q] NORM $
14m0001                               	                ;Q=33.
14m0001 11103 640701240477000220000000	        D[10 + WORD,,PIXEL3] MASK[18.] ALU[Q-D] DEST[ROTR] NORM $
14m0001                               	                ;ROTR=33.-PIXEL3
14m0001 11104 640701440477000220000000	        D[10 + WORD,,PIXEL3] MASK[18.] ALU[Q-D] DEST[MASKR] NORM $
14m0001                               	                ;MASKR=33.-PIXEL3
14m0001 11105 640044404571201000000000	        D[MEM] ROT[R] MASK[R] DEST[HOLD] PUSHJ[VIDPUT] NORM $
14m0001                               	                ;HOLD=DATA ROT (33.-PIXEL) MASK (33.-PIXEL)     do it
14m0001                               	
14m0001                               	;Determine if there is another word.
14m0001 11106 240700040171000220070000	        MAPF[7] D[10 + WORD,,PIXEL3] MASK[18.] DEST[Q] C800 $
14m0001                               	                ;Q=PIXEL3       VWEVID
14m0001 11107 640700064035044220000000	        D[10 + XSIZE3,,XSIZE] ROT[18.] MASK[18.] ALU[D+Q] DEST[Q] NORM $
14m0001                               	                ;Q=PIXEL3+XSIZE3
14m0001                               	        D[CONST 33.] ALU[D-Q]
14m0001 11110 471140014537000410000000	                COND[-OBUS<0] JUMP[VIDCHS] C600 $
14m0001                               	                ;If 33.-(PIXEL3+XSIZE3)<0
14m0001                               	
14m0001                               	;If there is a second word, put it up.
14m0001 11111 640700040171000440000000	        D[10 + WORD,,PIXEL3] DEST[Q] NORM $
14m0001                               	                ;Q=WORD,,PIXEL
14m0001 11112 640700014435044013000000	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[WORD,,PIXEL3] DEST-A-MEM NORM $
14m0001                               	                ;Temporarally increment WORD
14m0001 11113 640720024571000440000000	        D[MA] DEST[MA] NORM $
14m0001                               	                ;Read line of data again. (Not enough state.)
14m0001 11114 640700014171000360000000	        D[CONST 30.] DEST[Q] NORM $
14m0001                               	                ;Q=30.
14m0001 11115 640701240477000220000000	        D[10 + WORD,,PIXEL3] MASK[18.] ALU[Q-D] DEST[ROTR] NORM $
14m0001                               	                ;ROTR=30.-PIXEL3
14m0001 11116 640710004571200410000000	        D[MEM] ROT[R] MASK[33.] DEST[AR] NORM $
14m0001                               	                ;AR=DATA ROT (30.-PIXEL3) MASK 33.
14m0001 11117 640700014171002410000000	        D[CONST 33.] ROT[1] DEST[Q] NORM $
14m0001                               	                ;Q=66.
14m0001 11120 640700040077000220000000	        D[10 + WORD,,PIXEL3] MASK[18.] ALU[Q-D] DEST[Q] NORM $
14m0001                               	                ;Q=66.-PIXEL3
14m0001 11121 640701464477044220000000	        D[10 + XSIZE3,,XSIZE] ROT[18.] MASK[18.] ALU[Q-D] DEST[MASKR] NORM $
14m0001                               	                ;ROTR=66.-PIXEL3-XSIZE3
14m0001 11122 640700000171000440000000	        D[AR] DEST[Q] NORM $
14m0001                               	                ;Q=DATA ROT(30.-PIXEL3) MASK(33.)
14m0001 11123 640044400675001000000000	        D[MASK R] ALU[-D&Q] DEST[HOLD] PUSHJ[VIDPUT] NORM $
14m0001                               	                ;HOLD=DATA ROT(30.-PIXEL3) MASK(66.-PIXEL3-XSIZE3)
14m0001 11124 640700040171000440070000	        MAPF[7] D[10 + WORD,,PIXEL3] DEST[Q] NORM $
14m0001                               	                ;Q=WORD,,PIXEL          VWEVID
14m0001 11125 640700014477044013000000	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[WORD,,PIXEL3] DEST-A-MEM NORM $
14m0001                               	                ;Redecrement WORD
14m0001                               	
14m0001                               	;Check for last scan line of character (also interrupts).
14m0001 11126 240700044171000440070000	VIDCHS: MAPF[7] D[10 + YSIZE-1,,FONTPTR] DEST[Q] C800 $
14m0001                               	                ;Q=YSIZE-1,,FONTPTR     VWEVID
14m0001                               	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[YSIZE-1,,FONTPTR] DEST-A-MEM
14m0001 11127 451140214477044013000000	                COND[OBUS<0] JUMP[VIDCHE] C600 $
14m0001                               	                ;If YSIZE-1<0, done
14m0001 11130 661140000571000440001100	        COND[-INTRPT] JUMP[VIDCHL] NORM $
14m0001                               	                ;If no interrupt, loop
14m0001                               	        VIDSAV[VIDCHL]
14m0001                               	
14m0001 11131 640700014171030010000000	[       D[CONST (VIDCHL / 10000)] ROT[12.] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

14m0001                               	                ;Q=high bit (SDISP loads all 16 bits)
14m0001 11132 640700014175014110000000	        D[CONST (77 & (VIDCHL / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
14m0001                               	                ;Q=next 6 ADR bits
14m0001 11133 640704414575000000000000	        D[CONST (VIDCHL \ 100)] ALU[QORD] DEST[HOLD] NORM $
14m0001                               	                ;Q=SAVE ADR
14m0001 11134 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0001                               	                ;Q=POGB
14m0001 11135 640164014435000720000650	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
14m0001                               	                ;MA=POGB+58     write SAVE ADR
14m0002                               	]               ;Interrupt
14m0002                               	
14m0002                               	;Increment position one character width (right or down).
14m0002 11136 640700074171000220000000	VIDCHE: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
14m0002                               	                ;Q=POGB
14m0002 11137 640720014435000600000000	        D[CONST 48.] ALU[Q+D] DEST[MA] NORM $
14m0002                               	                ;MA=POGB+48.    read last font
14m0002 11140 640700000571000440000000	        NORM $
14m0002                               	                ;WAIT
14m0002 11141 640720004571000220000000	        D[MEM] MASK[18.] DEST[MA] NORM $
14m0002                               	                ;MA=LAST FONT   read YSIZE,,XSIZE
14m0002 11142 640700000571000440000000	        NORM $
14m0002                               	                ;WAIT
14m0002 11143 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
14m0002                               	                ;Q=YSIZE,,0
14m0002                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[Q-D]
14m0002 11144 451140004477044000200000	                COND[OBUS<0] JUMP[VIDCE2] C600 $
14m0002                               	                ;If YSIZE-XSIZE<0, sideways
14m0002                               	
14m0002 11145 640700064171000000200000	        D[10 + XSIZE3,,XSIZE] SPEC[LEFT] DEST[Q] NORM $
14m0002                               	                ;Q=XSIZE3,,0
14m0002 11146 640700040035044000200000	        D[10 + WORD,,PIXEL3] ROT[18.] SPEC[LEFT] ALU[Q+D] DEST[Q] NORM $
14m0002                               	                ;Q=PIXEL3+XSIZE3,,0
14m0002                               	        D[CONST 33.] ROT[18.] ALU[Q-D]
14m0002 11147 451140014477044410000000	                COND[OBUS<0] JUMP[VIDCE1] C600 $
14m0002                               	                ;If PIXEL3+XSIZE3-33.<0 skip
14m0002 11150 640700014077044410000000	        D[CONST 33.] ROT[18.] ALU[Q-D] DEST[Q] NORM $
14m0002                               	                ;Q=PIXEL3+XSIZE3-33.,,0
14m0002 11151 640700000017000440000000	        ALU[Q+1] DEST[Q] NORM $
14m0002                               	                ;Q=PIXEL3+XSIZE3-33.,,1
14m0002 11152 640710000555000440000000	VIDCE1: ALU[Q] DEST[AR] NORM $
14m0002                               	                ;AR=NEW PIXEL3,,WORD OFFSET
14m0002 11153 640700040171000000200000	        D[10 + WORD,,PIXEL3] SPEC[LEFT] DEST[Q] NORM $
14m0002                               	                ;Q=WORD,,0
14m0002                               	        D[AR] ROT[18.] ALU[D+Q] DEST[WORD,,PIXEL3] DEST-A-MEM
14m0002 11154 640140000435044443000000	                JUMP[VIDSCN] NORM $
14m0002                               	                ;WORD,,PIXEL3=WORD+OFFSET,,NEW PIXEL3
14m0002                               	
14m0002 11155 640700070171000440000000	VIDCE2: D[10 + LINE,,BYTEPTR] DEST[Q] NORM $
14m0002                               	                ;Q=LINE,,BYTEPTR
14m0002 11156 640700004077000000200000	        D[MEM] SPEC[LEFT] ALU[Q-D] DEST[Q] NORM $
14m0002                               	                ;Q=LINE-YSIZE,,BYTEPTR
14m0002 11157 640701400555000443000000	        ALU[Q] DEST[LINE,,BYTEPTR] DEST-A-MEM NORM $
14m0002                               	                ;LINE-YSIZE,,BYTEPTR
14m0002                               	        
14m0002                               	
14m0002                               	;Increment byte pointer for next character.
14m0002 11160 640700070171000440000000	VIDSCN: D[10 + LINE,,BYTEPTR] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

14m0002                               	                ;Q=LINE,,BYTEPTR
14m0002 11161 640711414435000073000000	        D[CONST 7] ALU[Q+D] DEST[AR LINE,,BYTEPTR] DEST-A-MEM NORM $
14m0002                               	                ;AR,LINE,,BYTEPTR=LINE,,BYTEPTR+7
14m0002 11162 640700000171044000200000	        D[AR] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
14m0002                               	                ;Q=BYTEPTR+7,,0
14m0002                               	        D[CONST 36.] ROT[18.] ALU[D-Q]
14m0002 11163 471140014537044440001013	                COND[-OBUS<0] JUMP[VIDSCL] C600 $
14m0002                               	                ;If 36.,,0-BYTEPTR+7,,0<0
14m0002 11164 640140000571000440000636	        JUMP[VIDDON] NORM $
14m0002                               	                ;Done
14m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

15m0002                               	;Divide by 33. (Efficient till 2048./33.)
15m0002                               	
15m0002                               	;AR=DIVIDEND
15m0002                               	
15m0002 11165 640704400171076370000000	VIDD33: D[AR] ROT[36. - 5] MASK[36. - 5] DEST[Q HOLD] NORM $
15m0002                               	                ;Q,HOLD=QUOTIENT=AR/32.
15m0002 11166 640700004035012440000000	VID33L: D[MEM] ROT[5] ALU[D+Q] DEST[Q] NORM $
15m0002                               	                ;Q=33*QUOTIENT
15m0002                               	        D[AR] ALU[D-Q] DEST[Q]
15m0002 11167 471300000137000440000000	                COND[-OBUS<0] POPJ C600 $
15m0002                               	                ;Q=REMAINDER, if < 0
15m0002 11170 640144404131000440001166	        D[MEM] ALU[D-1] DEST[Q HOLD] JUMP[VID33L] NORM $
15m0002                               	                ;Q,HOLD=QUOTIENT-1      loop
15m0002                               	
15m0002                               	;MEM=QUOTIENT
15m0002                               	;Q=REMAINDER
15m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

16m0002                               	;Put up one word of video
16m0002                               	
16m0002                               	;MEM=DATA
16m0002                               	
16m0002 11171 640700070171044220000000	VIDPUT: D[10 + LINE,,BYTEPTR] ROT[18.] MASK[18.] DEST[Q] NORM $
16m0002                               	                ;Q=0,,LINE
16m0002 11172 640710044477044220000000	        D[10 + YSIZE-1,,FONTPTR] ROT[18.] MASK[18.] ALU[Q-D] DEST[AR] NORM $
16m0002                               	                ;AR=0,,LINE-(YSIZE-1)
16m0002 11173 640700000171012440000000	        D[AR] ROT[5] DEST[Q] NORM $
16m0002                               	                ;Q=0 LINE 00000
16m0002 11174 640700014275012010000000	        D[CONST 1] ROT[5] ALU[-D&Q] DEST[Q] NORM $
16m0002                               	                ;Q=0 LINE/2 000000
16m0002                               	        D[AR] ROT[36. - 1]
16m0002 11175 531140000571106440000000	                COND[-OBUS<0] JUMP[VIDPT1] C550 $
16m0002                               	                ;IF LSB[LINE]=1
16m0002 11176 640700014175034010000000	        D[CONST 1] ROT[14.] ALU[QORD] DEST[Q] NORM $
16m0002                               	                ;Q=ODD[LINE] LINE/2 000000
16m0002 11177 640700040175044060000000	VIDPT1: D[10 + WORD,,PIXEL3] ROT[18.] MASK[6] ALU[QORD] DEST[Q] NORM $
16m0002                               	                ;Q=ODD[LINE] LINE/2 WORD (=interlaced address)
16m0002                               	
16m0002 11200 640700014035014070000000	        D[CONST 7] ROT[6] ALU[Q+D] DEST[Q] NORM $
16m0002                               	                ;Q=ADR+7*64.
16m0002 11201 640702214435000063600000	        D[CONST 6] ALU[Q+D] DEST[IOD] START-OUT NORM $
16m0002                               	                ;IOD=ADR+7 lines, 6 words
16m0002                               	
16m0002 11202 240700004171000410020000	        MAPF[2] D[MEM] MASK[33.] DEST[Q] C800 $
16m0002                               	                ;VLDADR Q=DATA
16m0002 11203 240700000571000440000000	        C800 $
16m0002                               	                ;WAIT
16m0002 11204 240702260735000443600000	        D[10 + COLOR] ALU[D#Q] DEST[IOD] START-OUT C800 $
16m0002                               	                ;IOD=DATA XOR COLOR
16m0002 11205 240300000571000443410000	        MAPF[1] START-IN POPJ C800 $
16m0002                               	                ;VLDDAT (next line must have MAPF[7] ... C800)
16m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

17m0002                               	;Vector A-MEM:
17m0002                               	
17m0002       0	        PIXEL,,FRACT    = 0
17m0002       1	        INTEN,,FRACT    = 1
17m0002       2	        XMAX,,XMIN      = 2
17m0002       3	        YMAX,,YMIN      = 3
17m0002       4	        DXDY,,FRACT     = 4
17m0002       5	        A3DYDX,,FRACT   = 5
17m0002       6	        OFFSET,,LINE    = 6
17m0002       7	        POG,,POGB       = 7
17m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

18m0002                               	;Paint line left
18m0002                               	.DEFINE VIDLFT[]
18m0002                               	[       D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
18m0002                               	                ;Q=0,,LINE
18m0002                               	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
18m0002                               	                ;OFFSET,,LINE=0,,LINE
18m0002                               	
18m0002                               	        PUSHJ[VIDDT1] NORM $
18m0002                               	                ;Do it
18m0002                               	
18m0002                               	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
18m0002                               	                ;Q=INTEN,,FRACT         VWEVID
18m0002                               	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
18m0002                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
18m0002                               	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
18m0002                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
18m0002                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
18m0002                               	                COND[OBUS<0] JUMP[. + 9] C600 $
18m0002                               	                ;If INTEN,,FRACT-0,,377777<0, done.
18m0002                               	
18m0002                               	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
18m0002                               	                ;Q=OFFSET,,LINE
18m0002                               	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
18m0002                               	                ;OFFSET-1,,LINE
18m0002                               	
18m0002                               	        COND[-INTRPT] JUMP[. - 7] NORM $
18m0002                               	                ;Loop if no interrupt
18m0002                               	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
18m0002                               	        VIDSAV[%VIDFOO]         ;       THE MACRO GETS ITS ARGUMENT.
18m0002                               	                ;Interrupt
18m0002                               	]
18m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

19m0002                               	;Paint line right
19m0002                               	.DEFINE VIDRGT[]
19m0002                               	[       D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
19m0002                               	                ;Q=0,,LINE
19m0002                               	        D[CONST 1] ROT[18.] ALU[QORD] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
19m0002                               	                ;OFFSET,,LINE=1,,LINE
19m0002                               	
19m0002                               	        PUSHJ[VIDDT1] NORM $
19m0002                               	                ;Do it (loop to here)
19m0002                               	
19m0002                               	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
19m0002                               	                ;Q=INTEN,,FRACT         VWEVID
19m0002                               	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
19m0002                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
19m0002                               	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
19m0002                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
19m0002                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
19m0002                               	                COND[OBUS<0] JUMP[. + 9] C600 $
19m0002                               	                ;If INTEN,,FRACT-0,,377777<0, done.
19m0002                               	
19m0002                               	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
19m0002                               	                ;Q=OFFSET,,LINE
19m0002                               	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
19m0002                               	                ;OFFSET+1,,LINE
19m0002                               	
19m0002                               	        COND[-INTRPT] JUMP[. - 7] NORM $
19m0002                               	                ;Loop if no interrupt
19m0002                               	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
19m0002                               	        VIDSAV[%VIDFOO]         ;       THE MACRO GETS ITS ARGUMENT.
19m0002                               	                ;Interrupt
19m0002                               	]
19m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

20m0002                               	;Vector Body
20m0002                               	;Extract X field from vector word (extending sign).
20m0002 11206 640710014531016010000000	VIDVCI: D[CONST 1] ROT[7] ALU[D-1] DEST[AR] NORM $
20m0002                               	                ;AR=177
20m0002 11207 640700044171026130000000	        D[10 + INTEN,,FRACT] ROT[11.] MASK[11.] DEST[Q] NORM $
20m0002                               	                ;Q=X
20m0002                               	        D[CONST 1] ROT[10.] ALU[D&Q]
20m0002 11210 510140014635024010000000	                COND[OBUS=0] JUMP[VIDVC1] C550 $
20m0002                               	                ;IF SIGN=1
20m0002 11211 640700000175026440000000	        D[AR] ROT[11.] ALU[DORQ] DEST[Q] NORM $
20m0002                               	                ;Q=0,,774 X
20m0002 11212 640700400555000443000000	VIDVC1: ALU[Q] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
20m0002                               	                ;XMAX,,XMIN=0,,X
20m0002                               	
20m0002                               	;Extract Y field from vector word (extending sign).
20m0002 11213 640700044171054130000000	        D[10 + INTEN,,FRACT] ROT[22.] MASK[11.] DEST[Q] NORM $
20m0002                               	                ;Q=Y
20m0002                               	        D[CONST 1] ROT[10.] ALU[D&Q]
20m0002 11214 510140014635024010000000	                COND[OBUS=0] JUMP[VIDVC2] C550 $
20m0002                               	                ;IF SIGN=1
20m0002 11215 640700000175026440000000	        D[AR] ROT[11.] ALU[DORQ] DEST[Q] NORM $
20m0002                               	                ;Q=0,,774 Y
20m0002 11216 640700600555000443000000	VIDVC2: ALU[Q] DEST[YMAX,,YMIN] DEST-A-MEM NORM $
20m0002                               	                ;YMAX,,YMIN=0,,Y
20m0002                               	
20m0002                               	;Get default color (0=no change).
20m0002                               	        D[10 + INTEN,,FRACT] ROT[25.] MASK[3] DEST[AR]
20m0002 11217 510150044571062030000000	                COND[OBUS=0] JUMP[VIDVC3] C550 $
20m0002                               	                ;AR=BRT (color)         if=0, no change
20m0002 11220 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11221 640720014435000600000000	        D[CONST 48.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+48.    read LAST COLOR,,LAST FONT
20m0002 11222 640700000171102440000000	        D[AR] ROT[33.] DEST[Q] NORM $
20m0002                               	                ;Q=COLOR 00000,,000000
20m0002 11223 640704204575000220000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=COLOR 00000,,LAST FONT    write LAST COLOR,,LAST FONT
20m0002                               	
20m0002                               	;Get default font (0=no change).
20m0002                               	VIDVC3: D[10 + INTEN,,FRACT] ROT[28.] MASK[3]
20m0002 11224 510140044571070030000000	                COND[OBUS=0] JUMP[VIDVC4] C550 $
20m0002                               	                ;if SIZE(FONT)=0, no change
20m0002 11225 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11226 640720014035000600000000	        D[CONST 48.] ALU[D+Q] DEST[Q MA] NORM $
20m0002                               	                ;Q,MA=POGB+48   read LAST COLOR,,LAST FONT
20m0002 11227 640700000571000440000000	        NORM $
20m0002                               	                ;WAIT
20m0002 11230 640710004571000000200000	        D[MEM] SPEC[LEFT] DEST[AR] NORM $
20m0002                               	                ;AR=COLOR,,0
20m0002 11231 640720044435070030000000	        D[10 + INTEN,,FRACT] ROT[28.] MASK[3] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+48.+SIZE
20m0002 11232 640700000171000440000000	        D[AR] DEST[Q] NORM $
20m0002                               	                ;Q=COLOR,,0
20m0002 11233 640704204575000220000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=COLOR,,FONT       write LAST COLOR,,LAST FONT
20m0002                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

20m0002                               	;Check relative.
20m0002                               	VIDVC4: D[10 + INTEN,,FRACT] ROT[29.]
20m0002 11234 511140044571072440000000	                COND[OBUS<0] JUMP[VIDVC5] C550 $
20m0002                               	                ;if relative
20m0002                               	
20m0002                               	;If relative, add previous X coordinate.
20m0002 11235 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11236 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+61.    read X0,,X1
20m0002 11237 640700050171000440000000	        D[10 + XMAX,,XMIN] DEST[Q] NORM $
20m0002                               	                ;Q=0,,X
20m0002 11240 640710004435000220000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[AR] NORM $
20m0002                               	                ;AR=0,,X+X1
20m0002 11241 640700004171044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=X1,,0
20m0002 11242 640704200575000440000000	        D[AR] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=X1,,X+X1  write X0,,X1
20m0002                               	
20m0002                               	;If relative, add previous Y coordinate.
20m0002 11243 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+62.    read Y0,,Y1
20m0002 11244 640700054171000440000000	        D[10 + YMAX,,YMIN] DEST[Q] NORM $
20m0002                               	                ;Q=0,,Y
20m0002 11245 640710004435000220000000	        D[MEM] MASK[18.] ALU[D+Q] DEST[AR] NORM $
20m0002                               	                ;AR=0,,Y+Y1
20m0002 11246 640700004171044000200000	        D[MEM] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=Y1,,0
20m0002 11247 640144200575000440000000	        D[AR] ALU[DORQ] DEST[MEMSTO] JUMP[VIDVC6] NORM $
20m0002                               	                ;HOLD=Y1,,Y+Y1  write Y0,,Y1
20m0002                               	
20m0002                               	;If absolute,just copy X
20m0002 11250 640700074171000220000000	VIDVC5: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11251 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+61.    read X0,,X1
20m0002 11252 640700050171000440000000	        D[10 + XMAX,,XMIN] DEST[Q] NORM $
20m0002                               	                ;Q=0,,X
20m0002 11253 640704204575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=X1,,X     write X0,,X1
20m0002                               	
20m0002                               	;If absolute, just copy Y
20m0002 11254 640720024433000440000000	        D[MA] ALU[D+1] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+62.    read Y0,,Y1
20m0002 11255 640700054171000440000000	        D[10 + YMAX,,YMIN] DEST[Q] NORM $
20m0002                               	                ;Q=0,,Y
20m0002 11256 640704204575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] NORM $
20m0002                               	                ;HOLD=Y1,,Y     write Y0,,Y1
20m0002                               	
20m0002                               	;Check type code. If 0, visible vector. (For now, all others invisible.)
20m0002                               	VIDVC6: D[10 + INTEN,,FRACT] ROT[32.] MASK[2]
20m0002 11257 530140044571100020000636	                COND[-OBUS=0] JUMP[VIDDON] C550 $
20m0002                               	                ;If T NEQ 0, done
20m0002                               	
20m0002                               	;Check first half done.
20m0002                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q]
20m0002 11260 656140074171000220000000	                COND[HALF] JUMP[VIDVCH] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

20m0002                               	                ;Q=POGB         If -HALF
20m0002                               	
20m0002                               	;If first half not done, color=background 77777,,777777
20m0002 11261 640720074435044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+POG    read BACKGROUND
20m0002 11262 640700014131102010000000	        D[CONST 1] ROT[33.] ALU[D-1] DEST[Q] NORM $
20m0002                               	                ;Q=077777,,777777
20m0002                               	.REPEAT VIC2 [
20m0002                               	        D[MEM] ALU[DORQ] DEST[IOD] START-OUT JUMP[VIDVI0] NORM $
20m0002                               	                ;IOD=BACKGROUND 77777,,777777
20m0002                               	];VIC2
20m0002                               	.REPEAT 1 - VIC2 [
20m0002                               	        D[MEM] ALU[DORQ] DEST[HOLD] NORM $
20m0002                               	                ;MEM=BACKGROUND 77777,,777777
20m0002                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002                               	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDVI0] NORM $
20m0002                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
20m0002                               	];[
20m0002 11263 640704404575000440000000	        D[MEM] ALU[DORQ] DEST[HOLD] NORM $
20m0002                               	                ;MEM=BACKGROUND 77777,,777777
20m0002 11264 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11265 640164014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDVI0] NORM $
20m0002                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
20m0002                               	]1-VIC2
20m0002                               	
20m0002                               	;If first half done, color=default color 00000,,000000
20m0002 11266 640720014435000600000000	VIDVCH: D[CONST 48.] ALU[Q+D] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+48.    read LAST COLOR
20m0002 11267 640710014531102010000000	        D[CONST 1] ROT[33.] ALU[D-1] DEST[AR] NORM $
20m0002                               	                ;AR=077777,,777777
20m0002 11270 640700004171000440000000	        D[MEM] DEST[Q] NORM $
20m0002                               	                ;Q=LAST COLOR,,LAST FONT
20m0002                               	.REPEAT VIC2 [
20m0002                               	        D[AR] ALU[-D&Q] DEST[IOD] START-OUT NORM $
20m0002                               	                ;IOD=LAST COLOR 00000,,000000
20m0002                               	];VIC2
20m0002                               	.REPEAT 1 - VIC2 [
20m0002                               	        D[AR] ALU[-D&Q] DEST[HOLD] NORM $
20m0002                               	                ;MEM=LAST COLOR 00000,,000000
20m0002                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002                               	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
20m0002                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
20m0002                               	        NORM $
20m0002                               	                ;WAIT
20m0002                               	];[
20m0002 11271 640704400675000440000000	        D[AR] ALU[-D&Q] DEST[HOLD] NORM $
20m0002                               	                ;MEM=LAST COLOR 00000,,000000
20m0002 11272 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11273 640724014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
20m0002                               	                ;MA=POGB+59     write <COLOR MASK,,MASK>
20m0002 11274 640700000571000440000000	        NORM $
20m0002                               	                ;WAIT
20m0002                               	]1-VIC2
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

20m0002                               	
20m0002                               	;Save X0,,X1 and form XMAX,,XMIN.
20m0002 11275 240700074171000440100000	VIDVI0: MAPF[10] D[10 + POG,,POGB] DEST[Q] C800 $
20m0002                               	                ;VLDCOL         Q=POGB
20m0002 11276 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+61.    read X0,,X1
20m0002 11277 640700000571000440000000	        NORM $
20m0002                               	                ;WAIT FOR MEM
20m0002 11300 640700404171000443000000	        D[MEM] DEST[Q XMAX,,XMIN] DEST-A-MEM NORM $
20m0002                               	                ;Q,XMAX,,XMIN=X0,,X1
20m0002 11301 640701004571000443000000	        D[MEM] DEST[DXDY,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;DXDY,,FRACT=X0,,X1     (for use below)
20m0002                               	        D[MEM] ROT[18.] ALU[Q-D]
20m0002 11302 471140004477044440000000	                COND[-OBUS<0] JUMP[VIDVI1] C600 $
20m0002                               	                ;If X0,,X1-X1,,X0<0
20m0002 11303 640700404571044443000000	        D[MEM] ROT[18.] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
20m0002                               	                ;XMAX,,XMIN=X1,,X0
20m0002                               	
20m0002                               	;Save Y0,,Y1 and form YMAX,,YMIN.
20m0002 11304 640700074171000440000000	VIDVI1: D[10 + POG,,POGB] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11305 640720014435000760000000	        D[CONST 62.] ALU[D+Q] DEST[MA] NORM $
20m0002                               	                ;MA=POGB+62.    read Y0,,Y1
20m0002 11306 640700000571000440000000	        NORM $
20m0002                               	                ;WAIT FOR MEM
20m0002 11307 640700604171000443000000	        D[MEM] DEST[Q YMAX,,YMIN] DEST-A-MEM NORM $
20m0002                               	                ;Q,YMAX,,YMIN=Y0,,Y1
20m0002 11310 640701204571000443000000	        D[MEM] DEST[A3DYDX,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;A3DYDX,,FRACT=Y0,,Y1   (for use below)
20m0002                               	        D[MEM] ROT[18.] ALU[Q-D]
20m0002 11311 471140004477044440000000	                COND[-OBUS<0] JUMP[VIDVI2] C600 $
20m0002                               	                ;If Y0,,Y1-Y1,,Y0<0
20m0002 11312 640700604571044443000000	        D[MEM] ROT[18.] DEST[YMAX,,YMIN] DEST-A-MEM NORM $
20m0002                               	                ;YMAX,,YMIN=Y1,,Y0
20m0002                               	
20m0002                               	;Form delta X. Check for vertical vectors.
20m0002 11313 640700060171044000200000	VIDVI2: D[10 + DXDY,,FRACT] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=X1,,0
20m0002 11314 640700060077000000200000	        D[10 + DXDY,,FRACT] SPEC[LEFT] ALU[Q-D] DEST[Q] NORM $
20m0002                               	                ;Q=DX,,0=X1,,0-X0,,0
20m0002                               	        ALU[Q] DEST[DXDY,,FRACT] DEST-A-MEM
20m0002 11315 510141000555000443000000	                COND[OBUS=0] JUMP[VIDVRV] C550 $
20m0002                               	                ;DXDY,,FRACT=DX,,0 (for use below)
20m0002                               	                ;If DX=0, vertical vector
20m0002                               	
20m0002                               	;Form delta Y. Check for horizontal vectors.
20m0002 11316 640700064171044000200000	        D[10 + A3DYDX,,FRACT] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=Y1,,0
20m0002 11317 640700064077000000200000	        D[10 + A3DYDX,,FRACT] SPEC[LEFT] ALU[Q-D] DEST[Q] NORM $
20m0002                               	                ;Q=DY,,0=Y1,,0-Y0,,0
20m0002                               	        ALU[Q] DEST[A3DYDX,,FRACT] DEST-A-MEM
20m0002 11320 510141200555000443000000	                COND[OBUS=0] JUMP[VIDHZV] C550 $
20m0002                               	                ;A3DYDX,,FRACT=DY,,0 (for use below)
20m0002                               	                ;If DY=0, horizontal vector
20m0002                               	
20m0002                               	;Form DXDY and A3DYDX.
20m0002 11321 640710060571000440000000	        D[10 + DXDY,,FRACT] DEST[AR] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

20m0002                               	                ;AR=DIVIDEND=DX,,0
20m0002 11322 640044464571000440000000	        D[10 + A3DYDX,,FRACT] DEST[HOLD] PUSHJ[VIDDIV] NORM $
20m0002                               	                ;HOLD=DIVISOR=DY,,0     divide
20m0002 11323 640710000555000440000000	        ALU[Q] DEST[AR] NORM $
20m0002                               	                ;AR=DX/DY,,FRACT (abs val)
20m0002 11324 640700060171000440000000	        D[10 + DXDY,,FRACT] DEST[Q] NORM $
20m0002                               	                ;Q=DX
20m0002                               	        D[10 + A3DYDX,,FRACT] ALU[D#Q]
20m0002 11325 531140064735000440000000	                COND[-OBUS<0] JUMP[VIDVI3] C550 $
20m0002                               	                ;IF DX XOR DY < 0
20m0002 11326 640710000473000440000000	        D[AR] ALU[0-D] DEST[AR] NORM $
20m0002                               	                ;AR=-DX/DY (correct sign)
20m0002 11327 640704460571000440000000	VIDVI3: D[10 + DXDY,,FRACT] DEST[HOLD] NORM $
20m0002                               	                ;HOLD=DIVISOR=DX
20m0002 11330 640701000571000443000000	        D[AR] DEST[DXDY,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;DXDY,,FRACT=DX/DY,,FRACT
20m0002 11331 640050064571000440000000	        D[10 + A3DYDX,,FRACT] DEST[AR] PUSHJ[VIDDIV] NORM $
20m0002                               	                ;AR=DIVIDEND=DY         divide
20m0002 11332 640710000555000440000000	        ALU[Q] DEST[AR] NORM $
20m0002                               	                ;AR=DY/DX,,FRACT        (abs val)
20m0002 11333 640701200435002443000000	        D[AR] ROT[1] ALU[Q+D] DEST[A3DYDX,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;A3DYDX=3*ABS[DY/DX]
20m0002                               	
20m0002                               	;Initialize OFFSET,,LINE.
20m0002 11334 640700054171000220000000	        D[10 + YMAX,,YMIN] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=0,,YMIN
20m0002 11335 640701400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0002                               	                ;OFFSET,,LINE=0,,YMIN
20m0002                               	
20m0002                               	;Initialize PIXEL,,FRACT and form boundary limits from POG windows.
20m0002 11336 640700050171044000200000	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=XMIN,,0
20m0002                               	        D[10 + DXDY,,FRACT]
20m0002 11337 531140060571000440000000	                COND[-OBUS<0] JUMP[VIDVI4] C550 $
20m0002                               	                ;If slope negative
20m0002 11340 640700050171000000200000	        D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=XMAX,,0
20m0002 11341 640040000555000443000000	VIDVI4: ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM PUSHJ[VIDVLM] NORM $
20m0002                               	                ;PIXEL,,FRACT=Q         form boundary limits
20m0002                               	
20m0002                               	;Check to see what side of 45 degrees vector's slope is.
20m0002 11342 640700064171000440000000	        D[10 + A3DYDX,,FRACT] DEST[Q] NORM $
20m0002                               	                ;Q=A3DYDX,,FRACT
20m0002                               	        D[CONST 3] ROT[18.] ALU[Q-D]
20m0002 11343 451140014477044030000000	                COND[OBUS<0] JUMP[VIDLL2] C600 $
20m0002                               	                ;If A3DYDX,,FRACT-3,,0<0, other case
20m0002                               	
20m0002                               	;This is the loop for painting 1 line of vectors whose slope is between
20m0002                               	;45 degrees (inclusive) and vertical (exclusive).
20m0002                               	
20m0002                               	;Check for above window.
20m0002 11344 640700054171044000200000	VIDLL1: D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0002                               	                ;Q=YMIN,,0
20m0002                               	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] ALU[D-Q]
20m0002 11345 451140070537044000200000	                COND[OBUS<0] JUMP[VIDSL1] C600 $
20m0002                               	                ;If LINE,,0-YMIN,,0<0, skip line
20m0002                               	;Paint left.
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

20m0002 11346 640700040171000220000000	        D[10 + PIXEL,,FRACT] MASK[18.] ALU[D] DEST[Q] NORM $
20m0002                               	                ;Q=0,,FRACT(PIXEL)
20m0002 11347 640710014137044010000000	        D[CONST 1] ROT[18.] ALU[D-Q] DEST[Q AR] NORM $
20m0002                               	                ;Q,AR=1,,0-0,,FRACT(PIXEL)
20m0002 11350 640700200435002443000000	        D[AR] ROT[1] ALU[D+Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;INTEN,,FRACT=3*(1,,0-0,,FRACT(PIXEL))
20m0002                               	
20m0002                               	        VIDLFT
20m0002                               	
20m0002 11351 640700070171000220000000	[       D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=0,,LINE
20m0002 11352 640701400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0002                               	                ;OFFSET,,LINE=0,,LINE
20m0002                               	
20m0002 11353 640040000571000440000000	        PUSHJ[VIDDT1] NORM $
20m0002                               	                ;Do it
20m0002                               	
20m0002 11354 240700044171000440070000	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
20m0002                               	                ;Q=INTEN,,FRACT         VWEVID
20m0002 11355 640700064077000440000000	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
20m0002                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
20m0002 11356 640700200555000443000000	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0002                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
20m0002                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
20m0002 11357 451140014475036040001370	                COND[OBUS<0] JUMP[. + 9] C600 $
20m0002                               	                ;If INTEN,,FRACT-0,,377777<0, done.
20m0002                               	
20m0002 11360 640700070171000440000000	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
20m0002                               	                ;Q=OFFSET,,LINE
20m0002 11361 640701414477044013000000	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0002                               	                ;OFFSET-1,,LINE
20m0002                               	
20m0002 11362 661140000571000440001353	        COND[-INTRPT] JUMP[. - 7] NORM $
20m0002                               	                ;Loop if no interrupt
20m0002       11353	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
20m0002                               	        VIDSAV[%VIDFOO] 
20m0002 11363 640700014171030010000000	[       D[CONST (%VIDFOO / 10000)] ROT[12.] DEST[Q] NORM $
20m0002                               	                ;Q=high bit (SDISP loads all 16 bits)
20m0002 11364 640700014175014130000000	        D[CONST (77 & (%VIDFOO / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
20m0002                               	                ;Q=next 6 ADR bits
20m0002 11365 640704414575000530000000	        D[CONST (%VIDFOO \ 100)] ALU[QORD] DEST[HOLD] NORM $
20m0002                               	                ;Q=SAVE ADR
20m0002 11366 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0002                               	                ;Q=POGB
20m0002 11367 640164014435000720000650	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
20m0002                               	                ;MA=POGB+58     write SAVE ADR
20m0002                               	]       ;       THE MACRO GETS ITS ARGUMENT.
20m0002                               	                ;Interrupt
20m0003                               	]
20m0003                               	;Paint right.
20m0003 11370 640710040171000220000000	        D[10 + PIXEL,,FRACT] MASK[18.] DEST[Q AR] NORM $
20m0003                               	                ;Q=0,,FRACT(PIXEL)
20m0003 11371 640700200435002443000000	        D[AR] ROT[1] ALU[D+Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0003                               	                ;INTEN,,FRACT=3*0,,FRACT(PIXEL)
20m0003                               	
20m0003                               	        VIDRGT
20m0003                               	
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

20m0003 11372 640700070171000220000000	[       D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0003                               	                ;Q=0,,LINE
20m0003 11373 640701414575044013000000	        D[CONST 1] ROT[18.] ALU[QORD] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0003                               	                ;OFFSET,,LINE=1,,LINE
20m0003                               	
20m0003 11374 640040000571000440000000	        PUSHJ[VIDDT1] NORM $
20m0003                               	                ;Do it (loop to here)
20m0003                               	
20m0003 11375 240700044171000440070000	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
20m0003                               	                ;Q=INTEN,,FRACT         VWEVID
20m0003 11376 640700064077000440000000	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
20m0003                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
20m0003 11377 640700200555000443000000	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0003                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
20m0003                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
20m0003 11400 451140014475036040001411	                COND[OBUS<0] JUMP[. + 9] C600 $
20m0003                               	                ;If INTEN,,FRACT-0,,377777<0, done.
20m0003                               	
20m0003 11401 640700070171000440000000	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
20m0003                               	                ;Q=OFFSET,,LINE
20m0003 11402 640701414435044013000000	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0003                               	                ;OFFSET+1,,LINE
20m0003                               	
20m0003 11403 661140000571000440001374	        COND[-INTRPT] JUMP[. - 7] NORM $
20m0003                               	                ;Loop if no interrupt
20m0003       11374	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
20m0003                               	        VIDSAV[%VIDFOO] 
20m0003 11404 640700014171030010000000	[       D[CONST (%VIDFOO / 10000)] ROT[12.] DEST[Q] NORM $
20m0003                               	                ;Q=high bit (SDISP loads all 16 bits)
20m0003 11405 640700014175014130000000	        D[CONST (77 & (%VIDFOO / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
20m0003                               	                ;Q=next 6 ADR bits
20m0003 11406 640704414575000740000000	        D[CONST (%VIDFOO \ 100)] ALU[QORD] DEST[HOLD] NORM $
20m0003                               	                ;Q=SAVE ADR
20m0003 11407 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0003                               	                ;Q=POGB
20m0003 11410 640164014435000720000650	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
20m0003                               	                ;MA=POGB+58     write SAVE ADR
20m0003                               	]       ;       THE MACRO GETS ITS ARGUMENT.
20m0003                               	                ;Interrupt
20m0004                               	]
20m0004                               	;Reset offset and increment line.
20m0004 11411 640700070171000220000000	VIDSL1: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0004                               	                ;Q=0,,LINE
20m0004 11412 640701400417000443000000	        ALU[Q+1] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0004                               	                ;OFFSET,,LINE=0,,LINE+1
20m0004                               	
20m0004                               	;Check for below window.
20m0004 11413 640700070171044000200000	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0004                               	                ;Q=LINE,,0
20m0004                               	        D[10 + YMAX,,YMIN] SPEC[LEFT] ALU[D-Q]
20m0004 11414 451140054537000000200000	                COND[OBUS<0] JUMP[VIDVEN] C600 $
20m0004                               	                ;If YMAX,,0-LINE,,0<0, terminate
20m0004                               	
20m0004                               	;Increment X position.
20m0004 11415 640700040171000440000000	        D[10 + PIXEL,,FRACT] DEST[Q] NORM $
20m0004                               	                ;Q=PIXEL,,FRACT
20m0004 11416 640700060035000440000000	        D[10 + DXDY,,FRACT] ALU[Q+D] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

20m0004                               	                ;Q=PIXEL,,FRACT+DXDY,,FRACT
20m0004 11417 640140000555000443001344	        ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM JUMP[VIDLL1] NORM $
20m0004                               	                ;PIXEL,,FRACT=PIXEL,,FRACT+DXDY,,FRACT  loop
20m0004                               	
20m0004                               	;This is the loop for vectors whose slope is between 45 degrees (exclusive)
20m0004                               	;and horizontal (exclusive).
20m0004                               	
20m0004                               	;Check for above window.
20m0004 11420 640700054171044000200000	VIDLL2: D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0004                               	                ;Q=YMIN,,0
20m0004                               	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] ALU[D-Q]
20m0004 11421 451140070537044000200000	                COND[OBUS<0] JUMP[VIDSL2] C600 $
20m0004                               	                ;If LINE,,0-YMIN,,0<0, skip line
20m0004                               	
20m0004                               	;Paint left.
20m0004                               	        D[10 + PIXEL,,FRACT] ROT[36. - 2] MASK[16.] DEST[Q]
20m0004 11422 640040040171104200000000	                PUSHJ[VIDMUL] NORM $
20m0004                               	                ;Q=MULTIPLIER(0,,00 16 BIT)     multiply
20m0004 11423 640700214537044033000000	        D[CONST 3] ROT[18.] ALU[D-Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0004                               	                ;INTEN,,FRACT=3,,0-0,,DELTA*A3DYDX,,FRACT
20m0004                               	
20m0004                               	        VIDLFT
20m0004                               	
20m0004 11424 640700070171000220000000	[       D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0004                               	                ;Q=0,,LINE
20m0004 11425 640701400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0004                               	                ;OFFSET,,LINE=0,,LINE
20m0004                               	
20m0004 11426 640040000571000440000000	        PUSHJ[VIDDT1] NORM $
20m0004                               	                ;Do it
20m0004                               	
20m0004 11427 240700044171000440070000	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
20m0004                               	                ;Q=INTEN,,FRACT         VWEVID
20m0004 11430 640700064077000440000000	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
20m0004                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
20m0004 11431 640700200555000443000000	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0004                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
20m0004                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
20m0004 11432 451140014475036040001443	                COND[OBUS<0] JUMP[. + 9] C600 $
20m0004                               	                ;If INTEN,,FRACT-0,,377777<0, done.
20m0004                               	
20m0004 11433 640700070171000440000000	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
20m0004                               	                ;Q=OFFSET,,LINE
20m0004 11434 640701414477044013000000	        D[CONST 1] ROT[18.] ALU[Q-D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0004                               	                ;OFFSET-1,,LINE
20m0004                               	
20m0004 11435 661140000571000440001426	        COND[-INTRPT] JUMP[. - 7] NORM $
20m0004                               	                ;Loop if no interrupt
20m0004       11426	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
20m0004                               	        VIDSAV[%VIDFOO] 
20m0004 11436 640700014171030010000000	[       D[CONST (%VIDFOO / 10000)] ROT[12.] DEST[Q] NORM $
20m0004                               	                ;Q=high bit (SDISP loads all 16 bits)
20m0004 11437 640700014175014140000000	        D[CONST (77 & (%VIDFOO / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
20m0004                               	                ;Q=next 6 ADR bits
20m0004 11440 640704414575000260000000	        D[CONST (%VIDFOO \ 100)] ALU[QORD] DEST[HOLD] NORM $
20m0004                               	                ;Q=SAVE ADR
20m0004 11441 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

20m0004                               	                ;Q=POGB
20m0004 11442 640164014435000720000650	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
20m0004                               	                ;MA=POGB+58     write SAVE ADR
20m0004                               	]       ;       THE MACRO GETS ITS ARGUMENT.
20m0004                               	                ;Interrupt
20m0005                               	]
20m0005                               	;Paint right.
20m0005 11443 640700040171104200000000	        D[10 + PIXEL,,FRACT] ROT[36. - 2] MASK[16.] DEST[Q] NORM $
20m0005                               	                ;Q=MULTIPLIER(0,,00 16 BIT)
20m0005 11444 640040014137040010000000	        D[CONST 1] ROT[16.] ALU[D-Q] DEST[Q] PUSHJ[VIDMUL] NORM $
20m0005                               	                ;Q=1-MULTIPLIER (0,,200000-16 BIT)      multiply
20m0005 11445 640700214537044033000000	        D[CONST 3] ROT[18.] ALU[D-Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0005                               	                ;INTEN,,FRACT=3,,0-0,,DELTA*A3DYDX,,FRACT
20m0005                               	
20m0005                               	        VIDRGT
20m0005                               	
20m0005 11446 640700070171000220000000	[       D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0005                               	                ;Q=0,,LINE
20m0005 11447 640701414575044013000000	        D[CONST 1] ROT[18.] ALU[QORD] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0005                               	                ;OFFSET,,LINE=1,,LINE
20m0005                               	
20m0005 11450 640040000571000440000000	        PUSHJ[VIDDT1] NORM $
20m0005                               	                ;Do it (loop to here)
20m0005                               	
20m0005 11451 240700044171000440070000	        MAPF[7] D[10 + INTEN,,FRACT] DEST[Q] C800 $
20m0005                               	                ;Q=INTEN,,FRACT         VWEVID
20m0005 11452 640700064077000440000000	        D[10 + A3DYDX,,FRACT] ALU[Q-D] DEST[Q] NORM $
20m0005                               	                ;Q=INTEN,,FRACT-A3DYDX,,FRACT
20m0005 11453 640700200555000443000000	        ALU[Q] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
20m0005                               	                ;AMEM[1]=INTEN,,FRACT-A3DYDX,,FRACT
20m0005                               	        D[CONST 4] ROT[15.] ALU[Q-D-1]
20m0005 11454 451140014475036040001465	                COND[OBUS<0] JUMP[. + 9] C600 $
20m0005                               	                ;If INTEN,,FRACT-0,,377777<0, done.
20m0005                               	
20m0005 11455 640700070171000440000000	        D[10 + OFFSET,,LINE] DEST[Q] NORM $
20m0005                               	                ;Q=OFFSET,,LINE
20m0005 11456 640701414435044013000000	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0005                               	                ;OFFSET+1,,LINE
20m0005                               	
20m0005 11457 661140000571000440001450	        COND[-INTRPT] JUMP[. - 7] NORM $
20m0005                               	                ;Loop if no interrupt
20m0005       11450	        %VIDFOO = (. - 8)       ;NOTE: THIS FORCES EVALUATION BEFORE
20m0005                               	        VIDSAV[%VIDFOO] 
20m0005 11460 640700014171030010000000	[       D[CONST (%VIDFOO / 10000)] ROT[12.] DEST[Q] NORM $
20m0005                               	                ;Q=high bit (SDISP loads all 16 bits)
20m0005 11461 640700014175014140000000	        D[CONST (77 & (%VIDFOO / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
20m0005                               	                ;Q=next 6 ADR bits
20m0005 11462 640704414575000500000000	        D[CONST (%VIDFOO \ 100)] ALU[QORD] DEST[HOLD] NORM $
20m0005                               	                ;Q=SAVE ADR
20m0005 11463 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
20m0005                               	                ;Q=POGB
20m0005 11464 640164014435000720000650	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
20m0005                               	                ;MA=POGB+58     write SAVE ADR
20m0005                               	]       ;       THE MACRO GETS ITS ARGUMENT.
20m0005                               	                ;Interrupt
20m0006                               	]
20m0006                               	;Increment line and reset offset.
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

20m0006 11465 640700070171000220000000	VIDSL2: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
20m0006                               	                ;Q=0,,LINE
20m0006 11466 640701400417000443000000	        ALU[Q+1] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
20m0006                               	                ;OFFSET,,LINE=0,,LINE+1
20m0006                               	
20m0006                               	;Check for below window.
20m0006 11467 640700070171044000200000	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
20m0006                               	                ;Q=LINE,,0
20m0006                               	        D[10 + YMAX,,YMIN] SPEC[LEFT] ALU[D-Q]
20m0006 11470 451140054537000000200000	                COND[OBUS<0] JUMP[VIDVEN] C600 $
20m0006                               	                ;If YMAX,,0-LINE,,0<0, terminate
20m0006                               	
20m0006                               	;Increment X position.
20m0006 11471 640700040171000440000000	        D[10 + PIXEL,,FRACT] DEST[Q] NORM $
20m0006                               	                ;Q=PIXEL,,FRACT
20m0006 11472 640700060035000440000000	        D[10 + DXDY,,FRACT] ALU[Q+D] DEST[Q] NORM $
20m0006                               	                ;Q=PIXEL,,FRACT+DXDY,,FRACT
20m0006 11473 640140000555000443001420	        ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM JUMP[VIDLL2] NORM $
20m0006                               	                ;PIXEL,,FRACT=PIXEL,,FRACT+DXDY,,FRACT  loop
20m0006                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

21m0006                               	;Vertical Vectors
21m0006 11474 640040000571000440000000	VIDVRV: PUSHJ[VIDVLM] NORM $
21m0006                               	                ;Form boundary limits
21m0006                               	
21m0006 11475 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
21m0006                               	                ;Q=POGB
21m0006 11476 640720014435000750000000	        D[CONST 61.] ALU[D+Q] DEST[MA] NORM $
21m0006                               	                ;MA=POGB+61.    read X0,,X1
21m0006 11477 640710050171044000200000	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q AR] NORM $
21m0006                               	                ;Q,AR=XMIN,,0   (AR for use below)
21m0006                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
21m0006 11500 451140004537000000200636	                COND[OBUS<0] JUMP[VIDDON] C600 $
21m0006                               	                ;If X0,,0-XMIN,,0<0, main loop
21m0006 11501 640700050171000000200000	        D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
21m0006                               	                ;Q=XMAX,,0
21m0006                               	        D[MEM] SPEC[LEFT] ALU[Q-D]
21m0006 11502 451140004477000000200636	                COND[OBUS<0] JUMP[VIDDON] C600 $
21m0006                               	                ;If XMAX,,0-X0,,0<0, main loop
21m0006                               	
21m0006 11503 640700000571000443000000	        D[AR] DEST[PIXEL,,FRACT] DEST-A-MEM NORM $
21m0006                               	                ;PIXEL,,FRACT=XMIN,,0
21m0006 11504 640700054171000220000000	        D[10 + YMAX,,YMIN] MASK[18.] DEST[Q] NORM $
21m0006                               	                ;Q=0,,YMIN
21m0006 11505 640701400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
21m0006                               	                ;OFFSET,,LINE=0,,YMIN
21m0006 11506 640700214571044033000000	        D[CONST 3] ROT[18.] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
21m0006                               	                ;INTEN,,FRACT=3,,0
21m0006                               	
21m0006 11507 640700054171000000200000	VIDVRL: D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
21m0006                               	                ;Q=YMAX,,0
21m0006                               	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] ALU[Q-D]
21m0006 11510 451140070477044000200000	                COND[OBUS<0] JUMP[VIDVEN] C600 $
21m0006                               	                ;If YMAX,,0-LINE,,0<0 terminate
21m0006                               	
21m0006 11511 640040000571000440000000	        PUSHJ[VIDDOT] NORM $
21m0006                               	                ;Do one pixel
21m0006                               	
21m0006 11512 240700070171000220070000	        MAPF[7] D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] C800 $
21m0006                               	                ;Q=0,,LINE      VWEVID
21m0006                               	        ALU[Q+1] DEST[OFFSET,,LINE] DEST-A-MEM
21m0006 11513 661141400417000443001507	                COND[-INTRPT] JUMP[VIDVRL] NORM $
21m0006                               	                ;OFFSET,,LINE=0,,LINE+1         loop if no interrupt
21m0006                               	        VIDSAV[VIDVRL]
21m0006                               	
21m0006 11514 640700014171030010000000	[       D[CONST (VIDVRL / 10000)] ROT[12.] DEST[Q] NORM $
21m0006                               	                ;Q=high bit (SDISP loads all 16 bits)
21m0006 11515 640700014175014150000000	        D[CONST (77 & (VIDVRL / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
21m0006                               	                ;Q=next 6 ADR bits
21m0006 11516 640704414575000070000000	        D[CONST (VIDVRL \ 100)] ALU[QORD] DEST[HOLD] NORM $
21m0006                               	                ;Q=SAVE ADR
21m0006 11517 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
21m0006                               	                ;Q=POGB
21m0006 11520 640164014435000720000650	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
21m0006                               	                ;MA=POGB+58     write SAVE ADR
21m0007                               	]               ;Interrupt
21m0007                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

22m0007                               	;Horizontal Vectors
22m0007 11521 640040000571000440000000	VIDHZV: PUSHJ[VIDVLM] NORM $
22m0007                               	                ;Form boundary limits
22m0007                               	
22m0007 11522 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
22m0007                               	                ;Q=POGB
22m0007 11523 640720014435000760000000	        D[CONST 62.] ALU[D+Q] DEST[MA] NORM $
22m0007                               	                ;MA=POGB+62.    read Y0,,Y1
22m0007 11524 640710054171044000200000	        D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q AR] NORM $
22m0007                               	                ;Q,AR=YMIN,,0 (AR for use below)
22m0007                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
22m0007 11525 451140004537000000200636	                COND[OBUS<0] JUMP[VIDDON] C600 $
22m0007                               	                ;IF Y0,,0-YMIN,,0<0, main loop
22m0007 11526 640700054171000000200000	        D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
22m0007                               	                ;Q=YMAX,,0
22m0007                               	        D[MEM] SPEC[LEFT] ALU[Q-D]
22m0007 11527 451140004477000000200636	                COND[OBUS<0] JUMP[VIDDON] C600 $
22m0007                               	                ;IF YMAX,,0-Y0,,0<0, main loop
22m0007                               	
22m0007 11530 640701400571044443000000	        D[AR] ROT[18.] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
22m0007                               	                ;OFFSET,,LINE=0,,YMIN
22m0007 11531 640700050171044000200000	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
22m0007                               	                ;Q=XMIN,,0
22m0007 11532 640700000555000443000000	        ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM NORM $
22m0007                               	                ;PIXEL,,FRACT=XMIN,,0
22m0007 11533 640700214571044033000000	        D[CONST 3] ROT[18.] DEST[INTEN,,FRACT] DEST-A-MEM NORM $
22m0007                               	                ;INTEN,,FRACT=3,,0
22m0007                               	
22m0007 11534 640700050171000000200000	VIDHZL: D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
22m0007                               	                ;Q=XMAX,,0
22m0007                               	        D[10 + PIXEL,,FRACT] SPEC[LEFT] ALU[Q-D]
22m0007 11535 451140040477000000200000	                COND[OBUS<0] JUMP[VIDVEN] C600 $
22m0007                               	                ;If XMAX,,0-PIXEL,,0<0, terminate
22m0007                               	
22m0007 11536 640040000571000440000000	        PUSHJ[VIDDOT] NORM $
22m0007                               	                ;Do one pixel
22m0007                               	
22m0007 11537 240700040171000440070000	        MAPF[7] D[10 + PIXEL,,FRACT] DEST[Q] C800 $
22m0007                               	                ;Q=PIXEL,,FRACT         VWEVID
22m0007                               	        D[CONST 1] ROT[18.] ALU[Q+D] DEST[PIXEL,,FRACT] DEST-A-MEM
22m0007 11540 661140014435044013001534	                COND[-INTRPT] JUMP[VIDHZL] NORM $
22m0007                               	                ;PIXEL,,FRACT=PIXEL+1,,FRACT    loop if no interrupt
22m0007                               	        VIDSAV[VIDHZL]
22m0007                               	
22m0007 11541 640700014171030010000000	[       D[CONST (VIDHZL / 10000)] ROT[12.] DEST[Q] NORM $
22m0007                               	                ;Q=high bit (SDISP loads all 16 bits)
22m0007 11542 640700014175014150000000	        D[CONST (77 & (VIDHZL / 100))] ROT[6] ALU[QORD] DEST[Q] NORM $
22m0007                               	                ;Q=next 6 ADR bits
22m0007 11543 640704414575000340000000	        D[CONST (VIDHZL \ 100)] ALU[QORD] DEST[HOLD] NORM $
22m0007                               	                ;Q=SAVE ADR
22m0007 11544 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
22m0007                               	                ;Q=POGB
22m0007 11545 640164014435000720000650	        D[CONST 58.] ALU[Q+D] DEST[MA] STRT-WRT JUMP[VIDINT] NORM $
22m0007                               	                ;MA=POGB+58     write SAVE ADR
22m0008                               	]               ;Interrupt
22m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

23m0008                               	;Vector endpoint cleanup (subtract away first point if visible)
23m0008 11546 640700074171000220000000	VIDVEN: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
23m0008                               	                ;Q=POGB
23m0008 11547 640720014435000760000000	        D[CONST 62.] ALU[Q+D] DEST[MA] NORM $
23m0008                               	                ;MA=POGB+62.    read Y0,,Y1
23m0008 11550 640700054171044000200000	        D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=YMIN,,0
23m0008                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
23m0008 11551 451140004537000000200636	                COND[OBUS<0] JUMP[VIDDON] C600 $
23m0008                               	                ;If Y0,,0-YMIN,,0<0, main loop
23m0008 11552 640700054171000000200000	        D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=YMAX,,0
23m0008                               	        D[MEM] SPEC[LEFT] ALU[Q-D]
23m0008 11553 451140004477000000200636	                COND[OBUS<0] JUMP[VIDDON] C600 $
23m0008                               	                ;If YMAX,,0-Y0,,0<0, main loop
23m0008 11554 640710004571000000200000	        D[MEM] SPEC[LEFT] DEST[AR] NORM $
23m0008                               	                ;AR=Y0,,0       (for use below)
23m0008                               	
23m0008 11555 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
23m0008                               	                ;Q=POGB
23m0008 11556 640720014435000750000000	        D[CONST 61.] ALU[Q+D] DEST[MA] NORM $
23m0008                               	                ;MA=POGB+62.    read X0,,X1
23m0008 11557 640700050171044000200000	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=XMIN,,0
23m0008                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
23m0008 11560 451140004537000000200636	                COND[OBUS<0] JUMP[VIDDON] C600 $
23m0008                               	                ;If X0,,0-XMIN,,0<0, main loop
23m0008 11561 640700050171000000200000	        D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=XMAX,,0
23m0008                               	        D[MEM] SPEC[LEFT] ALU[Q-D]
23m0008 11562 451140004477000000200636	                COND[OBUS<0] JUMP[VIDDON] C600 $
23m0008                               	                ;If XMAX,,0-X0,,0<0, main loop
23m0008                               	
23m0008 11563 640700004171000000200000	        D[MEM] SPEC[LEFT] DEST[Q] NORM $
23m0008                               	                ;Q=X0,,0
23m0008 11564 640700000555000443000000	        ALU[Q] DEST[PIXEL,,FRACT] DEST-A-MEM NORM $
23m0008                               	                ;PIXEL,,FRACT=X0,,0
23m0008 11565 640701400571044223000000	        D[AR] ROT[18.] MASK[18.] DEST[OFFSET,,LINE] DEST-A-MEM NORM $
23m0008                               	                ;OFFSET,,LINE=0,,Y0
23m0008 11566 640040214571044053000000	        D[CONST 5] ROT[18.] DEST[INTEN,,FRACT] DEST-A-MEM PUSHJ[VIDDOT] NORM $
23m0008                               	                ;INTEN,,FRACT=5,,0      Do it
23m0008 11567 240140000571000440070636	        MAPF[7] JUMP[VIDDON] C800 $
23m0008                               	                ;VWEVID         main loop
23m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

24m0008                               	;Output one pixel
24m0008 11570 640700070171000220000000	VIDDOT: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=0,,LINE
24m0008 11571 640141400555000443000000	        ALU[Q] DEST[OFFSET,,LINE] DEST-A-MEM JUMP[VIDDT2] NORM $
24m0008                               	                ;OFFSET,,LINE=0,,LINE
24m0008                               	
24m0008                               	;Enter here for limit check  
24m0008 11572 640700040171000000200000	VIDDT1: D[10 + PIXEL,,FRACT] SPEC[LEFT] DEST[Q] NORM $
24m0008                               	                ;Q=PIXEL,,0
24m0008 11573 640710070035000000200000	        D[10 + OFFSET,,LINE] SPEC[LEFT] ALU[Q+D] DEST[Q AR] NORM $
24m0008                               	                ;AR,Q=PIXEL,,0+OFFSET,,0
24m0008                               	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] ALU[Q-D]
24m0008 11574 451300050477044000200000	                COND[OBUS<0] POPJ C600 $
24m0008                               	                ;IF PIXEL,,0-XMIN,,0<0, RETURN
24m0008                               	        D[10 + XMAX,,XMIN] SPEC[LEFT] ALU[D-Q]
24m0008 11575 451300050537000000200000	                COND[OBUS<0] POPJ C600 $
24m0008                               	                ;IF XMAX,,0-PIXEL,,0<0, RETURN
24m0008                               	.REPEAT VIC2 [
24m0008                               	VIDDT2: D[AR] ROT[18.] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=0,,PIXEL
24m0008                               	        D[10 + OFFSET,,LINE] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[Q] NORM $
24m0008                               	                ;Q=LINE,,PIXEL
24m0008                               	        D[10 + INTEN,,FRACT] ROT[18.] MASK[3] DEST[AR] NORM $
24m0008                               	                ;AR=0,,INTEN
24m0008                               	        D[AR] ROT[33.] ALU[QORD] DEST[IOD] START-OUT NORM $
24m0008                               	                ;IOD=INTEN,LINE,,PIXEL
24m0008                               	        MAPF[13] START-IN C800 $
24m0008                               	                ;VLDPIX
24m0008                               	        MAPF[2] START-IN C800 $
24m0008                               	                ;VSYADR
24m0008                               	        MAPF[1] START-IN POPJ C800 $
24m0008                               	                ;VSYDAT return (Note: Next instructon must have MAPF[7])
24m0008                               	];VIC2
24m0008                               	.REPEAT 1 - VIC2 [
24m0008                               	VIDDT2: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=0,,LINE
24m0008                               	        D[CONST 4] ROT[6] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;AR=0,,LINE+256.
24m0008                               	        D[AR] ROT[5] MASK[14.] DEST[Q] NORM $
24m0008                               	                ;Q=0 LINE 00000
24m0008                               	        D[CONST 1] ROT[5] ALU[-D&Q] DEST[Q] NORM $
24m0008                               	                ;Q=0 LINE/2 000000
24m0008                               	        D[AR] ROT[36. - 1]
24m0008                               	                COND[-OBUS<0] JUMP[VIDDT3] C550 $
24m0008                               	                ;IF LSB[LINE]=1
24m0008                               	        D[CONST 1] ROT[14.] ALU[QORD] DEST[Q] NORM $
24m0008                               	                ;Q=ODD[LINE] LINE/2 000000
24m0008                               	VIDDT3: ALU[Q] DEST[HOLD] NORM $
24m0008                               	                ;MEM=INTERLACED LINE 000000
24m0008                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008                               	        D[CONST 60.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
24m0008                               	                ;MA=POGB+60.    write INTERLACED LINE 000000 (temp)
24m0008                               	
24m0008                               	        D[CONST 5] ROT[6] ALU[D-1] DEST[Q] NORM $
24m0008                               	                ;Q=319.
24m0008                               	        D[10 + PIXEL,,FRACT] ROT[18.] MASK[18.] ALU[Q+D] DEST[Q] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

24m0008                               	                ;Q=0,,PIXEL+319.
24m0008                               	        D[10 + OFFSET,,LINE] ROT[18.] MASK[18.] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;Q=0,,PIXEL+0,,OFFSET+319.
24m0008                               	        D[AR] MASK[18.] DEST[Q AR] NORM $
24m0008                               	                ;Q,AR=0,,PIXEL+OFFSET+319.
24m0008                               	        D[AR] ROT[1] ALU[D+Q] DEST[AR] PUSHJ[VIDD33] NORM $
24m0008                               	                ;AR=3*corrected PIXEL   divide by 33
24m0008                               	
24m0008                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[AR] NORM $
24m0008                               	                ;AR=QUOTIENT,,REMAINDER=WORD,,PIXEL
24m0008                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008                               	        D[CONST 60.] ALU[Q+D] DEST[MA] NORM $
24m0008                               	                ;MA=POGB+60     read INTERLACED LINE 000000
24m0008                               	        D[AR] ROT[18.] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=WORD
24m0008                               	        D[MEM] ALU[QORD] DEST[Q] NORM $
24m0008                               	                ;Q=INTERLACED LINE 000000 + WORD (=interlaced address)
24m0008                               	
24m0008                               	        D[CONST 7] ROT[6] ALU[Q+D] DEST[Q] NORM $
24m0008                               	                ;Q=ADR+7*64.
24m0008                               	        D[CONST 6] ALU[Q+D] DEST[IOD] START-OUT NORM $
24m0008                               	                ;IOD=ADR+7 lines, 6 words
24m0008                               	
24m0008                               	        MAPF[2] D[AR] MASK[18.] DEST[Q] C800 $
24m0008                               	                ;VLDADR         Q=REMAINDER
24m0008                               	        D[CONST 30.] ALU[D-Q] DEST[ROTR] NORM $
24m0008                               	                ;ROTR=30-REMAINDER
24m0008                               	        D[10 + INTEN,,FRACT] DEST[Q] NORM $
24m0008                               	                ;Q=INTEN,,FRACT
24m0008                               	        D[CONST 4] ROT[15.] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;AR=INTEN,,FRACT+0,,400000
24m0008                               	        D[AR] ROT[18.] MASK[3] DEST[AR] NORM $
24m0008                               	                ;AR=0,,INTEN
24m0008                               	        D[AR] ROT[R] DEST[AR] NORM $
24m0008                               	                ;AR=DATA correctly shifted
24m0008                               	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008                               	        D[CONST 59.] ALU[Q+D] DEST[MA] NORM $
24m0008                               	                ;MA=POGB+59.    read COLOR MASK,,MASK
24m0008                               	        D[AR] DEST[Q] NORM $
24m0008                               	                ;Q=DATA
24m0008                               	        D[MEM] ALU[D#Q] DEST[IOD] START-OUT NORM $
24m0008                               	                ;IOD=DATA XOR COLOR
24m0008                               	        MAPF[1] START-IN POPJ C800 $
24m0008                               	                ;VLDDAT (next line must have MAPF[7] ... C800)
24m0008                               	];[
24m0008 11576 640700070171000220000000	VIDDT2: D[10 + OFFSET,,LINE] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=0,,LINE
24m0008 11577 640710014435014040000000	        D[CONST 4] ROT[6] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;AR=0,,LINE+256.
24m0008 11600 640700000171012160000000	        D[AR] ROT[5] MASK[14.] DEST[Q] NORM $
24m0008                               	                ;Q=0 LINE 00000
24m0008 11601 640700014275012010000000	        D[CONST 1] ROT[5] ALU[-D&Q] DEST[Q] NORM $
24m0008                               	                ;Q=0 LINE/2 000000
24m0008                               	        D[AR] ROT[36. - 1]
24m0008 11602 531140000571106440000000	                COND[-OBUS<0] JUMP[VIDDT3] C550 $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

24m0008                               	                ;IF LSB[LINE]=1
24m0008 11603 640700014175034010000000	        D[CONST 1] ROT[14.] ALU[QORD] DEST[Q] NORM $
24m0008                               	                ;Q=ODD[LINE] LINE/2 000000
24m0008 11604 640704400555000440000000	VIDDT3: ALU[Q] DEST[HOLD] NORM $
24m0008                               	                ;MEM=INTERLACED LINE 000000
24m0008 11605 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008 11606 640724014435000740000000	        D[CONST 60.] ALU[Q+D] DEST[MA] STRT-WRT NORM $
24m0008                               	                ;MA=POGB+60.    write INTERLACED LINE 000000 (temp)
24m0008                               	
24m0008 11607 640700014131014050000000	        D[CONST 5] ROT[6] ALU[D-1] DEST[Q] NORM $
24m0008                               	                ;Q=319.
24m0008 11610 640700040035044220000000	        D[10 + PIXEL,,FRACT] ROT[18.] MASK[18.] ALU[Q+D] DEST[Q] NORM $
24m0008                               	                ;Q=0,,PIXEL+319.
24m0008 11611 640710070435044220000000	        D[10 + OFFSET,,LINE] ROT[18.] MASK[18.] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;Q=0,,PIXEL+0,,OFFSET+319.
24m0008 11612 640710000171000220000000	        D[AR] MASK[18.] DEST[Q AR] NORM $
24m0008                               	                ;Q,AR=0,,PIXEL+OFFSET+319.
24m0008 11613 640050000435002440001165	        D[AR] ROT[1] ALU[D+Q] DEST[AR] PUSHJ[VIDD33] NORM $
24m0008                               	                ;AR=3*corrected PIXEL   divide by 33
24m0008                               	
24m0008 11614 640710004575044000200000	        D[MEM] ROT[18.] SPEC[LEFT] ALU[DORQ] DEST[AR] NORM $
24m0008                               	                ;AR=QUOTIENT,,REMAINDER=WORD,,PIXEL
24m0008 11615 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008 11616 640720014435000740000000	        D[CONST 60.] ALU[Q+D] DEST[MA] NORM $
24m0008                               	                ;MA=POGB+60     read INTERLACED LINE 000000
24m0008 11617 640700000171044220000000	        D[AR] ROT[18.] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=WORD
24m0008 11620 640700004175000440000000	        D[MEM] ALU[QORD] DEST[Q] NORM $
24m0008                               	                ;Q=INTERLACED LINE 000000 + WORD (=interlaced address)
24m0008                               	
24m0008 11621 640700014035014070000000	        D[CONST 7] ROT[6] ALU[Q+D] DEST[Q] NORM $
24m0008                               	                ;Q=ADR+7*64.
24m0008 11622 640702214435000063600000	        D[CONST 6] ALU[Q+D] DEST[IOD] START-OUT NORM $
24m0008                               	                ;IOD=ADR+7 lines, 6 words
24m0008                               	
24m0008 11623 240700000171000220020000	        MAPF[2] D[AR] MASK[18.] DEST[Q] C800 $
24m0008                               	                ;VLDADR         Q=REMAINDER
24m0008 11624 640701214537000360000000	        D[CONST 30.] ALU[D-Q] DEST[ROTR] NORM $
24m0008                               	                ;ROTR=30-REMAINDER
24m0008 11625 640700044171000440000000	        D[10 + INTEN,,FRACT] DEST[Q] NORM $
24m0008                               	                ;Q=INTEN,,FRACT
24m0008 11626 640710014435036040000000	        D[CONST 4] ROT[15.] ALU[Q+D] DEST[AR] NORM $
24m0008                               	                ;AR=INTEN,,FRACT+0,,400000
24m0008 11627 640710000571044030000000	        D[AR] ROT[18.] MASK[3] DEST[AR] NORM $
24m0008                               	                ;AR=0,,INTEN
24m0008 11630 640710000571200440000000	        D[AR] ROT[R] DEST[AR] NORM $
24m0008                               	                ;AR=DATA correctly shifted
24m0008 11631 640700074171000220000000	        D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
24m0008                               	                ;Q=POGB
24m0008 11632 640720014435000730000000	        D[CONST 59.] ALU[Q+D] DEST[MA] NORM $
24m0008                               	                ;MA=POGB+59.    read COLOR MASK,,MASK
24m0008 11633 640700000171000440000000	        D[AR] DEST[Q] NORM $
24m0008                               	                ;Q=DATA
24m0008 11634 640702204735000443600000	        D[MEM] ALU[D#Q] DEST[IOD] START-OUT NORM $
24m0008                               	                ;IOD=DATA XOR COLOR
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

24m0008 11635 240300000571000443410000	        MAPF[1] START-IN POPJ C800 $
24m0008                               	                ;VLDDAT (next line must have MAPF[7] ... C800)
24m0008                               	]1-VIC2
24m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

25m0008                               	;Compute Limits
25m0008 11636 640700074171000220000000	VIDVLM: D[10 + POG,,POGB] MASK[18.] DEST[Q] NORM $
25m0008                               	                ;Q=POGB
25m0008 11637 640700074035044040000000	        D[10 + POG,,POGB] ROT[18.] MASK[4] ALU[Q+D] DEST[Q] NORM $
25m0008                               	                ;Q=POGB+POG
25m0008 11640 640720014435000200000000	        D[CONST 16.] ALU[Q+D] DEST[MA] NORM $
25m0008                               	                ;MA=POGB+16.+POG        read POG XMAX,,XMIN
25m0008                               	
25m0008 11641 640700050171044000200000	        D[10 + XMAX,,XMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=XMIN,,0
25m0008                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[Q-D]
25m0008 11642 471140004477044000200000	                COND[-OBUS<0] JUMP[VIDVL1] C600 $
25m0008                               	                ;If XMIN,,0-POGXMIN,,0<0
25m0008 11643 640700050171000000200000	        D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=XMAX,,0
25m0008 11644 640700404575000223000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
25m0008                               	                ;XMAX,,XMIN=XMAX,,POGXMIN
25m0008                               	
25m0008 11645 640700050171000000200000	VIDVL1: D[10 + XMAX,,XMIN] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=XMAX,,0
25m0008                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
25m0008 11646 471140004537000000200000	                COND[-OBUS<0] JUMP[VIDVL2] C600 $
25m0008                               	                ;If POGXMAX,,0-XMAX,,0<0
25m0008 11647 640700050171000220000000	        D[10 + XMAX,,XMIN] MASK[18.] DEST[Q] NORM $
25m0008                               	                ;Q=0,,XMIN
25m0008 11650 640700004175000000200000	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[Q] NORM $
25m0008                               	                ;Q=POGXMAX,,XMIN
25m0008 11651 640700400555000443000000	        ALU[Q] DEST[XMAX,,XMIN] DEST-A-MEM NORM $
25m0008                               	                ;XMAX,,XMIN=POGXMAX,,XMIN
25m0008                               	
25m0008 11652 640700024171000440000000	VIDVL2: D[MA] DEST[Q] NORM $
25m0008                               	                ;Q=MA
25m0008 11653 640720014435000200000000	        D[CONST 16.] ALU[Q+D] DEST[MA] NORM $
25m0008                               	                ;MA=MA+16.      read POG YMAX,,YMIN
25m0008                               	
25m0008 11654 640700054171044000200000	        D[10 + YMAX,,YMIN] ROT[18.] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=YMIN,,0
25m0008                               	        D[MEM] ROT[18.] SPEC[LEFT] ALU[Q-D]
25m0008 11655 471140004477044000200000	                COND[-OBUS<0] JUMP[VIDVL3] C600 $
25m0008                               	                ;If YMIN,,0-POGYMIN,,0<0
25m0008 11656 640700054171000000200000	        D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=YMAX,,0
25m0008 11657 640700604575000223000000	        D[MEM] MASK[18.] ALU[DORQ] DEST[YMAX,,YMIN] DEST-A-MEM NORM $
25m0008                               	                ;YMAX,,YMIN=YMAX,,POGYMIN
25m0008                               	
25m0008 11660 640700054171000000200000	VIDVL3: D[10 + YMAX,,YMIN] SPEC[LEFT] DEST[Q] NORM $
25m0008                               	                ;Q=YMAX,,0
25m0008                               	        D[MEM] SPEC[LEFT] ALU[D-Q]
25m0008 11661 471300004537000000200000	                COND[-OBUS<0] POPJ C600 $
25m0008                               	                ;If POGYMAX,,0-YMAX,,0<0
25m0008 11662 640700054171000220000000	        D[10 + YMAX,,YMIN] MASK[18.] DEST[Q] NORM $
25m0008                               	                ;Q=0,,YMIN
25m0008 11663 640700004175000000200000	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[Q] NORM $
25m0008                               	                ;Q=POGYMAX,,YMIN
25m0008 11664 640300600555000443000000	        ALU[Q] DEST[YMAX,,YMIN] DEST-A-MEM POPJ NORM $
25m0008                               	                ;YMAX,,YMIN=POGYMAX,,YMIN
25m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

26m0008                               	;Multiply
26m0008                               	;A3DYDX,,FRACT=MULTIPLICAND(2 BIT,,16 BIT 00)   positive only
26m0008                               	;Q=MULTIPLIER(0,,00 16 BIT)                     positive only
26m0008 11665 640710064571036440000000	VIDMUL: D[10 + A3DYDX,,FRACT] ROT[15.] DEST[AR] NORM $
26m0008                               	                ;AR=MULTIPLICAND(0 17 BIT,,1 BIT 00000000000000000)
26m0008 11666 640704401215000440000000	        ACSEL[AC] ALU[0] DEST[O_AC HOLD] NORM $
26m0008                               	                ;HOLD=AC for safe keeping       AC=0
26m0008                               	;AR=MULTIPLICAND(0 17 BIT,,1 BIT 00000000000000000)
26m0008                               	;Q=MULTIPLIER(0,,00 16 BIT)
26m0008                               	;MEM=AC storage
26m0008 11667 640740014571000170000000	        D[CONST 15.] LLOAD NORM $
26m0008                               	                ;Loop 16 times
26m0008 11670 640240002021000030001670	        D[AR] ACSEL[AC] ALU[MULAC+D] DEST[D4] MASK[3] LOOP[.] NORM $
26m0008                               	                ;Add AR to AC depending on the low order bit of Q.
26m0008                               	                ;Shift AC,,Q right. High order bit of AC=OVR XOR -IOB<0
26m0008                               	;AC=PRODUCT(0 17 BIT,,18 BIT)
26m0008 11671 640710005171000440000000	        D[MEM] ACSEL[AC] DEST[O_AC AR] NORM $
26m0008                               	                ;AC=AC storage, AR=PRODUCT(0 17 BIT,,18 BIT)
26m0008 11672 640300000171052240000000	        D[AR] ROT[36. - 15.] MASK[20.] DEST[Q] POPJ NORM $
26m0008                               	                ;Q=PRODUCT(2 BIT,,18 BIT)       return
26m0008                               	;Q=PRODUCT(2 BIT,,18 BIT)
26m0008                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VID.SLO  --  of -- f2x

27m0008                               	;Divide
27m0008                               	;AR=DIVIDEND,,0
27m0008                               	;MEM=DIVISOR,,0
27m0008 11673 531140000571000440000000	VIDDIV: D[AR]   COND[-OBUS<0] JUMP[VIDDV1] C550 $
27m0008                               	                ;If AR<0
27m0008 11674 640710000473000440000000	        D[AR] ALU[0-D] DEST[AR] NORM $
27m0008                               	                ;ABS[AR]
27m0008 11675 640710001171044440000000	VIDDV1: D[AR] ROT[18.] ACSEL[AC] DEST[O_AC AR] NORM $
27m0008                               	                ;AR LSH -18. <-> AC
27m0008 11676 640700000215000440000000	        ALU[0] DEST[Q] NORM $
27m0008                               	                ;Q=0
27m0008 11677 531140004571000440000000	        D[MEM]  COND[-OBUS<0] JUMP[VIDDV2] C550 $
27m0008                               	                ;If MEM<0
27m0008 11700 640144404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD] JUMP[VIDDV2] NORM $
27m0008                               	                ;ABS[MEM]
27m0008                               	
27m0008                               	: (. + 3) - (. \ 4)
27m0008                               	                ;.QUAD-1
27m0008 11703 640740014571000440000000	VIDDV2: D[CONST 36.] LLOAD NORM $
27m0008                               	                ;Loop 37 times
27m0008                               	
27m0008                               	VIDDVL: D[MEM] ALU[DIVAC-D] ACSEL[AC] DEST[D6] MASK[3]
27m0008 11704 451640007043000030001704	                COND[OBUS<0] SLOOP[VIDDVL] C600 $
27m0008                               	                ;Loop here if remainder positive
27m0008 11705 640310001171000440000000	        D[AR] ACSEL[AC] ALU[D] DEST[O_AC AR] POPJ NORM $
27m0008                               	                ;Swap AR <-> AC and return
27m0008                               	        D[MEM] ALU[DIVAC+D] ACSEL[AC] DEST[D6] MASK[3]
27m0008 11706 451640007001000030001704	                COND[OBUS<0] SLOOP[VIDDVL] C600 $
27m0008                               	                ;Loop here if remainder positive
27m0008 11707 640310001171000440000000	        D[AR] ACSEL[AC] DEST[O_AC AR] POPJ NORM $
27m0008                               	                ;Swap AR <-> AC and return
27m0008                               	;Q=QUOTIENT,,FRACT
27m0008                               	
27m0008                               	.REPEAT XUCODE [
27m0008                               	        .USE[OTHER]     ;If 8K u-mem present, return to low memory.
27m0008                               	]
27m0008                               	[
27m0008                               	        .USE[OTHER]      [ XLIST
27m0008                               	 LIST ];If 8K u-mem present, return to low memory.
27m0008                               	]
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

39m0155                               	]VID
39m0155                               	        .OPCODE[766]
39m0155                               	 [XLIST 
39m0156                               	 LIST            ].REPEAT ((1 - VID) * (773 - 766 + 1)) [
39m0156                               	        ILGIOT $                        ;OPS 766:773
39m0156                               	        NOP $
39m0156                               	];1-VID
39m0156                               	.REPEAT VID [
39m0156                               	        ILGIOT $                        ;OP 766 = illegal (reserved)
39m0156                               	        NOP $
39m0156                               	        GETADR[VIDDPA] JUMP[GOHIGH]$    ;OP 767 = DPYADD
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156                               	        FIXM2$                          ;OP 770 = VIDIN
39m0156                               	        D[CONST 36] DEST[DEV-ADR] JUMP[VIDIN]$
39m0156                               	        FIXM1$                          ;OP 771 = VIDOUT
39m0156                               	        D[CONST 36] DEST[DEV-ADR] JUMP[VIDOUT]$
39m0156                               	        GETADR[VIDDPI] JUMP[GOHIGH]$    ;OP 772 = DPYINI
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156                               	        GETADR[VIDDPO] JUMP[GOHIGH]$    ;OP 773 = DPYOUT
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156                               	];[
39m0156                               	        ILGIOT 
39m0156 03754 000140000571000440002026	[  JUMP [MAIN] ]$                       ;OP 766 = illegal (reserved)
39m0156 03755 000700000571000440000000	        NOP $
39m0156                               	        GETADR[VIDDPA]  [  ;Place the 12-bit value of VIDDPA in Q.
39m0156 03756 640700014171014040000000	        D[CONST (77 & (VIDDPA / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
39m0156 03757 440140014175000330006224	        D[CONST (VIDDPA \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH]$   ;OP 767 = DPYADD
39m0156                               	
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156 03760 640706200550400440030000	        FIXM2$                          ;OP 770 = VIDIN
39m0156 03761 000141614571000360006245	        D[CONST 36] DEST[DEV-ADR] JUMP[VIDIN]$
39m0156 03762 640706000550400440020000	        FIXM1$                          ;OP 771 = VIDOUT
39m0156 03763 000141614571000360006250	        D[CONST 36] DEST[DEV-ADR] JUMP[VIDOUT]$
39m0156                               	        GETADR[VIDDPI]  [  ;Place the 12-bit value of VIDDPI in Q.
39m0156 03764 640700014171014030000000	        D[CONST (77 & (VIDDPI / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
39m0156 03765 440140014175000470006224	        D[CONST (VIDDPI \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH]$   ;OP 772 = DPYINI
39m0156                               	
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156                               	        GETADR[VIDDPO]  [  ;Place the 12-bit value of VIDDPO in Q.
39m0156 03766 640700014171014040000000	        D[CONST (77 & (VIDDPO / 100))] ROT[6] DEST[Q] NORM $ ;High-order 6 bits
39m0156 03767 440140014175000350006224	        D[CONST (VIDDPO \ 100)] ALU[DORQ] DEST[Q] C600 ]JUMP[GOHIGH]$   ;OP 773 = DPYOUT
39m0156                               	
39m0156                               	                                        ;Note: GETADR expands to 2 words
39m0156                               	]VID
39m0156                               	        .RELOC
39m0156                               	 [.USE[OTHER]
39m0156                               	 [ XLIST
39m0157                               	 LIST ]]
39m0157                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

40m0157                               	;FLOATING POINT, KA10 STYLE.
40m0157                               	;NONDISPATCH CODE.
40m0157                               	.DEFINE CFPLOW[] [D[AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]
40m0157                               	.DEFINE JINSEXP[] [D[AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]
40m0157                               	.DEFINE CINSEXP[] [D[AR] ROT[27.] DEST[Q] PUSHJ[INSEX1] NORM ]
40m0157                               	.DEFINE CFDS[] [D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] PUSHJ[FDS1] NORM]
40m0157                               	
40m0157                               	;***** DON'T USE A-MEM 0 FOR ANYTHING BESIDES DISPATCHES!!!     TVR-Sep80  *****
40m0157                               	;***** This must be fixed!!!!                                   TVR-Sep80  *****
40m0157 06256 640050000551000443000000	UFA1:   ALU[AC] ACSEL[AC] DEST[0 AR] DEST-A-MEM PUSHJ[FADSUB] NORM $
40m0157 06257 640710041171000440000000	        D[10] ACSEL[AC] DEST[AR O_AC] SHORT $
40m0157 06260 000160001571400440602027	        D[AR] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] $
40m0157                               	
40m0157                               	        .PAIR    [:. \ 2 + .
40m0157                               	];: 6460                ;.PAIR
40m0157 06262 640140001751000440006264	DFN1:   ACSEL[AC] ALU[NOTAC] DEST[AC] JUMP[. + 2] NORM $
40m0157 06263 640700001513000440000000	        ACSEL[AC] ALU[0-AC] DEST[AC] SHORT $
40m0157 06264 640700004171000440000000	        D[MEM] DEST[Q] SHORT $
40m0157 06265 640700010235066110000000	        D[MASK 9] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
40m0157 06266 662104200575000330002032	        D[AR] MASK[27.] ALU[DORQ] DEST[MEMSTO] MEMSTMA  [COND[-MA-AC] LBJUMP[MSMAIN] NORM
40m0157                               	 ]$
40m0157                               	
40m0157 06267 640160001615000440602027	FSCZAP: ALU[0] DEST[MA AC] ACSEL[AC] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0157 06270 640710000171022110000000	FSC1:   D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
40m0157 06271 531140011661066100000000	        D[MASK 8] ROT[27.] ACSEL[AC] ALU[-D&AC] DEST[AC] COND[-OBUS<0] JUMP[FSC2] C550 $
40m0157                               	
40m0157 06272 640710010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q AR] SHORT $
40m0157 06273 640700011561066100000000	        D[MASK 8] ROT[27.] ACSEL[AC] ALU[DORAC] DEST[AC] SHORT $
40m0157 06274 640700224435000220000000	FSC2:   D[MA] MASK[18.] ALU[D+Q] DEST[IR-ADR] SHORT $
40m0157 06275 640040000215000440000000	        ALU[0] DEST[Q] PUSHJ[NRMLIZ] NORM $
40m0157 06276 640040000171066440000000	        CINSEXP  [D[AR] ROT[27.] DEST[Q] PUSHJ[INSEX1] NORM ]$
40m0157 06277 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157                               	
40m0157                               	FAOS1:
40m0157                               	FAOS5:
40m0157 06300 640050000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06301 640160000571000440602027	        DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0157 06302 640050000551000440000000	FAOS2:  ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06303 640140001571400440000000	        CFPLOW  [D[AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]$
40m0157 06304 640710000551000440000000	FAOS3:  ACSEL[AC] ALU[AC] DEST[AR] NORM $
40m0157 06305 640701614571000110000000	        D[CONST 11] DEST[DEV-ADR] SHORT $
40m0157 06306 640040000551000443000000	        ACSEL[AC] ALU[AC] DEST[0] DEST-A-MEM PUSHJ[FADSUB] NORM $
40m0157 06307 662104241171000440002032	        D[10] ACSEL[AC] DEST[MEMSTO O_AC] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157 06310 640050000551000440000000	FAOS4:  ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FADSUB] NORM $
40m0157 06311 662104200551000440002032	        ACSEL[AC] ALU[AC] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157                               	
40m0157                               	FMP1:
40m0157                               	FMP5:
40m0157 06312 640050000551000440000000	        ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FM] NORM $
40m0157 06313 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157 06314 640050000551000440000000	FMP2:   ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FM] NORM $
40m0157 06315 640140001571400440000000	        CFPLOW  [D[AR] ACSEL[AC+1] DEST[AC] JUMP[FPLOW] NORM ]$
40m0157 06316 640710000551000440000000	FMP3:   ACSEL[AC] ALU[AC] DEST[AR] NORM $
40m0157 06317 640701614571000110000000	        D[CONST 11] DEST[DEV-ADR] SHORT $
40m0157 06320 640040000551000443000000	        ACSEL[AC] ALU[AC] DEST-A-MEM PUSHJ[FM] DEST[0] NORM $
40m0157 06321 662104241171000440002032	        D[10] ACSEL[AC] DEST[MEMSTO O_AC] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157 06322 640050000551000440000000	FMP4:   ACSEL[AC] ALU[AC] DEST[AR] PUSHJ[FM] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

40m0157 06323 662104200551000440002032	        ACSEL[AC] ALU[AC] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0157                               	
40m0157                               	;Macro to test for divide by zero
40m0157                               	.DEFINE DIVTST[] [D[MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]
40m0157                               	
40m0157                               	;;;FD5: D[MA] ROT[18.] DEST[HOLD] SPEC[LEFT] NORM $     ;Not needed.  TVR-Apr80
40m0157                               	
40m0157                               	;FDV,FDVR
40m0157 06324 510140004571000330000000	FD1:    DIVTST  [D[MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$      ;Check for divide
40m0157                               	 by zero
40m0157 06325 640050004721000440000000	        CFDS  [D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] PUSHJ[FDS1] NORM]$
40m0157 06326 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0157                               	
40m0157                               	;------------------------------------------------------------------------------
40m0157                               	;LONG MODE FLOATING DIVIDE.
40m0157                               	;------------------------------------------------------------------------------
40m0157 06327 510140004571000330000000	FD2:    DIVTST  [D[MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0157                               	 ;AR.0,IR.35:=XOR(DIVIDEND SIGN,DIVISOR SIGN).
40m0157 06330 640710004721000440000000	        D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] SHORT $
40m0157 06331 640700200571002010000000	        D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
40m0157                               	 ;FLUSH SIGN & EXPONENT FROM DIVIDEND LOW
40m0157 06332 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0157 06333 640700001571422440000000	        D[AR] ROT[9] DEST[AC] ACSEL[AC+1] SHORT $
40m0157 06334 640700011621422330000000	        D[MASK 27.] ROT[9] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
40m0157                               	 ;+ FORM OF DIVIDEND TO (AC,A-MEM[1]).  ORIG. DIVIDEND TO AR.
40m0157 06335 631150000551000440000000	        ALU[AC] ACSEL[AC] DEST[AR] COND[-OBUS<0] JUMP[FD2A] CYLEN[C450] $
40m0157 06336 510140001513400440006340	        ALU[0-AC] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[. + 2] C550 $
40m0157 06337 640140001751000440006341	        ALU[NOTAC] ACSEL[AC] DEST[AC] JUMP[. + 2] SHORT $
40m0157 06340 640700001513000440000000	        ALU[0-AC] ACSEL[AC] DEST[AC] NORM $
40m0157 06341 640701400551400443000000	FD2A:   ALU[AC] ACSEL[AC+1] DEST[6] DEST-A-MEM NORM $
40m0157 06342 640040000571000440000000	        PUSHJ[FD] NORM $        ;FOR NOW.
40m0157                               	 ;AC+1 GETS 0 IF REMAINDER = 0.
40m0157 06343 510140071571400440000000	        D[16] ACSEL[AC+1] DEST[AC] COND[OBUS=0] JUMP[FD2D] C550 $
40m0157 06344 640700002145400020000000	        ALU[SH-AC] ACSEL[AC+1] MASK[2] DEST[D4] NORM $
40m0157                               	         ;Shift remainder rt. 1
40m0157 06345 531140070571000440006347	        D[16] COND[-OBUS<0] C550 JUMP[. + 2] $
40m0157                               	         ;Extend sign bit
40m0157 06346 640700015561506010000000	        D[CONST 1] ROT[35.] ALU[DORAC] ACSEL[AC+1] DEST[AC] NORM $
40m0157                               	 ;SETUP EXPONENT OF REMAINDER.
40m0157 06347 640700044171000440000000	        D[11] DEST[Q] SHORT $
40m0157                               	 ;A-MEM[7] HAS ORIGINAL (DIVIDEND HOW)-(DIVISOR).
40m0157 06350 531140074571000440006352	        D[17] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0157 06351 640700014077000010000000	        D[CONST 1] ALU[Q-D] DEST[Q] SHORT $
40m0157 06352 453140014077000320000000	        D[CONST 26.] ALU[Q-D] DEST[Q] COND[OBUS18] JUMP[FD2C] C600 $
40m0157                               	.DEFINE SWAPAC[] [
40m0157                               	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0157                               	        D[AR] ACSEL[AC] DEST[AR O_AC] SHORT $
40m0157                               	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0157                               	]
40m0157                               	 ;SWAP QUOTIENT (AC) AND REMAINDER (AC+1)
40m0157                               	        SWAPAC
40m0157                               	 [
40m0157 06353 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0157 06354 640710001171000440000000	        D[AR] ACSEL[AC] DEST[AR O_AC] SHORT $
40m0157 06355 640700001571400440000000	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0158                               	] ;INSERT EXPONENT INTO REMAINDER.
40m0158 06356 640050000555000440000000	        ALU[Q] DEST[AR] PUSHJ[INSEXP] NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

40m0158                               	        SWAPAC
40m0158                               	 [
40m0158 06357 640710000551400440000000	        ALU[AC] ACSEL[AC+1] DEST[AR] SHORT $
40m0158 06360 640710001171000440000000	        D[AR] ACSEL[AC] DEST[AR O_AC] SHORT $
40m0158 06361 640700001571400440000000	        D[AR] ACSEL[AC+1] DEST[AC] SHORT $
40m0159 06362 640160000571000440602027	]FD2D:  SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0159 06363 640160001615400440602027	FD2C:   ALU[0] ACSEL[AC+1] DEST[AC MA] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
40m0159                               	
40m0159 06364 510140004571000330000000	FD3:    DIVTST  [D[MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0159 06365 640040000551000443000000	        ALU[AC] ACSEL[AC] DEST[0] DEST-A-MEM PUSHJ[FDS] NORM $
40m0159 06366 662104241171000440002032	        D[10] ACSEL[AC] DEST[MEMSTO O_AC] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0159 06367 510140004571000330000000	FD4:    DIVTST  [D[MEM] MASK[27.] COND[OBUS=0] JUMP[FPNDIV] C550]$
40m0159 06370 640050004721000440000000	        CFDS  [D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] PUSHJ[FDS1] NORM]$
40m0159 06371 662104200551000440002032	        ALU[AC] ACSEL[AC] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
40m0159                               	
40m0159                               	;HERE ON DIVISOR=0.  SET NO DIVIDE, OVF,FLOV,RETURN.
40m0159 06372 640700020171000440000000	FPNDIV: D[PC] DEST[Q] SHORT $
40m0159 06373 640040014175056010000000	        D[CONST 1] ROT[23.] ALU[DORQ] DEST[Q] PUSHJ[SETFOV] NORM $
40m0159 06374 640160000571000440602027	        DEST[MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;NORMALIZE DOUBLE PRECISION NUMBER IN AC,Q WHOSE EXPONENT
40m0159                               	; IS IN IR-ADR.  LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.
40m0159                               	; IF NUMBER IS 0, LEAVE 0 IN AR,AC, AND Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	.DEFINE CNORM[] [D[AR] ACSEL[AC] DEST[AC] PUSHJ[NRMLIZ] NORM]
40m0159                               	
40m0159                               	;A. Return immediately if 0.
40m0159 06375 510310000545000440000000	NRMLIZ: ALU[QORAC] ACSEL[AC] DEST[AR] COND[OBUS=0] POPJ C550 $
40m0159                               	;B. Check for mantissa overflow, move exponent to AR.
40m0159 06376 640050000551000440000000	        ALU[AC] DEST[AR] ACSEL[AC] PUSHJ[NORMOV] NORM $
40m0159                               	                ;Check mantissa and shift right if necessary
40m0159 06377 530300034571000220000000	        D[IR] MASK[18.] COND[-OBUS=0] POPJ C550 $
40m0159                               	                ;If we adjusted right, then we definitely don't have to
40m0159                               	                ;shift left.  We're done here.
40m0159                               	;C. Left shift until normalized.
40m0159 06400 611140000551000440000000	        ALU[AC] ACSEL[AC] COND[OBUS<0] JUMP[NEGNOR] CYLEN[C450] $
40m0159                               	                ;Separate into two cases, positive and negative
40m0159 06401 530300014621064010000000	POSNOR: D[CONST 1] ROT[26.] ALU[D&AC] ACSEL[AC] COND[-OBUS=0] POPJ C550 $
40m0159                               	                ;If high order bit of mantissa is one, we're done
40m0159 06402 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] SHORT $
40m0159                               	                ;Decrement the exponent
40m0159 06403 640140003145000020006401	        ALU[SH-AC] ACSEL[AC] MASK[2] DEST[D6] JUMP[POSNOR] NORM $
40m0159                               	                ;Shift left and try again.
40m0159 06404 510140014621064010000000	NEGNOR: D[CONST 1] ROT[26.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[NN1] C550 $
40m0159                               	                ;If high order bit of mantissa is zero, we're done
40m0159 06405 640710000531000440000000	        D[AR] ALU[D-1] DEST[AR] SHORT $
40m0159                               	                ;Decrement the exponent
40m0159 06406 640140003145000020006404	        ALU[SH-AC] ACSEL[AC] MASK[2] DEST[D6] JUMP[NEGNOR] NORM $
40m0159                               	                ;Shift left and try again.
40m0159 06407 530300010621000330000000	NN1:    D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[-OBUS=0] POPJ C550 $
40m0159                               	                ;Check for case of exactly -(2^n).  If it isn't, we're done
40m0159 06410 640700015561064010000000	        D[CONST 1] ROT[26.] ALU[DORAC] ACSEL[AC] DEST[AC] SHORT $
40m0159                               	                ;We went one too far, backup by simply OR'ing in the relevant
40m0159                               	                ;bit in the same manner as shifting would. 
40m0159                               	                ;(*** What about Q??  TVR-Jul80)
40m0159 06411 640310000433000440000000	        D[AR] ALU[D+1] DEST[AR] POPJ NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

40m0159                               	                ;Increment exponent to account for simulated left shift.
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;CHECK FOR MANTISSA OVERFLOW INTO EXPONENT FIELD.  CALL WITH
40m0159                               	; AR&AC,Q: # TO NORMALIZE, IR-ADR: ITS EXPONENT.
40m0159                               	; LEAVE EXPONENT IN AR.  SET IR-ADR=0 IF NO OVERFLOW.  SET IR-ADR<>0
40m0159                               	; IF OVERFLOW, AND NORMALIZE.
40m0159                               	;
40m0159                               	;M.O. <=> [AR0<>AR8] OR [(AR8=1) AND (AR9-35=0)]
40m0159                               	;------------------------------------------------------------------------------
40m0159 06412 511140000721020440000000	NORMOV: D[AR] ROT[8] ALU[D#AC] ACSEL[AC] COND[OBUS<0] JUMP[NOVYES] C550 $
40m0159                               	                ;Check to make sure AR<0>=AR<8>.  If they don't, the mantissa
40m0159                               	                ;clearly overlaps the exponent field.
40m0159 06413 530140010621000330000000	        D[MASK 27.] ALU[D&AC] ACSEL[AC] COND[-OBUS=0] JUMP[NOVNO] C550 $
40m0159                               	                ;Check for AR<9:35> for zero.  If not zero, we're OK
40m0159 06414 510140014621066010000000	        D[CONST 1] ROT[27.] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[NOVNO] C550 $
40m0159                               	                ;Check AR<8>.  If zero, we're OK
40m0159                               	;       \ /
40m0159                               	;Mantissa has overflowed, adjust it.  Right by one should be enough.
40m0159 06415 640700002145000010000000	NOVYES: ALU[SH-AC] ACSEL[AC] MASK[1] DEST[D4] SHORT $
40m0159                               	                ;Shift mantissa right (i think?)
40m0159 06416 640310234433000220000000	        D[IR] MASK[18.] ALU[D+1] DEST[AR IR-ADR] POPJ NORM $
40m0159                               	                ;Increment mantissa and flag that we changed it by setting
40m0159                               	                ;IR<18:35> to be non-zero.
40m0159                               	
40m0159                               	;Mantissa has not overflowed.
40m0159 06417 640710034571000220000000	NOVNO:  D[IR] MASK[18.] DEST[AR] SHORT $
40m0159                               	                ;Save exponent in AR
40m0159 06420 640300200615000440000000	        ALU[0] DEST[IR-ADR] POPJ NORM $
40m0159                               	                ;Zero IR<18:35> to signify success
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;INSERT EXPONENT IN AR INTO WORD IN AC.
40m0159                               	;SET FLOV,FLUN,OVF FLAGS AS REQUIRED.
40m0159                               	;PRESERVES AR, CLOBBERS Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159 06421 640700000171066440000000	INSEXP: D[AR] ROT[27.] DEST[Q] NORM $
40m0159                               	                ;Move exponent into position
40m0159 06422 640700010235066100000000	INSEX1: D[MASK 8.] ROT[27.] ALU[D&Q] DEST[Q] SHORT $
40m0159                               	                ;Flush stuff in mantissa area
40m0159 06423 640700001705000440000000	        ALU[Q#AC] ACSEL[AC] DEST[AC] SHORT $
40m0159                               	                ;Fill in exponent
40m0159 06424 513140000571000440000000	        D[AR] COND[OBUS18] JUMP[EXPUF] C550 $
40m0159                               	                ;Check for underflow (i.e. below range of exponent offset)
40m0159 06425 510300000571070120000000	        D[AR] MASK[10.] ROT[28.] COND[OBUS=0] POPJ C550 $
40m0159                               	                ;Check for overflow (i.e. above range of exponent offset)
40m0159 06426 640700020171000440000000	        D[PC] DEST[Q] SHORT $
40m0159                               	                ;Setup to set floating overflow
40m0159 06427 640305414575100110000000	SETFOV: D[CONST 11] ROT[32.] ALU[DORQ] DEST[CRYOV] POPJ NORM $
40m0159                               	                ;Turn on overflow and floating overflow
40m0159 06430 640700020171000440000000	EXPUF:  D[PC] DEST[Q] SHORT $
40m0159                               	                ;Setup to set no divide and floating overflow
40m0159 06431 640140014175060010006427	        D[CONST 1] ROT[24.] ALU[DORQ] DEST[Q] JUMP[SETFOV] NORM$
40m0159                               	                ;Turn on no divide, then do overflows
40m0159                               	
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	;FLOATING ADD AC&AR TO MEM.  RESULT, NORMALIZED AND ROUNDED
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

40m0159                               	; IF REQUIRED IN AC,Q.
40m0159                               	;------------------------------------------------------------------------------
40m0159                               	.DEFINE BLEXPS[DES1 TIME DES2] [
40m0159                               	        D[MASK 8] ROT[27.] ALU[DORAC] ACSEL[AC] DEST[DES2] COND[OBUS<0] JUMP[. + 2] C550
40m0159                               	 $
40m0159                               	        D[MASK 8] ROT[27.] ALU[-D&AC] ACSEL[AC] DEST[DES2] SHORT $
40m0159                               	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159                               	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[DES1] JUMP[. + 2] NORM $
40m0159                               	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[DES1] CYLEN[TIME] $
40m0159                               	];BLEXPS
40m0159                               	        ;A. + FORM EXPONENT OF AC,MEM RTO AR,Q RESP.
40m0159 06432 640710000171022110000000	FADSUB: D[AR] MASK[9] ROT[9] DEST[Q AR] SHORT $
40m0159 06433 510140014635020010000000	FADSU1: D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS1] C550 $
40m0159 06434 640710010735000110000000	        D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
40m0159 06435 640700004171022110000000	FS1:    D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
40m0159 06436 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FS2] C550 $
40m0159 06437 640700010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0159                               	        ;B. COMPUTE DIFFERENCE, SWAP OPRANDS IF AC HAS LARGER EXP.
40m0159                               	        ;   LEAVE + DIFFERENCE IN Q, DIFF -1 IN LOOP CTR.
40m0159                               	        ;   LEAVE LARGER EXPONENT IN IR-ADR.
40m0159 06440 640700200555000440000000	FS2:    ALU[Q] DEST[IR-ADR] SHORT $
40m0159 06441 471140000077000440000000	        D[AR] ALU[Q-D] DEST[Q] COND[-OBUS<0] JUMP[FS3] C600 $
40m0159 06442 640700200571000440000000	        D[AR] DEST[IR-ADR] SHORT $
40m0159 06443 640704405171000440000000	        D[MEM] ACSEL[AC] DEST[HOLD O_AC] NORM $
40m0159 06444 640700000117000440000000	        ALU[0-Q] DEST[Q] NORM $
40m0159 06445 640750000455000440000000	FS3:    ALU[Q-1] DEST[AR] LLOAD NORM $
40m0159                               	        ;C. BLANK EXPONENTS.
40m0159                               	        BLEXPS[HOLD NORM AC]
40m0159                               	 [
40m0159 06446 511140011561066100006450	        D[MASK 8] ROT[27.] ALU[DORAC] ACSEL[AC] DEST[AC] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159                               	
40m0159 06447 640700011661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] ACSEL[AC] DEST[AC] SHORT $
40m0159 06450 511140004171000440006452	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0159 06451 640144410675066100006453	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] JUMP[. + 2] NORM $
40m0159 06452 640704410575066100000000	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[HOLD] CYLEN[NORM] $
40m0160                               	]       ;D. IF DELTA EXPONENTS >62., AC GOES TO OBLIVION.
40m0160 06453 450140000033000440000000	        D[AR] ALU[D+1] DEST[Q] COND[OBUS=0] JUMP[FS5] C600 $
40m0160 06454 451140014477000770000000	        D[CONST 63.] ALU[Q-D] COND[OBUS<0] JUMP[FS4] C600 $
40m0160 06455 640700001615000440000000	        ALU[0] DEST[AC] ACSEL[AC] SHORT $
40m0160 06456 640140000215000440000000	        ALU[0] DEST[Q] JUMP[FS5] NORM $
40m0160 06457 640700000215000440000000	FS4:    ALU[0] DEST[Q] SHORT $
40m0160 06460 640240002145000010006460	        ACSEL[AC] ALU[SH-AC] DEST[D4] MASK[1] LOOP [.] NORM $
40m0160                               	        ;E. ADD.
40m0160 06461 640710004421000440000000	FS5:    D[MEM] ALU[D+AC] ACSEL[AC] DEST[AR] SHORT $
40m0160                               	        ;F. NORMALIZE RESULT.
40m0160 06462 640700035571000440000000	        D[IR] ACSEL[AC] DEST[AC] SHORT $        ;CHECK FOR UFA
40m0160 06463 510140014621100010000000	        D[CONST 1] ROT[40] ALU[D&AC] ACSEL[AC] COND[OBUS=0] JUMP[UFANOR] C550 $
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;ENTER HERE WITH RESULT IN AR,Q, EXP IN IR-ADR.
40m0160                               	;------------------------------------------------------------------------------
40m0160 06464 640040001571000440006375	FPNAR:  CNORM  [D[AR] ACSEL[AC] DEST[AC] PUSHJ[NRMLIZ] NORM]$                          
40m0160                               	 ;NOPE, NORMALIZE
40m0160                               	;(Calls NRMLIZ which changes register usage from above and adjusts various
40m0160                               	;things.  "LEAVE EXPONENT IN AR, NORMALIZED NUMBER IN AC,Q.")
40m0160                               	;G. ROUND IF NECESSARY, INSERT EXPONENT INTO HIGH ORDER WORD OF RESULT.
40m0160 06465 631144400555000440000000	        ALU[Q] COND[-OBUS<0] DEST[HOLD] JUMP[NORND] CYLEN[C450] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

40m0160                               	                ;Save Q in HOLD (i.e. MEM)
40m0160                               	                ;If Q<0> is zero, don't round
40m0160 06466 640700034171000440000000	        D[IR] DEST[Q] NORM $
40m0160                               	                ;Get Q so we check bit meaning rounding (??? Can't this be
40m0160                               	                ;done with D[IR] ROT[7] COND[OBUS<0]... ???)
40m0160 06467 510140014635072010000000	        D[CONST 1] ROT[35] ALU[D&Q] COND[OBUS=0] JUMP[NORND] C550 $
40m0160                               	                ;Check opcode to see if rounding is requested.
40m0160                               	                ;If not, we're done
40m0160 06470 640700004171000440000000	        D[MEM] DEST[Q] SHORT $
40m0160                               	                ;Restore Q
40m0160 06471 530140010635000430000000	        D[MASK 43] ALU[D&Q] COND[-OBUS=0] JUMP[YESRND] C550 $
40m0160                               	                ;Round if Q<1:35> is non-zero (? what does this signify???)
40m0160 06472 611140000551000440006421	        ALU[AC] ACSEL[AC] COND[OBUS<0] JUMP[INSEXP] CYLEN[C450] $
40m0160                               	                ;If mantissa is negative, we don't round (???)
40m0160                               	;       \ /
40m0160 06473 640700200571000440000000	YESRND: D[AR] DEST[IR-ADR] SHORT $
40m0160                               	                ;Setup IR for NRMLIZ
40m0160 06474 640040001413000440006375	        ALU[AC+1] ACSEL[AC] DEST[AC] PUSHJ[NRMLIZ] NORM $
40m0160                               	                ;Increment high order word and normalize once more (???)
40m0160 06475 640140000171066440006422	        JINSEXP  [D[AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]$
40m0160                               	                ;Now stick in exponent
40m0160                               	;       ---
40m0160 06476 640140004171000440006421	NORND:  D[MEM] DEST[Q] JUMP[INSEXP] NORM $
40m0160                               	                ;Restore Q and insert exponent(?)
40m0160                               	
40m0160                               	;UFA NORMALIZATION -- ONLY ON MANTISSA OVERFLOW.
40m0160 06477 450300001575000440000000	UFANOR: D[AR] ALU[DORQ] ACSEL[AC] DEST[AC] COND[OBUS=0] POPJ C600 $
40m0160 06500 640040001571000440006412	        D[AR] ACSEL[AC] DEST[AC] PUSHJ[NORMOV] NORM $
40m0160 06501 640140000171066440006422	        JINSEXP  [D[AR] ROT[27.] DEST[Q] JUMP[INSEX1] NORM ]$
40m0160                               	;       ---
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;SETUP LOW ORDER FP RESULT, STORE BOTH IN AC,AC+1
40m0160                               	;ENTER WITH LOW WORD IN MEM, HIGH WORD IN AC, HIGH
40m0160                               	;WORD'S EXPONENT IN AR&AC+1.
40m0160                               	;------------------------------------------------------------------------------
40m0160 06502 640710015463400330000000	FPLOW:  D[CONST 27.] ACSEL[AC+1] ALU[AC-D] DEST[AC AR] SHORT $
40m0160 06503 530140014621416010000000	        D[CONST 1] ROT[7] ACSEL[AC+1] ALU[D&AC] COND[-OBUS=0] JUMP[ZLOW] C550 $
40m0160 06504 510140004171066330000000	        D[MEM] ROT[27.] MASK[27.] DEST[Q] COND[OBUS=0] JUMP[ZLOW] C550 $
40m0160 06505 640700001571466440000000	        D[AR] ROT[27.] ACSEL[AC+1] DEST[AC] SHORT $
40m0160 06506 640700011621466100000000	        D[MASK 8] ROT[27.] ALU[D&AC] ACSEL[AC+1] DEST[AC] SHORT $
40m0160 06507 640160001545400440602027	        ACSEL[AC+1] ALU[QORAC] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0160 06510 640160001615400440602027	ZLOW:   ACSEL[AC+1] ALU[0] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
40m0160                               	
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;
40m0160                               	;       FLOATING MULTIPLY.  AC&AR BY MEM.
40m0160                               	;
40m0160                               	;*** This code produces non-zero results if MEM=-1.0 and AC=0  !!!    TVR-Jun80
40m0160                               	;------------------------------------------------------------------------------
40m0160                               	;A. SUM OF + FORM EXPONENTS -128.+1 TO IR-ADR.  +1 BECAUSE 28
40m0160                               	; STEPS ARE USED TO PROVIDE ONE GUARD DIGIT.
40m0160 06511 640710000171022110000000	FM:     D[AR] MASK[9] ROT[9] DEST[Q AR] NORM$
40m0160                               	                ;Extract the exponent from AC (which was copied into AR)
40m0160 06512 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM1] C550 $
40m0160                               	                ;Check sign bit of number.  Nothing special if positive
40m0160 06513 640710010735000110000000	        D[MASK 9] ALU[D#Q] DEST[AR] SHORT $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

40m0160                               	                ;Sign is negative, we want the one-complement of the exponent
40m0160                               	                ;field to get the actual exponent.
40m0160 06514 640700004171022110000000	FM1:    D[MEM] MASK[9] ROT[9] DEST[Q] SHORT $
40m0160                               	                ;Extract the exponent from MEM
40m0160 06515 510140014635020010000000	        D[CONST 1] ROT[8] ALU[D&Q] COND[OBUS=0] JUMP[FM2] C550 $
40m0160                               	                ;Check sign bit of number.  Nothing special if positive
40m0160 06516 640700010335000110000000	        D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0160                               	                ;Sign is negative, we want the one-complement of the exponent
40m0160                               	                ;field to get the actual exponent.
40m0160 06517 640700000037000440000000	FM2:    D[AR] ALU[D+Q] CARRY DEST[Q] SHORT $
40m0160                               	                ;Add the two exponents
40m0160                               	                ;+1. FOR GUARD DIGIT.
40m0160 06520 640700214477016010000000	        D[CONST 1] ROT[7] ALU[Q-D] DEST[IR-ADR] SHORT $
40m0160                               	                ;Account for exponent bias.  Put exponent in a safe place.
40m0160                               	;B. BLANK EXPONENTS.
40m0160                               	        BLEXPS[Q SHORT AR]
40m0160                               	 [
40m0160 06521 511150010561066100006523	        D[MASK 8] ROT[27.] ALU[DORAC] ACSEL[AC] DEST[AR] COND[OBUS<0] JUMP[. + 2] C550 $
40m0160                               	
40m0160 06522 640710010661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] ACSEL[AC] DEST[AR] SHORT $
40m0160 06523 511140004171000440006525	        D[MEM] DEST[Q] COND[OBUS<0] JUMP[. + 2] C550 $
40m0160 06524 640140010275066100006526	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[Q] JUMP[. + 2] NORM $
40m0160 06525 640700010175066100000000	        D[MASK 8] ROT[27.] ALU[DORQ] DEST[Q] CYLEN[SHORT] $
40m0161                               	]               ;Extend the sign to blank out the exponent field.  We will
40m0161                               	                ;now have perfectly good integers here, of 27 bit magnitude
40m0161                               	                ;(assuming that the numbers were normalized to begin with).
40m0161 06526 640040001615000440000000	        ALU[0] DEST[AC] ACSEL[AC] PUSHJ[TESMUL] NORM $ ;28. STEPS.
40m0161                               	;;;     ALU[Q] DEST[AR] SHORT $ ;FLUSH SIGN IN LO WD.
40m0161 06527 640710010275000070000000	        D[MASK 7] ALU[-D&Q] DEST[Q AR] SHORT $  ;FLUSH SIGN IN LO WD.
40m0161                               	                ;Flush remenants of multiplier in low order part of
40m0161                               	                ;word.  MASK field determined empirically (35-28???)
40m0161 06530 640700000035000440000000	        D[AR] ALU[D+Q] DEST[Q] SHORT $
40m0161                               	                ;Make low order word unsigned.
40m0161 06531 640150000551000440006464	        ALU[AC] ACSEL[AC] DEST[AR] JUMP[FPNAR] NORM $
40m0161                               	
40m0161                               	;28. STEP INTEGER MULTIPLY FOR USE BY FM.
40m0161 06532 640740014571000330000000	TESMUL: D[CONST 27.] LLOAD NORM $       ;LOOP 28 TIMES
40m0161 06533 640140000571000440004067	        JUMP[DOMUL1] NORM $     ;TEST.
40m0161                               	
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	;SHORT STYLE FLOATING DIVIDE AC BY MEM.
40m0161                               	; XOR OF DIVISOR&DIVIDEND SIGNS IN AR BIT 0.
40m0161                               	;------------------------------------------------------------------------------
40m0161 06534 640710004721000440000000	FDS:    D[MEM] ALU[D#AC] ACSEL[AC] DEST[AR] SHORT $
40m0161 06535 640700200571002010000000	FDS1:   D[AR] MASK[1] ROT[1] DEST[IR-ADR] SHORT $
40m0161 06536 631150000551000440006540	        ALU[AC] ACSEL[AC] DEST[AR] COND[-OBUS<0] JUMP[. + 2] CYLEN[C450] $
40m0161 06537 640700001513000440000000	        ALU[0-AC] ACSEL[AC] DEST[AC] SHORT $
40m0161 06540 640701400615000443000000	        ALU[0] DEST[6] DEST-A-MEM NORM $
40m0161                               	        ;FALLS THROUGH...
40m0161                               	
40m0161                               	;------------------------------------------------------------------------------
40m0161                               	;
40m0161                               	;       Floating Divide
40m0161                               	;
40m0161                               	; DIVIDEND HIGH ORDER WORD IN AC, LOW IN A-MEM[1]. DIVISOR IN MEM.
40m0161                               	; BOTH IN POSITIVE FORM.  IR.35=XOR(DIVIDEND SIGN,DIVISOR SIGN).
40m0161                               	; HOW DIVIDEND IN AR IN ORIGINAL (MAY BE <0) FORM.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

40m0161                               	;------------------------------------------------------------------------------
40m0161                               	FD:
40m0161                               	;A. PUT DIVISOR IN + FORM, GET DIVISOR EXPONENT.
40m0161                               	;.1 SHUFFLE IR.35 INTO A-MEM.
40m0161 06541 640701034571000223000000	        D[IR] MASK[18.] DEST[4] DEST-A-MEM NORM $
40m0161                               	                ;Save IR-ADR in A-MEM
40m0161 06542 531140004171000440006544	        D[MEM] DEST[Q] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0161                               	                ;Check for negative divisor
40m0161 06543 640704404073000440000000	        D[MEM] ALU[0-D] DEST[Q HOLD] NORM $
40m0161                               	                ;Negate divisor
40m0161 06544 640700204571022100000000	        D[MEM] ROT[9] MASK[8] DEST[IR-ADR] NORM $
40m0161                               	                ;Extract exponent from divisor, store in IR<18:35>
40m0161 06545 640704410675066100000000	        D[MASK 8] ROT[27.] ALU[-D&Q] DEST[HOLD] NORM $
40m0161                               	                ;Extract mantissa from divisor
40m0161                               	;B. FETCH AND BLANK HOW DIVIDEND EXPONENT.
40m0161 06546 640702200171022103000000	        D[AR] ROT[9] MASK[8] DEST[Q 11] DEST-A-MEM NORM $
40m0161                               	                ;Extract dividend exponent. Save also for FDVL
40m0161 06547 531140000571000440006551	        D[AR] COND[-OBUS<0] JUMP[. + 2] C550 $
40m0161                               	                ;Check for negative dividend
40m0161                               	;Grrr!!! >4 hrs of hard staring to find this bastard! TVR-Jul80
40m0161                               	;;;     D[MASK 9] ALU[D#Q] DEST[Q] SHORT $
40m0161 06550 640702210335000103000000	        D[MASK 8] ALU[D#Q] DEST[Q 11] DEST-A-MEM SHORT $
40m0161                               	                ;Fixup dividend exponent
40m0161 06551 640700011661066100000000	        D[MASK 8] ROT[27.] ALU[-D&AC] ACSEL[AC] DEST[AC] SHORT $
40m0161                               	                ;Extract mantissa from dividend
40m0161                               	;C. COMPUTE RESULTANT EXPONENT.
40m0161 06552 640700034077000220000000	        D[IR] MASK[18.] ALU[Q-D] DEST[Q] SHORT $
40m0161                               	                ;Subtract divisor exponent from dividend exponent
40m0161 06553 640700214435016010000000	        D[CONST 1] ROT[7] ALU[D+Q] DEST[IR-ADR] NORM $
40m0161                               	                ;Include exponent offset
40m0161                               	;D. MOVE LOW DIVIDEND TO Q.
40m0161 06554 640700070171000440000000	        D[16] DEST[Q] SHORT $
40m0161                               	;E. IF DIVISOR<=DIVIDEND,  SHIFT DIVIDEND RIGHT, INC
40m0161                               	        ; RESULTANT EXPONENT.  SAVE DIFF. IN A-MEM[7] FOR LONG MODE.
40m0161 06555 471141604463000443000000	        D[MEM] ALU[AC-D] ACSEL[AC] DEST[7] DEST-A-MEM COND[-OBUS<0] JUMP[FDAD] C600 $
40m0161                               	;F. SHIFT DIVIDEND RIGHT BY 8 SO RESULT WILL BE
40m0161                               	; NORMALIZED AFTER ROUNDING.  28. STEP DIVIDE WILL
40m0161                               	; FIX THIS.
40m0161 06556 640740014571000070000000	FDSHFT: D[CONST 7] LLOAD NORM $
40m0161 06557 640240002145000020006557	        ALU[SH-AC] ACSEL[AC] MASK[2] DEST[D4] LOOP[.] NORM $
40m0161                               	;GET 1. EXP TO A-MEM[4], 2. SIGN XOR TO IR-ADR.
40m0161 06560 640701200571000443000000	        D[AR] DEST[5] DEST-A-MEM NORM $
40m0161 06561 640710034571000440000000	        D[IR] DEST[AR] SHORT $
40m0161 06562 640700260571000440000000	        D[14] DEST[IR-ADR] SHORT $
40m0161 06563 640701000571000443000000	        D[AR] DEST[4] DEST-A-MEM NORM $
40m0161 06564 640710064571000440000000	        D[15] DEST[AR] SHORT $
40m0161 06565 640040000571000440004155	        PUSHJ[DODIV2] NORM $    ;36. STEP.  RESULT HAS SIGNS ADJUSTED.
40m0161                               	;G. SAVE REMAINDER IN A-MEM[6], PUT QUOTIENT IN AC, 0 IN Q.
40m0161 06566 640701400551000443000000	        ALU[AC] ACSEL[AC] DEST[6] DEST-A-MEM NORM $
40m0161 06567 640700001555000440000000	        ALU[Q] ACSEL[AC] DEST[AC] SHORT $
40m0161 06570 640700000215000440000000	        ALU[0] DEST[Q] SHORT $
40m0161                               	;H. PREPARE TO ROUND 29. BIT RESULT.
40m0161 06571 640700002145000010000000	        ALU[SH-AC] ACSEL[AC] MASK[1] DEST[D4] SHORT $
40m0161 06572 640700260571000440000000	        D[14] DEST[IR-ADR] SHORT $      ;MOVE EXP FOR FPNAR.
40m0161 06573 640150000551000440006464	        ALU[AC] ACSEL[AC] DEST[AR] JUMP[FPNAR] NORM $
40m0161                               	
40m0161                               	;------------------------------------------------------------------------------
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

40m0161                               	;HERE WHEN DIVIDEND IS >= DIVISOR.  SHIFT DIVIDEND RIGHT
40m0161                               	; AND INCREMENT RESULTANT AC.  THIS WILL ALLOW DIVIDE TO
40m0161                               	; SUCCEED IF BOTH DIVISOR & DIVIDEND WERE NORMALIZED
40m0161                               	; AND DIVISOR <> 0.
40m0161                               	;------------------------------------------------------------------------------
40m0161 06574 640700002145000020000000	FDAD:   ALU[SH-AC] ACSEL[AC] MASK[2] DEST[D4] SHORT $
40m0161 06575 640140234433000220006556	        D[IR] MASK[18.] ALU[D+1] DEST[IR-ADR] JUMP[FDSHFT] NORM $
40m0161                               	
40m0161                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

41m0161                               	;ADJSP1 ADJSP2 DMOVE2 DMOVN2 DMOVM2 DMVNM2 DMVNM3 DMVNM4 DMVNM5 KAFIXP KAFIXN FIXR1
41m0161                               	 KIFIX1 FIXRN KIFIXN FIXER FIXER1 FIXER2 FIXER3
41m0161                               	;
41m0161                               	;Strays from KI instructions
41m0161                               	;
41m0161                               	
41m0161                               	.REPEAT XUCODE [
41m0161                               	 .USE[AREA50]  ;Squeeze this stuff into the space vacated by MBOOT.
41m0161                               	    ]
41m0161                               	[
41m0161                               	 .USE[AREA50]  [ XLIST
41m0161                               	 LIST ] ;Squeeze this stuff into the space vacated by MBOOT.
41m0161                               	    ]
41m0161                               	;(ADJSP continued)
41m0161                               	;Left result is negative.  Check right side.
41m0161 05002 640710034421000220000000	ADJSP1: D[IR] MASK[22] ALU[D+AC] DEST[AR] NORM $
41m0161                               	                ;Add right half
41m0161 05003 640700010275000220000000	        D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
41m0161                               	                ;Isolate left half
41m0161 05004 640710001175000220000000	        D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] NORM $
41m0161                               	                ;Merge halves and store
41m0161 05005 533160034571000440602027	        D[IR] COND[-OBUS18] SPEC[MA_PC] DEST[MA] JUMP[MAIN1] C550 $
41m0161                               	                ;If E was positive, it wasn't an overflow (just a bad idea)
41m0161                               	                ;Start fetching next instruction
41m0161 05006 511140000571000440002026	        D[AR] COND[OBUS<0] JUMP[MAIN] C550 $
41m0161                               	                ;If original was negative, we're OK.  Start doing next
41m0161                               	                ;instruction if no sign changed in left half
41m0161 05007 640140000571000440004732	        JUMP[PDLO6] NORM $
41m0161                               	                ;ADJSP got a PDLOV
41m0161                               	;ADJSP left result positive
41m0161 05010 640700010275000220000000	ADJSP2: D[MASK 22] ALU[-D&Q] DEST[Q] SHORT $
41m0161                               	                ;Isolate left half
41m0161 05011 000710001175000220000000	        D[AR] MASK[22] ALU[DORQ] DEST[O_AC AR] $
41m0161                               	                ;Merge halves and store
41m0161 05012 513720034571000440600000	        D[IR] COND[OBUS18] SPEC[MA_PC] DEST[MA] C550 $
41m0161                               	                ;If E was negative, it wasn't an overflow (just a bad idea)
41m0161                               	                ;Start fetching next instruction
41m0161 05013 531140000571000440002027	        D[AR] COND[-OBUS<0] JUMP[MAIN1] C550 $
41m0161                               	                ;If original was positive, we're OK.  Start doing next
41m0161                               	                ;instruction if no sign changed in left half
41m0161 05014 640140000571000440004732	        JUMP[PDLO6] NORM $
41m0161                               	                ;ADJSP got a PDLOV
41m0161                               	
41m0161                               	;(DMOVE continued)
41m0161 05015 640720024433000440000000	DMOVE2: D[MA] ALU[D+1] DEST[MA] NORM $  ;Fetch second word
41m0161 05016 640706000550400440020000	        FIXM1 $                 ;Complete fetch
41m0161 05017 640160005571400440602027	        ACSEL[AC+1] D[MEM] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] CYLEN[FIXM+1] $
41m0161                               	                ;Put it in the second AC and start next instruction
41m0161                               	
41m0161                               	;(DMOVN continued)
41m0161 05020 640720024433000440000000	DMOVN2: D[MA] ALU[D+1] DEST[MA] NORM $  ;Fetch second word
41m0161 05021 640706000550400440020000	        FIXM1 $ ;Complete fetch
41m0161 05022 640720005473400440600000	        ACSEL[AC+1] D[MEM] ALU[0-D] DEST[AC MA] SPEC[MA_PC] CYLEN[FIXM+1] $
41m0161                               	                ;Negate low order word and put it in the second AC
41m0161                               	                ;Start next instruction fetch (Note that DEST[MA] is
41m0161                               	                ;really associated with SPEC[MA_PC])
41m0161                               	                ;*** Is FIXM+1 really the right thing???
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

41m0161                               	        ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&AC] DEST[AC]
41m0161 05023 670140011661506010002027	                        COND[-OBUS=0] JUMP[MAIN1] NORM $
41m0161                               	                ;Clear stupid bit 0.
41m0161                               	                ;If the low order part is non-zero, we're done
41m0161 05024 500140001413000441202027	        ACSEL[AC] ALU[AC+1] DEST[AC] SPEC[CRYOV] JUMP[MAIN1] C550 $
41m0161                               	                ;Increment high order word and we're finally done.
41m0161                               	
41m0161                               	;(DMOVEM continued)
41m0161                               	        .PAIR
41m0161                               	 [:. \ 2 + .
41m0162 05026 640700005571000440000000	]DMOVM2:        CYLEN[MEMSTO] ACSEL[AC] D[MEM] DEST[AC] NORM $
41m0162                               	                ;Write it also in the AC
41m0162 05027 640720024433000440000000	        CYLEN[MEMSTO] D[MA] ALU[D+1] DEST[MA] $
41m0162                               	                ;Setup to write second word
41m0162 05030 662104200551400440002032	        ACSEL[AC+1] ALU[AC] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
41m0162                               	                ;Write secord word.
41m0162                               	
41m0162                               	;(DMOVNM continued)
41m0162 05031 640700000113400440000000	DMVNM2: ACSEL[AC+1] ALU[0-AC] DEST[Q] SHORT $
41m0162                               	                ;Negate low order word.
41m0162                               	        ACSEL[AC+1] D[MASK 1] ROT[35.] ALU[-D&Q] DEST[Q]
41m0162 05032 670140010275506010000000	                        COND[-OBUS=0] JUMP[DMVNM4] NORM $
41m0162                               	                ;Clear stupid bit 0.
41m0162                               	                ;If the low order part is non-zero, no change needed to
41m0162                               	                ;high order word.
41m0162                               	        D[AR] ALU[AC+1] DEST[AR STRT-WRT] SPEC[CRYOV]
41m0162 05033 662154000413000441200000	                COND[-MA-AC] JUMP[DMVNM5] NORM $
41m0162                               	                ;Increment high order word and start first store
41m0162 05034 000140005570400440000000	DMVNM3: ACSEL[MA] D[MEM] DEST[AC] JUMP[DMVNM5] $
41m0162                               	                ;Store is to an AC, write into 2901.
41m0162 05035 002144000571000440005034	DMVNM4: DEST[STRT-WRT] COND[MA-AC] JUMP[DMVNM3] $
41m0162                               	                ;Start first store.  Jump if to an AC
41m0162 05036 640720024433000440000000	DMVNM5: D[MA] ALU[D+1] DEST[MA] NORM $
41m0162                               	                ;Finish write.  Note that due to FIXM2, we don't have to
41m0162                               	                ;worry about map faults.
41m0162                               	                ;Prepare for secord write
41m0162 05037 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
41m0162                               	                ;Do final write (low order word into (E+1))
41m0162                               	
41m0162                               	;KAFIX (Opcode 247) continued
41m0162                               	;Positive number to fix
41m0162 05040 030040034171066110000000	KAFIXP: D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
41m0162                               	                ;Extract exponent adjustment factor and do fixing
41m0162 05041 640160001555000440602027	        ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put result into AC and we're done
41m0162                               	;Negative number to fix
41m0162 05042 030040034171066110000000	KAFIXN: D[IR] ROT[27.] MASK[9.] DEST[Q] COND[-OBUS=0] PUSHJ[FIXER] $
41m0162                               	                ;Extract exponent adjustment factor and do fixing
41m0162                               	;;;     ACSEL[AC] D[MASK R] ALU[D/#Q] DEST[AC MA]       ;*** Assembler loses!
41m0162                               	        ACSEL[AC] D[2] MASK[R] ALU[D/#Q] DEST[AC MA]    ;Sigh...
41m0162 05043 640160011775001000602027	                        SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put sign extended result into AC and we're done
41m0162                               	
41m0162                               	;(FIXR continued)
41m0162 05044 511140004571000440000000	FIXR1:  D[MEM] COND[OBUS<0] JUMP[FIXRN] C550 $
41m0162                               	                ;Round different directions
41m0162 05045 640050015435074200006432	        D[CONST 20] ROT[30.] ALU[D+Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

41m0162                               	                ;Positive. Finish making constant 0.5 and add it
41m0162 05046 640700014171000330000000	        D[CONST 33] DEST[Q] SHORT $
41m0162                               	                ;Start making magic constant
41m0162 05047 640154400551000440000000	        ALU[AC] DEST[AR HOLD] JUMP[FIXR2] NORM $
41m0162                               	                ;Setup for FIXER.  Rest is same as KIFIX
41m0162                               	;       ---
41m0162 05050 640050015537074600006432	FIXRN:  D[CONST 60] ROT[30.] ALU[D-Q] DEST[AC AR] PUSHJ[FADSUB] NORM $
41m0162                               	                ;Negative. Finish making constant -0.5 and add it
41m0162 05051 640700014171000330000000	        D[CONST 33] DEST[Q] SHORT $
41m0162                               	                ;Start making magic constant
41m0162 05052 640700014175014020000000	        D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
41m0162                               	                ;Finish making magic constant
41m0162 05053 640054400513000440000000	        ALU[0-AC] DEST[AR HOLD] PUSHJ[FIXER] NORM $
41m0162                               	                ;Setup for FIXER
41m0162 05054 640160001517000440602027	        ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Negate it back again and start next instruction
41m0162                               	;       ---
41m0162                               	;(KIFIX continued)
41m0162 05055 511150004571000440000000	KIFIX1: D[MEM] DEST[AR] COND[OBUS<0] JUMP[KIFIXN] C550 $
41m0162                               	                ;Load up things for FIXER, check for positive mantissa
41m0162 05056 640040014175014020000000	FIXR2:  D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] PUSHJ[FIXER] NORM $
41m0162                               	                ;Finish making magic constant and do fix.
41m0162 05057 640160001555000440602027	        ACSEL[AC] ALU[Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Put result into AC and we're done
41m0162                               	;       ---
41m0162                               	;       ---
41m0162 05060 640700014175014020000000	KIFIXN: D[CONST 2] ROT[6] ALU[DORQ] DEST[Q] SHORT $
41m0162                               	                ;Finish making magic constant
41m0162 05061 640054404473000440000000	        D[MEM] ALU[0-D] DEST[HOLD AR] PUSHJ[FIXER] NORM $
41m0162                               	                ;ABS to both MEM and AR.  Fix the number
41m0162 05062 640160001517000440602027	        ACSEL[AC] ALU[0-Q] DEST[AC MA] SPEC[MA_PC] JUMP[MAIN1] NORM $
41m0162                               	                ;Negate it back again and start next instruction
41m0162                               	
41m0162                               	
41m0162                               	;Fix a number (without sign extension) in MEM, AR=ABS(MEM), Q=magic number
41m0162                               	;(233 for normal fix)
41m0162                               	FIXER:  D[AR] ROT[9] MASK[9] ALU[D-Q] DEST[ROTR Q]
41m0162 05063 511141200137022110000000	                        COND[OBUS<0] JUMP[FIXER2] C550 $
41m0162                               	                ;Calculate number of positions to move
41m0162                               	                ;Jump if we'll be shifting right (n<2^26)
41m0162 05064 640701414435000330000000	        D[CONST 27.] ALU[D+Q] DEST[MASKR] NORM $
41m0162                               	                ;Construct appropriate mask
41m0162 05065 640704404571000330000000	        D[MEM] MASK[27.] DEST[HOLD] NORM $
41m0162                               	                ;Flush exponent, our mask won't reach.
41m0162 05066 511140014477000110000000	        D[CONST 9.] ALU[Q-D] COND[OBUS<0] JUMP[FIXER1] C550 $
41m0162                               	                ;Check for overflow
41m0162                               	;;; Set overflow here.  What kind?  (We can live without it for KAFIX, since it
41m0162                               	;;; never did check, but when KIFIX is done, this will have to be corrected.)
41m0162 05067 640040014555106010006147	        D[CONST 1] ROT[35.] ALU[Q] PUSHJ[QORCRY] NORM $
41m0162                               	                ;Set overflow flag.
41m0162 05070 640701414571000440000000	        D[CONST 44] DEST[MASKR] NORM $
41m0162                               	                ;For those losers who want to see some of the number...
41m0162                               	;Now that we know how much to shift things, do it and return.
41m0162 05071 640300004171201000000000	FIXER1: D[MEM] ROT[R] MASK[R] DEST[Q] NORM POPJ $
41m0162                               	                ;Gee, that was fast.
41m0162                               	;Negative, shift count, the easy case.
41m0162 05072 011141414435000330000000	FIXER2: D[CONST 27.] ALU[D+Q] DEST[MASKR] COND[OBUS<0] JUMP[FIXER3] $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

41m0162                               	                ;Construct appropriate mask.  If !x!<1, return zero
41m0162 05073 640141214435000440005071	        D[CONST 36.] ALU[D+Q] DEST[ROTR] JUMP[FIXER1] NORM $
41m0162                               	                ;Hardware doesn't believe in negative shift counts
41m0162                               	;Number is fractional, i.e. shift would go off the end.  Return zero
41m0162 05074 640301400215000440000000	FIXER3: ALU[0] DEST[Q MASKR] SHORT POPJ $
41m0162                               	                ;Just return zero.  Set mask just in case
41m0162                               	
41m0162                               	.REPEAT XUCODE [
41m0162                               	  .USE[OTHER]
41m0162                               	   ]
41m0162                               	[
41m0162                               	  .USE[OTHER]
41m0162                               	 [ XLIST
41m0162                               	 LIST ]   ];FLTR, continued
41m0162 06576 640700014171000330000000	FLTR1:  D[CONST 33] DEST[Q] SHORT $
41m0162 06577 640700214575014020000000	        D[CONST 2] ROT[6] ALU[DORQ] DEST[IR-ADR] NORM $
41m0162                               	                ;Make magic constant for exponent
41m0162 06600 000040000215000440006464	        ALU[0] DEST[Q] PUSHJ[FPNAR] $
41m0162                               	                ;Clear low order word
41m0162                               	                ;Normalize and round (happens to have same bit on as FxxR)
41m0162                               	                ;Result goes to AC
41m0162 06601 640160000571000440602027	        SPEC[MA_PC] DEST[MA] JUMP[MAIN1] NORM $
41m0162                               	                ;Start next instruction fetch
41m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

42m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

43m0162                               	.REPEAT TYMNET [.DEFINE FOOLIST[] [ LIST ] ]
43m0162                               	[.DEFINE FOOLIST[] [ LIST ] ];;;FOOLIST
43m0162                               	
43m0162       7600	TYMORG = 7600   ;Where to assemble fixed part of TYMNet code.
43m0162                               	
43m0162                               	  .REPEAT OTP [
43m0162                               	TNODIFS = 2     ;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
43m0162                               	TNIRIFS = 4     ;INPUT READY INTERRUPT FF SUBSEL = REQ A.
43m0162                               	TYM.LD = 1      ;MAPF value for loading output register.
43m0162                               	TYM.RD = 0      ;MAPF value for reading input register.
43m0162                               	  ] ;OTP
43m0162                               	
43m0162                               	  .REPEAT NTP [
43m0162                               	TNODIFS = 17    ;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
43m0162                               	TNIRIFS = 16    ;INPUT READY INTERRUPT FF SUBSEL = REQ A.
43m0162                               	TYM.LD = 15     ;MAPF value for loading output register.
43m0162                               	TYM.RD = 5      ;MAPF value for reading input register.
43m0162                               	  ] [
43m0162       17	TNODIFS = 17    ;OUTPUT DONE INTERRUPT FF SUBSEL = REQ B
43m0162       16	TNIRIFS = 16    ;INPUT READY INTERRUPT FF SUBSEL = REQ A.
43m0162       15	TYM.LD = 15     ;MAPF value for loading output register.
43m0162       5	TYM.RD = 5      ;MAPF value for reading input register.
43m0162                               	  ];NTP
43m0162                               	
43m0162                               	.REPEAT TYMNET [
43m0162                               	
43m0162                               	;TYMNET INTERFACE.
43m0162                               	
43m0162                               	;A-MEM USAGE.
43m0162                               	; 0: STANDARD.
43m0162                               	; 1: STATE OF OUTPUT FFS (SEE CFTNET)
43m0162                               	; 2: OUTPUT COROUTINE ADR (LO 6 BITS)
43m0162                               	; 3: INPUT COROUTINE ADR (LO 6 BITS)
43m0162                               	; 4: CURRENT -10 WORD BEING OUTPUT (FOR STATE 1 ONLY)
43m0162                               	; 5: CURRENT -10 WORD BEING ASSEMBLED ON INPUT (STATE 1)
43m0162                               	; 6: IOWD FOR PACKET CURRENTLY BEING READ
43m0162                               	; 7: B0-2, STATE OF MAP BEFORE INT; B3-35, INP REG AT INT START
43m0162                               	
43m0162                               	;MAIN MEMORY LOCATIONS:
43m0162                               	; 2000/ KEY:    0               ;FLAGS
43m0162                               	; 2200/ IRING: BLOCK 200        ;INPUT (TO HOST) RING
43m0162                               	; 2400/ ORING: BLOCK 400        ;OUTPUT (FROM HOST) RING
43m0162                               	; 2005/ HIRP:  0        ;HOST IRING PTR (TAKER)
43m0162                               	; 2006/ BIRP:  0        ;BASE IRING PTR (PUTTER)
43m0162                               	; 2011/ HORP:  0        ;HOST ORING PTR (PUTTER)
43m0162                               	; 2012/ BORP:  0        ;BASE ORING PTR (TAKER)
43m0162                               	
43m0162                               	;DR11C FLAG NAMES.  (FIELD VALUES).
43m0162                               	;THE ACTUAL DEFINITIONS ARE IN CFDEF.SLO
43m0162                               	;TNODIBN=2      ;OUTPUT DONE ROTATE AMOUNT (INPUT) = REQ B.
43m0162                               	;TNIRIBN=3      ;INPUT READY ROTATE AMOUNT (INPUT) = REQ A.
43m0162                               	;TNODOBN=6      ;OUTPUT DONE ROTATE AMOUNT (OUTPUT) = CSR1.
43m0162                               	;TNODOBNPO=7
43m0162                               	;TNIROBN=7      ;INPUT READY ROTATE AMOUNT (OUTPUT) = CSR0.
43m0162                               	;TNIROBNPO=10
43m0162                               	
43m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

43m0162                               	.DEFINE TNOCEC[] [ ;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
43m0162                               	        D[14] ROT[34] MASK[20] DEST[Q] NORM $
43m0162                               	        D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
43m0162                               	        ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
43m0162                               	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0162                               	]
43m0162                               	.DEFINE GBORP[] [
43m0162                               	        D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
43m0162                               	]
43m0162                               	.DEFINE GHORP[] [
43m0162                               	        D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
43m0162                               	]
43m0162                               	.DEFINE GBIRP[] [
43m0162                               	        D[CONST 6] DEST[Q] PUSHJ[TNRCW] NORM $
43m0162                               	]
43m0162                               	.DEFINE GHIRP[] [
43m0162                               	        D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
43m0162                               	]
43m0162                               	
43m0162                               	
43m0162                               	;HERE TO SERVICE INPUT READY OR OUTPUT DONE INTERRUPT BY
43m0162                               	; TYMNET INTERFACE.
43m0162                               	        ;SAVE MAP STATE IN A-MEM[7].0-2 & TURN MAP OFF.
43m0162                               	TNI:    DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
43m0162                               	        D[IR] MASK[3] DEST[AR] MAPF[10] CYLEN[IOB-OUT] $        ;MAPOFF NEEDS MAPF,
43m0162                               	 CYLEN.
43m0162                               	        D[AR] ROT[41] DEST[Q] NORM $
43m0162                               	        D[CONST 6] DEST[DEV-ADR] SPEC[IOB-IN] NORM $ ;BACK TO 6 FOR TN
43m0162                               	
43m0162                               	        ;SAVE INPUT REG IN A-MEM[7].
43m0162                               	        MAPF[TYM.RD] D[IOD] MASK[41] DEST[AR] CYLEN[IOB-IN] $
43m0162                               	        D[AR] ALU[DORQ] DEST[Q 7] DEST-A-MEM NORM $
43m0162                               	        D[CONST 1] ROT[TNODIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI1] C550 $
43m0162                               	        D[CONST (TYMORG / 100)] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
43m0162                               	        D[12] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNODIFS] C550 $   ;OUTPUT DONE.
43m0162                               	        D[12] ALU[DORQ] SDISP C550 $    ;OUTPUT DONE.
43m0162                               	TNI0:   D[17] DEST[Q] NORM $    ;RESTORE INP REG
43m0162                               	TNI1:   D[CONST 1] ROT[TNIRIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI2] C550 $
43m0162                               	        D[17] ROT[34] MASK[20] DEST[Q] PUSHJ[BITREV] NORM $
43m0162                               	        D[CONST (TYMORG / 100)] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
43m0162                               	        D[13] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNIRIFS] CYLEN[C500] $    ;INPUT
43m0162                               	 READY.
43m0162                               	        D[13] ALU[DORQ] SDISP CYLEN[C500] $     ;INPUT READY.
43m0162                               	TNI2:   D[17] ROT[3] MASK[3] DEST[IOD] NORM $
43m0162                               	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] JUMP[MPOFF1] NORM $  ;ENDS UP AT MAIN.
43m0162                               	
43m0162                               	;VARIOUS SUBROUTINES.
43m0162                               	;Q LOADED WITH 16. BIT WORD TO SEND, SHIFTED LEFT BY 8.
43m0162                               	TNSEND: ALU[Q] DEST[AR] NORM $
43m0162                               	        D[AR] ROT[34] DEST[Q] PUSHJ[BITREV] NORM $
43m0162                               	        D[AR] ROT[8] DEST[Q] SHORT $
43m0162                               	        D[MASK 16.] ROT[8] ALU[D&Q] DEST[AR] NORM $
43m0162                               	        D[MASK 8] DEST[Q] PUSHJ[DEV6ST1] NORM $
43m0162                               	        ;CLEAR THEN SET INPUT READY FLAG TO DR11C.
43m0162                               	        D[MASK 43] ROT[TNIROBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
43m0162                               	        D[CONST 1] ROT[TNIROBN] DEST[AR] NORM JUMP[DEV6ST2] $
43m0162                               	;NO OUTPUT TO DO.  DO NOT CHANGE TNIROBN, SET A-MEM FLAG FOR
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

43m0162                               	; CLOCK ROUTINE.
43m0162                               	TNORE:  ALU[-1] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0162                               	;READ WORD FROM BASE-HOST COMMUNICATION AREA, LOCATION 20XX;
43m0162                               	; Q HAS XX.
43m0162                               	TNRCW:  D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] NORM $
43m0162                               	        FIXM0 POPJ $
43m0162                               	
43m0162                               	;HERE WHEN INPUT RING FULL.  SET CLOCK FLAG AND RETURN WITHOUT
43m0162                               	; SETTING TNODOBN.
43m0162                               	TNIRF:  ALU[-1] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
43m0162                               	;CLEAR THEN SET TNODOBN.
43m0162                               	TNCASODOF:
43m0162                               	        D[MASK 43] ROT[TNODOBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
43m0162                               	        D[CONST 1] ROT[TNODOBN] DEST[AR] NORM JUMP[DEV6ST2] $
43m0162                               	
43m0162                               	.REPEAT SLOWTAPE [
43m0162                               	
43m0162                               	;REVERSE RIGHTMOST 16. BITS IN Q.  LEAVES RESULT IN Q&AR.
43m0162                               	; CLOBBERS IR, MEM.
43m0162                               	BITREV: ALU[Q] DEST[AR] SHORT $
43m0162                               	        D[CONST 17] LLOAD NORM $
43m0162                               	        D[AR] ROT[23] DEST[AR] SHORT $
43m0162                               	        ALU[0] DEST[Q HOLD] NORM $
43m0162                               	        D[CONST 1] DEST[IR-ALL] NORM $
43m0162                               	BRLP:   D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[BRLP1] C550 $
43m0162                               	        D[IR] ALU[QORD] DEST[Q] SHORT $
43m0162                               	BRLP1:  D[IR] ROT[1] DEST[IR-ALL] LOOP[BRLP] NORM $
43m0162                               	        ALU[Q] DEST[AR] POPJ NORM $
43m0162                               	
43m0162                               	 ] ;SLOWTAPE
43m0162                               	
43m0162                               	.REPEAT 1 - SLOWTAPE [
43m0162                               	
43m0162                               	BITREV: D[MASK 20] ALU[D&Q] DEST[Q AR] NORM POPJ $
43m0162                               	
43m0162                               	 ]
43m0162                               	
43m0162                               	        .ORG[TYMORG]    ;$*$*$* Dispatch mechanism is a real loser here.  We
43m0162                               	                        ;       won't be able to flush this one until
43m0162                               	                        ;       references are made relative.  Essentially,
43m0162                               	                        ;       [xx & 77] gets replaced by [. - TNOC0] and
43m0162                               	                        ;       TNOC0 is kept in a A-MEM for speed.  Then,
43m0162                               	                        ;       instead of D[CONST 71] ROT[6] ALU[DORQ], one
43m0162                               	                        ;       uses D[10 + x] ALU[D+Q] to do the dispatch.
43m0162                               	;********** OUTPUT DONE CO-ROUTINE.
43m0162                               	;A-MEM[4] = ROTATED -10 WORD WITH -11 WORD JUST SENT IN 12-27.
43m0162                               	;STATE 0: FETCH NEXT -10 WORD OR QUIT IF RING EMPTY.
43m0162                               	TNOC0:  GBORP
43m0162                               	        D[MEM] DEST[AR] NORM $
43m0162                               	TNOC0A: GHORP
43m0162                               	        D[AR] DEST[Q] NORM $
43m0162                               	        D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNORE] C600 $
43m0162                               	        D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
43m0162                               	        FIXM0 $
43m0162                               	        D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
43m0162                               	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0162                               	;CLOCK RESTARTS COROUTINE HERE.
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

43m0162                               	TNOC2:  TNOCEC
43m0162                               	;STATE 1: SEND LOW ORDER HALF OF -10 WORD.
43m0162                               	        D[14] ROT[20] DEST[Q] NORM $
43m0162                               	        ALU[Q] DEST[4] PUSHJ[TNSEND] DEST-A-MEM NORM $
43m0162                               	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0162                               	        TNOCEC
43m0162                               	        GBORP
43m0162                               	        D[MEM] ALU[D+1] DEST[Q] NORM $
43m0162                               	        D[MASK 8] ALU[D&Q] DEST[AR MEMSTO] JUMP[TNOC0A] CYLEN[MEMSTO] $
43m0162                               	
43m0162                               	;********** INPUT READY CO-ROUTINE.
43m0162                               	; A-MEM[5] HAS CURRENT INPUT WORD BEING ASSEMBLED.
43m0162                               	;STATE 0: AWAITING START OF NEXT MESSAGE.
43m0162                               	
43m0162                               	TNIC0:  D[CONST 2] ROT[9] DEST[MA] NORM $ ;ADDRESS OF KEY IN MAIN MEM.
43m0162                               	        ALU[0] DEST[MEMSTO] NORM $ ;CLEAR KEY AT START OF EVERY MESSAGE
43m0162                               	        D[AR] DEST[Q 5] DEST-A-MEM NORM $
43m0162                               	        D[CONST 1] ROT[17] ALU[D&Q] COND[OBUS=0] JUMP[TNIC0A] C550 $
43m0162                               	;DATA PACKET MESSAGE.
43m0162                               	        D[AR] ROT[34] MASK[7] DEST[Q] SHORT $
43m0162                               	        D[CONST 5] ALU[D+Q] DEST[AR] SHORT $
43m0162                               	        D[AR] ROT[42] MASK[18.] DEST[6] DEST-A-MEM NORM $
43m0162                               	        D[15] DEST[AR] SHORT $
43m0162                               	;READ MSG.  A-MEM[6]:=# -10 WORDS IN MESSAGE.
43m0162                               	; AR:=FIRST -11 WORD IN MESSAGE.
43m0162                               	TNICRM:
43m0162                               	        GBIRP
43m0162                               	        D[16] ROT[18.] ALU[0-D] DEST[Q] NORM $
43m0162                               	        D[MEM] MASK[18.] ALU[QORD] DEST[6] DEST-A-MEM NORM $
43m0162                               	;STATE 1: HO 16 BITS OF WORD ARRIVES.
43m0162                               	TNIC1:  D[AR] ROT[24] DEST[5] DEST-A-MEM NORM $
43m0162                               	        GHIRP
43m0162                               	        D[16] ALU[D+1] DEST[Q] NORM $
43m0162                               	        D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
43m0162                               	        D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNIRF] C600 $
43m0162                               	        PUSHJ[TNCASODOF] NORM $
43m0162                               	        D[CONST[. & 77 + 1]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
43m0162                               	;STATE 2: LO 16 BITS OF WORD ARRIVES.
43m0162                               	; ALSO STARTED HERE BY CLOCK ROUTINE.
43m0162                               	TNIC2:  D[16] MASK[7] DEST[Q] NORM $
43m0162                               	        D[CONST 22] ROT[6] ALU[D+Q] DEST[MA] NORM $
43m0162                               	        D[15] DEST[Q] NORM $
43m0162                               	        D[AR] ROT[4] ALU[DORQ] DEST[MEMSTO] NORM $
43m0162                               	        PUSHJ[TNCASODOF] NORM $
43m0162                               	        D[16] ALU[D+1] DEST[Q] CYLEN[MEMSTO] $
43m0162                               	        D[CONST 1] ROT[18.] ALU[D+Q] DEST[6] DEST-A-MEM COND[-OBUS<0] JUMP[TNICDN] C600 $
43m0162                               	
43m0162                               	        D[CONST[77 & TNIC1]] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
43m0162                               	
43m0162                               	 .RELOC
43m0162                               	
43m0162                               	TNICDN: D[CONST 6] DEST[Q] SHORT $
43m0162                               	        D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] SHORT $
43m0162                               	        D[16] MASK[7] DEST[MEMSTO] NORM $
43m0162                               	        D[CONST[TNIC0 & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] CYLEN[MEMSTO] $
43m0162                               	;1 WD OR 2 WD OR ESCAPE MESSAGE.
43m0162                               	TNIC0A: D[CONST 1] ROT[16] ALU[D&Q] COND[-OBUS=0] JUMP[TNIC0B] C550 $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

43m0162                               	;ONE WORD PACKET.
43m0162                               	        D[CONST 1] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
43m0162                               	TNIC0B: D[CONST 1] ROT[16] ALU[D#Q] DEST[Q AR] SHORT $
43m0162                               	        D[MASK 6] ROT[8] ALU[D&Q] DEST[Q] SHORT $
43m0162                               	        D[MASK 6] ROT[8] ALU[D#Q] COND[OBUS=0] JUMP[TNIC0C] C550 $
43m0162                               	;2 WORD PACKET.
43m0162                               	        D[CONST 2] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
43m0162                               	;ESCAPE SEQUENCE.  BETTER NOT HAPPEN.
43m0162                               	TNIC0C: JUMP[.] $
43m0162                               	
43m0162                               	;CLOCK ROUTINE, CALLED EVERY TICK OF 60HZ CLOCK.
43m0162                               	
43m0162                               	TYMCLK: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPOFF] SPEC[IOB-IN] NORM $
43m0162                               	        MAPF[10] CYLEN[IOB-OUT] D[CONST 6] DEST[DEV-ADR] $
43m0162                               	        D[IR] DEST[7] DEST-A-MEM NORM $
43m0162                               	        D[13] COND[OBUS<0] PUSHJ[TNSI] C550 $
43m0162                               	        D[12] COND[OBUS<0] PUSHJ[TNSO] C550 $
43m0162                               	        D[17] MASK[3] DEST[IOD] NORM $
43m0162                               	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
43m0162                               	        MAPF[10] CYLEN[IOB-OUT] $
43m0162                               	        D[CONST 6] DEST[DEV-ADR] POPJ NORM $
43m0162                               	
43m0162                               	TNSI:   GHIRP
43m0162                               	        D[16] ALU[D+1] DEST[Q] NORM $
43m0162                               	        D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
43m0162                               	        D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
43m0162                               	        D[CONST[TNIC2 & 77]] DEST[3] DEST-A-MEM JUMP[TNCASODOF] NORM $
43m0162                               	TNSO:   GBORP
43m0162                               	        D[MEM] DEST[AR] NORM $
43m0162                               	        GHORP
43m0162                               	        D[AR] DEST[Q] NORM $
43m0162                               	        D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
43m0162                               	        D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
43m0162                               	        FIXM0 $
43m0162                               	        D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
43m0162                               	        D[CONST[TNOC2 & 77]] DEST[2] POPJ DEST-A-MEM NORM $
43m0162                               	
43m0162                               	;RESET TYMNET INTERFACE.  OUTPUT COROUTINE GOES INTO NULL STATE.
43m0162                               	; INPUT COROUTINE GOES INTO STATE 0, INTRPTS GET ENABLED.
43m0162                               	TYMRS1: D[CONST 3] ROT[2] DEST[AR] CYLEN[IOB-OUT] SPEC[IOB-OUT] $
43m0162                               	         ;GET CONST TO ENB. INTRPTS; IOB-OUT CLEARS FLAGS.
43m0162                               	TYMRS2: MAPF[TNODIFS] START-OUT C600 $
43m0162                               	        MAPF[TNIRIFS] D[MASK 2] ALU[NOTD] ROT[2] DEST[Q] PUSHJ[DEV6ST1] C600 $
43m0162                               	        ALU[-1] DEST[2] DEST-A-MEM NORM $
43m0162                               	        D[CONST[TNIC0 & 77]] DEST[3] POPJ DEST-A-MEM NORM $
43m0162                               	
43m0162                               	TYMAREA:        ;SAVE LOCATION
43m0162                               	
43m0162                               	        .OPCODE[744]      ;RESET TYMNET
43m0162                               	
43m0162                               	        NOP $
43m0162                               	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNRESET] $
43m0162                               	
43m0162                               	        NOP $
43m0162                               	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNOUT] $
43m0162                               	
43m0162                               	        NOP $
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

43m0162                               	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNIN] $
43m0162                               	
43m0162                               	        NOP $   ;AS NEAR AS I CAN TELL, THIS ONE (747) ISN'T USED. - PG
43m0162                               	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[F5DIAG] $
43m0162                               	
43m0162                               	        .USE[TYMAREA]   ;RETURN TO MAIN CODE
43m0162                               	
43m0162                               	TYMNRESET:  SPEC[IOB-OUT] D[MA] ROT[2] DEST[AR] NORM PUSHJ[TYMRS2] $
43m0162                               	                ;RESET CO-ROUTINES, ENB. INTRPTS FROM EFF. ADDR. 34,35
43m0162                               	        JUMP[MAIN] $
43m0162                               	
43m0162                               	TYMNOUT: SPEC[IOB-OUT] NORM $  ;CLEAR "RDY FOR DATA" FROM PDP11
43m0162                               	        MAPF[TNODIFS] D[MA] ROT[8.] DEST[Q] NORM PUSHJ[TNSEND] $
43m0162                               	          ;SEND EFF. ADDR. 20-35 TO PDP11.
43m0162                               	        JUMP[MAIN] $
43m0162                               	
43m0162                               	TYMNIN: D[CONST 25.] LLOAD NORM $
43m0162                               	        NORM LOOP[.] $  ;GIVE DMA DEVICES SOME MEMORY TIME.
43m0162                               	        SPEC[IOB-IN] NORM $
43m0162                               	        MAPF[TYM.RD] D[IOD] ROT[27. + 1] DEST[AR] C800 $
43m0162                               	           ;Align input word with 16 data bits at RIGHT end.
43m0162                               	        D[AR] ROT[4] C550 COND[-OBUS<0] JUMP[. + 2] $
43m0162                               	           ;Don't clear "INPUT RDY" flag unless it's on.
43m0162                               	        SPEC[IOB-OUT] SHORT $  ;IT'S ON.
43m0162                               	        MAPF[TNIRIFS] D[AR] DEST[MEMSTO] MEMST $
43m0162                               	
43m0162                               	F5DIAG: FIXM1 $
43m0162                               	        D[IR] ALU[NOTD] DEST[AR] NORM $
43m0162                               	                ;AR=-IR
43m0162                               	        D[AR] ROT[13.] MASK[2] DEST[AR] NORM $
43m0162                               	                ;AR=-AC MASK 2
43m0162                               	        D[AR] ROT[6] DEST[Q] NORM $
43m0162                               	                ;Q=INVERTED 2 LSB'S OF AC SHIFTED INTO STROBES
43m0162                               	        D[MEM] ROT[8.] ALU[DORQ] DEST[HOLD] NORM $
43m0162                               	                ;DATA SHIFTED WITH STROBES INSERTED
43m0162                               	        D[MEM] DEST[AR] NORM $
43m0162                               	                ;DATA=(E) (LSH 8) (STB ACTIVE LOW)
43m0162                               	        D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
43m0162                               	                ;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
43m0162                               	        D[MASK 2] ROT[6] DEST[Q] NORM $
43m0162                               	                ;MASK TO FORCE STB'S HIGH
43m0162                               	        D[MEM] ALU[DORQ] DEST[AR] NORM $
43m0162                               	                ;DATA=(E) (LSH 8) (STB'S FORCED INACTIVE HIGH)
43m0162                               	        D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
43m0162                               	                ;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
43m0162                               	        ALU[0] DEST[DEV-ADR] JUMP[MAIN] $
43m0162                               	
43m0162                               	
43m0162                               	];[
43m0162                               	
43m0162                               	;TYMNET INTERFACE.
43m0162                               	
43m0162                               	;A-MEM USAGE.
43m0162                               	; 0: STANDARD.
43m0162                               	; 1: STATE OF OUTPUT FFS (SEE CFTNET)
43m0162                               	; 2: OUTPUT COROUTINE ADR (LO 6 BITS)
43m0162                               	; 3: INPUT COROUTINE ADR (LO 6 BITS)
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

43m0162                               	; 4: CURRENT -10 WORD BEING OUTPUT (FOR STATE 1 ONLY)
43m0162                               	; 5: CURRENT -10 WORD BEING ASSEMBLED ON INPUT (STATE 1)
43m0162                               	; 6: IOWD FOR PACKET CURRENTLY BEING READ
43m0162                               	; 7: B0-2, STATE OF MAP BEFORE INT; B3-35, INP REG AT INT START
43m0162                               	
43m0162                               	;MAIN MEMORY LOCATIONS:
43m0162                               	; 2000/ KEY:    0               ;FLAGS
43m0162                               	; 2200/ IRING: BLOCK 200        ;INPUT (TO HOST) RING
43m0162                               	; 2400/ ORING: BLOCK 400        ;OUTPUT (FROM HOST) RING
43m0162                               	; 2005/ HIRP:  0        ;HOST IRING PTR (TAKER)
43m0162                               	; 2006/ BIRP:  0        ;BASE IRING PTR (PUTTER)
43m0162                               	; 2011/ HORP:  0        ;HOST ORING PTR (PUTTER)
43m0162                               	; 2012/ BORP:  0        ;BASE ORING PTR (TAKER)
43m0162                               	
43m0162                               	;DR11C FLAG NAMES.  (FIELD VALUES).
43m0162                               	;THE ACTUAL DEFINITIONS ARE IN CFDEF.SLO
43m0162                               	;TNODIBN=2      ;OUTPUT DONE ROTATE AMOUNT (INPUT) = REQ B.
43m0162                               	;TNIRIBN=3      ;INPUT READY ROTATE AMOUNT (INPUT) = REQ A.
43m0162                               	;TNODOBN=6      ;OUTPUT DONE ROTATE AMOUNT (OUTPUT) = CSR1.
43m0162                               	;TNODOBNPO=7
43m0162                               	;TNIROBN=7      ;INPUT READY ROTATE AMOUNT (OUTPUT) = CSR0.
43m0162                               	;TNIROBNPO=10
43m0162                               	
43m0162                               	
43m0162                               	.DEFINE TNOCEC[] [ ;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
43m0162                               	        D[14] ROT[34] MASK[20] DEST[Q] NORM $
43m0162                               	        D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
43m0162                               	        ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
43m0162                               	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0162                               	]
43m0162                               	.DEFINE GBORP[] [
43m0162                               	        D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
43m0162                               	]
43m0162                               	.DEFINE GHORP[] [
43m0162                               	        D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
43m0162                               	]
43m0162                               	.DEFINE GBIRP[] [
43m0162                               	        D[CONST 6] DEST[Q] PUSHJ[TNRCW] NORM $
43m0162                               	]
43m0162                               	.DEFINE GHIRP[] [
43m0162                               	        D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
43m0162                               	]
43m0162                               	
43m0162                               	
43m0162                               	;HERE TO SERVICE INPUT READY OR OUTPUT DONE INTERRUPT BY
43m0162                               	; TYMNET INTERFACE.
43m0162                               	        ;SAVE MAP STATE IN A-MEM[7].0-2 & TURN MAP OFF.
43m0162 06602 640042400571000443405402	TNI:    DEST[CLR-DEV-FROM-INTR] SPEC[IOB-IN] NORM PUSHJ[MAPOFF] $
43m0162 06603 440710034571000030100000	        D[IR] MASK[3] DEST[AR] MAPF[10] CYLEN[IOB-OUT] $        ;MAPOFF NEEDS MAPF,
43m0162                               	 CYLEN.
43m0162 06604 640700000171102440000000	        D[AR] ROT[41] DEST[Q] NORM $
43m0162 06605 640701614571000063400000	        D[CONST 6] DEST[DEV-ADR] SPEC[IOB-IN] NORM $ ;BACK TO 6 FOR TN
43m0162                               	
43m0162                               	        ;SAVE INPUT REG IN A-MEM[7].
43m0162 06606 140710030571000410050000	        MAPF[TYM.RD] D[IOD] MASK[41] DEST[AR] CYLEN[IOB-IN] $
43m0162 06607 640701600175000443000000	        D[AR] ALU[DORQ] DEST[Q 7] DEST-A-MEM NORM $
43m0162 06610 510140014635004010000000	        D[CONST 1] ROT[TNODIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI1] C550 $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

43m0162 06611 440700014171014763600000	        D[CONST (TYMORG / 100)] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
43m0162 06612 511140050575000440176614	        D[12] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNODIFS] C550 $   ;OUTPUT DONE.
43m0162 06613 500540050575000440000000	        D[12] ALU[DORQ] SDISP C550 $    ;OUTPUT DONE.
43m0162 06614 640700074171000440000000	TNI0:   D[17] DEST[Q] NORM $    ;RESTORE INP REG
43m0162 06615 510140014635006010000000	TNI1:   D[CONST 1] ROT[TNIRIBN] ALU[D&Q] COND[OBUS=0] JUMP[TNI2] C550 $
43m0162 06616 640040074171070200000000	        D[17] ROT[34] MASK[20] DEST[Q] PUSHJ[BITREV] NORM $
43m0162 06617 440700014171014763600000	        D[CONST (TYMORG / 100)] ROT[6] DEST[Q] SPEC[IOB-OUT] CYLEN[IOB-OUT] $
43m0162 06620 551140054575000440166622	        D[13] ALU[DORQ] COND[OBUS<0] JUMP[. + 2] MAPF[TNIRIFS] CYLEN[C500] $    ;INPUT
43m0162                               	 READY.
43m0162 06621 540540054575000440000000	        D[13] ALU[DORQ] SDISP CYLEN[C500] $     ;INPUT READY.
43m0162 06622 640702274571006030000000	TNI2:   D[17] ROT[3] MASK[3] DEST[IOD] NORM $
43m0162 06623 640141600615000443605401	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] JUMP[MPOFF1] NORM $  ;ENDS UP AT MAIN.
43m0162                               	
43m0162                               	;VARIOUS SUBROUTINES.
43m0162                               	;Q LOADED WITH 16. BIT WORD TO SEND, SHIFTED LEFT BY 8.
43m0162 06624 640710000555000440000000	TNSEND: ALU[Q] DEST[AR] NORM $
43m0162 06625 640040000171070440000000	        D[AR] ROT[34] DEST[Q] PUSHJ[BITREV] NORM $
43m0162 06626 640700000171020440000000	        D[AR] ROT[8] DEST[Q] SHORT $
43m0162 06627 640710010635020200000000	        D[MASK 16.] ROT[8] ALU[D&Q] DEST[AR] NORM $
43m0162 06630 640040010171000100000000	        D[MASK 8] DEST[Q] PUSHJ[DEV6ST1] NORM $
43m0162                               	        ;CLEAR THEN SET INPUT READY FLAG TO DR11C.
43m0162 06631 640040010171020430000000	        D[MASK 43] ROT[TNIROBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
43m0162 06632 640150014571016010000000	        D[CONST 1] ROT[TNIROBN] DEST[AR] NORM JUMP[DEV6ST2] $
43m0162                               	;NO OUTPUT TO DO.  DO NOT CHANGE TNIROBN, SET A-MEM FLAG FOR
43m0162                               	; CLOCK ROUTINE.
43m0162 06633 640140400741000443006614	TNORE:  ALU[-1] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0162                               	;READ WORD FROM BASE-HOST COMMUNICATION AREA, LOCATION 20XX;
43m0162                               	; Q HAS XX.
43m0162 06634 640720014575014200000000	TNRCW:  D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] NORM $
43m0162 06635 640306000550400440000000	        FIXM0 POPJ $
43m0162                               	
43m0162                               	;HERE WHEN INPUT RING FULL.  SET CLOCK FLAG AND RETURN WITHOUT
43m0162                               	; SETTING TNODOBN.
43m0162 06636 640140600741000443006622	TNIRF:  ALU[-1] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
43m0162                               	;CLEAR THEN SET TNODOBN.
43m0162                               	TNCASODOF:
43m0162 06637 640040010171016430000000	        D[MASK 43] ROT[TNODOBNPO] DEST[Q] PUSHJ[DEV6CL] NORM $
43m0162 06640 640150014571014010000000	        D[CONST 1] ROT[TNODOBN] DEST[AR] NORM JUMP[DEV6ST2] $
43m0162                               	
43m0162                               	.REPEAT SLOWTAPE [
43m0162                               	
43m0162                               	;REVERSE RIGHTMOST 16. BITS IN Q.  LEAVES RESULT IN Q&AR.
43m0162                               	; CLOBBERS IR, MEM.
43m0162                               	BITREV: ALU[Q] DEST[AR] SHORT $
43m0162                               	        D[CONST 17] LLOAD NORM $
43m0162                               	        D[AR] ROT[23] DEST[AR] SHORT $
43m0162                               	        ALU[0] DEST[Q HOLD] NORM $
43m0162                               	        D[CONST 1] DEST[IR-ALL] NORM $
43m0162                               	BRLP:   D[AR] ROT[1] DEST[AR] COND[-OBUS<0] JUMP[BRLP1] C550 $
43m0162                               	        D[IR] ALU[QORD] DEST[Q] SHORT $
43m0162                               	BRLP1:  D[IR] ROT[1] DEST[IR-ALL] LOOP[BRLP] NORM $
43m0162                               	        ALU[Q] DEST[AR] POPJ NORM $
43m0162                               	
43m0162                               	 ] ;SLOWTAPE
43m0162                               	
43m0162                               	.REPEAT 1 - SLOWTAPE [
43m0162                               	
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

43m0162                               	BITREV: D[MASK 20] ALU[D&Q] DEST[Q AR] NORM POPJ $
43m0162                               	
43m0162                               	 ]
43m0162                               	[
43m0162                               	
43m0162 06641 640310010235000200000000	BITREV: D[MASK 20] ALU[D&Q] DEST[Q AR] NORM POPJ $
43m0162                               	
43m0162                               	 ]
43m0162                               	        .ORG[TYMORG]     [ XLIST
43m0162                               	 LIST ];$*$*$* Dispatch mechanism is a real loser here.  We
43m0162                               	                        ;       won't be able to flush this one until
43m0162                               	                        ;       references are made relative.  Essentially,
43m0162                               	                        ;       [xx & 77] gets replaced by [. - TNOC0] and
43m0162                               	                        ;       TNOC0 is kept in a A-MEM for speed.  Then,
43m0162                               	                        ;       instead of D[CONST 71] ROT[6] ALU[DORQ], one
43m0162                               	                        ;       uses D[10 + x] ALU[D+Q] to do the dispatch.
43m0162                               	;********** OUTPUT DONE CO-ROUTINE.
43m0162                               	;A-MEM[4] = ROTATED -10 WORD WITH -11 WORD JUST SENT IN 12-27.
43m0162                               	;STATE 0: FETCH NEXT -10 WORD OR QUIT IF RING EMPTY.
43m0162                               	TNOC0:  GBORP
43m0162                               	 [
43m0162 07600 640040014171000120006634	        D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
43m0163 07601 640710004571000440000000	]       D[MEM] DEST[AR] NORM $
43m0163                               	TNOC0A: GHORP
43m0163                               	 [
43m0163 07602 640040014171000110006634	        D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
43m0164 07603 640700000171000440000000	]       D[AR] DEST[Q] NORM $
43m0164 07604 450140004537000440006633	        D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNORE] C600 $
43m0164 07605 640720014435014240000000	        D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
43m0164 07606 640706000550400440000000	        FIXM0 $
43m0164 07607 640041004171060443006624	        D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
43m0164 07610 640140414571000113006614	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0164                               	;CLOCK RESTARTS COROUTINE HERE.
43m0164                               	TNOC2:  TNOCEC
43m0164                               	 [ ;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
43m0164 07611 640700060171070200000000	        D[14] ROT[34] MASK[20] DEST[Q] NORM $
43m0164 07612 530140010735000200007615	        D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
43m0164 07613 640040000215000440006624	        ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
43m0164 07614 640140414571000153006614	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0165                               	];STATE 1: SEND LOW ORDER HALF OF -10 WORD.
43m0165 07615 640700060171040440000000	        D[14] ROT[20] DEST[Q] NORM $
43m0165 07616 640041000555000443006624	        ALU[Q] DEST[4] PUSHJ[TNSEND] DEST-A-MEM NORM $
43m0165 07617 640140414571000203006614	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0165                               	        TNOCEC
43m0165                               	 [ ;SEND 0 BYTE IF ESCAPE WORD (-1) JUST SENT.
43m0165 07620 640700060171070200000000	        D[14] ROT[34] MASK[20] DEST[Q] NORM $
43m0165 07621 530140010735000200007624	        D[MASK 20] ALU[D#Q] COND[-OBUS=0] JUMP[. + 3] C550 $
43m0165 07622 640040000215000440006624	        ALU[0] DEST[Q] PUSHJ[TNSEND] NORM $
43m0165 07623 640140414571000243006614	        D[CONST[. & 77 + 1]] DEST[2] DEST-A-MEM JUMP[TNI0] NORM $
43m0166                               	]       GBORP
43m0166                               	 [
43m0166 07624 640040014171000120006634	        D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
43m0167 07625 640700004033000440000000	]       D[MEM] ALU[D+1] DEST[Q] NORM $
43m0167 07626 640154210635000100007602	        D[MASK 8] ALU[D&Q] DEST[AR MEMSTO] JUMP[TNOC0A] CYLEN[MEMSTO] $
43m0167                               	
43m0167                               	;********** INPUT READY CO-ROUTINE.
43m0167                               	; A-MEM[5] HAS CURRENT INPUT WORD BEING ASSEMBLED.
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

43m0167                               	;STATE 0: AWAITING START OF NEXT MESSAGE.
43m0167                               	
43m0167 07627 640720014571022020000000	TNIC0:  D[CONST 2] ROT[9] DEST[MA] NORM $ ;ADDRESS OF KEY IN MAIN MEM.
43m0167 07630 640704200615000440000000	        ALU[0] DEST[MEMSTO] NORM $ ;CLEAR KEY AT START OF EVERY MESSAGE
43m0167 07631 640701200171000443000000	        D[AR] DEST[Q 5] DEST-A-MEM NORM $
43m0167 07632 510140014635036010000000	        D[CONST 1] ROT[17] ALU[D&Q] COND[OBUS=0] JUMP[TNIC0A] C550 $
43m0167                               	;DATA PACKET MESSAGE.
43m0167 07633 640700000171070070000000	        D[AR] ROT[34] MASK[7] DEST[Q] SHORT $
43m0167 07634 640710014435000050000000	        D[CONST 5] ALU[D+Q] DEST[AR] SHORT $
43m0167 07635 640701400571104223000000	        D[AR] ROT[42] MASK[18.] DEST[6] DEST-A-MEM NORM $
43m0167 07636 640710064571000440000000	        D[15] DEST[AR] SHORT $
43m0167                               	;READ MSG.  A-MEM[6]:=# -10 WORDS IN MESSAGE.
43m0167                               	; AR:=FIRST -11 WORD IN MESSAGE.
43m0167                               	TNICRM:
43m0167                               	        GBIRP
43m0167                               	 [
43m0167 07637 640040014171000060006634	        D[CONST 6] DEST[Q] PUSHJ[TNRCW] NORM $
43m0168 07640 640700070073044440000000	]       D[16] ROT[18.] ALU[0-D] DEST[Q] NORM $
43m0168 07641 640701404575000223000000	        D[MEM] MASK[18.] ALU[QORD] DEST[6] DEST-A-MEM NORM $
43m0168                               	;STATE 1: HO 16 BITS OF WORD ARRIVES.
43m0168 07642 640701200571050443000000	TNIC1:  D[AR] ROT[24] DEST[5] DEST-A-MEM NORM $
43m0168                               	        GHIRP
43m0168                               	 [
43m0168 07643 640040014171000050006634	        D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
43m0169 07644 640700070033000440000000	]       D[16] ALU[D+1] DEST[Q] NORM $
43m0169 07645 640700010235000070000000	        D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
43m0169 07646 450140004537000440006636	        D[MEM] ALU[D-Q] COND[OBUS=0] JUMP[TNIRF] C600 $
43m0169 07647 640040000571000440006637	        PUSHJ[TNCASODOF] NORM $
43m0169 07650 640140614571000513006622	        D[CONST[. & 77 + 1]] DEST[3] DEST-A-MEM JUMP[TNI2] NORM $
43m0169                               	;STATE 2: LO 16 BITS OF WORD ARRIVES.
43m0169                               	; ALSO STARTED HERE BY CLOCK ROUTINE.
43m0169 07651 640700070171000070000000	TNIC2:  D[16] MASK[7] DEST[Q] NORM $
43m0169 07652 640720014435014220000000	        D[CONST 22] ROT[6] ALU[D+Q] DEST[MA] NORM $
43m0169 07653 640700064171000440000000	        D[15] DEST[Q] NORM $
43m0169 07654 640704200575010440000000	        D[AR] ROT[4] ALU[DORQ] DEST[MEMSTO] NORM $
43m0169 07655 640040000571000440006637	        PUSHJ[TNCASODOF] NORM $
43m0169 07656 640700070033000440000000	        D[16] ALU[D+1] DEST[Q] CYLEN[MEMSTO] $
43m0169 07657 471141414435044013000000	        D[CONST 1] ROT[18.] ALU[D+Q] DEST[6] DEST-A-MEM COND[-OBUS<0] JUMP[TNICDN] C600 $
43m0169                               	
43m0169 07660 640140614571000423006622	        D[CONST[77 & TNIC1]] DEST[3] JUMP[TNI2] DEST-A-MEM NORM $
43m0169                               	
43m0169                               	 .RELOC
43m0169                               	 [.USE[OTHER]
43m0169                               	 [ XLIST
43m0170                               	 LIST ]]
43m0170 06642 640700014171000060000000	TNICDN: D[CONST 6] DEST[Q] SHORT $
43m0170 06643 640720014575014200000000	        D[CONST 20] ROT[6] ALU[DORQ] DEST[MA] SHORT $
43m0170 06644 640704270571000070000000	        D[16] MASK[7] DEST[MEMSTO] NORM $
43m0170 06645 640140614571000273006622	        D[CONST[TNIC0 & 77]] DEST[3] DEST-A-MEM JUMP[TNI2] CYLEN[MEMSTO] $
43m0170                               	;1 WD OR 2 WD OR ESCAPE MESSAGE.
43m0170 06646 530140014635034010000000	TNIC0A: D[CONST 1] ROT[16] ALU[D&Q] COND[-OBUS=0] JUMP[TNIC0B] C550 $
43m0170                               	;ONE WORD PACKET.
43m0170 06647 640141414571000013007637	        D[CONST 1] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
43m0170 06650 640710014335034010000000	TNIC0B: D[CONST 1] ROT[16] ALU[D#Q] DEST[Q AR] SHORT $
43m0170 06651 640700010235020060000000	        D[MASK 6] ROT[8] ALU[D&Q] DEST[Q] SHORT $
43m0170 06652 510140010735020060000000	        D[MASK 6] ROT[8] ALU[D#Q] COND[OBUS=0] JUMP[TNIC0C] C550 $
43m0170                               	;2 WORD PACKET.
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

43m0170 06653 640141414571000023007637	        D[CONST 2] DEST[6] JUMP[TNICRM] DEST-A-MEM NORM $
43m0170                               	;ESCAPE SEQUENCE.  BETTER NOT HAPPEN.
43m0170 06654 000140000571000440006654	TNIC0C: JUMP[.] $
43m0170                               	
43m0170                               	;CLOCK ROUTINE, CALLED EVERY TICK OF 60HZ CLOCK.
43m0170                               	
43m0170 06655 640041614571000013405402	TYMCLK: D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPOFF] SPEC[IOB-IN] NORM $
43m0170 06656 440701614571000060100000	        MAPF[10] CYLEN[IOB-OUT] D[CONST 6] DEST[DEV-ADR] $
43m0170 06657 640701634571000443000000	        D[IR] DEST[7] DEST-A-MEM NORM $
43m0170 06660 511040054571000440000000	        D[13] COND[OBUS<0] PUSHJ[TNSI] C550 $
43m0170 06661 511040050571000440000000	        D[12] COND[OBUS<0] PUSHJ[TNSO] C550 $
43m0170 06662 640702274571000030000000	        D[17] MASK[3] DEST[IOD] NORM $
43m0170 06663 640701600615000443600000	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
43m0170 06664 440700000571000440100000	        MAPF[10] CYLEN[IOB-OUT] $
43m0170 06665 640301614571000060000000	        D[CONST 6] DEST[DEV-ADR] POPJ NORM $
43m0170                               	
43m0170                               	TNSI:   GHIRP
43m0170                               	 [
43m0170 06666 640040014171000050006634	        D[CONST 5] DEST[Q] PUSHJ[TNRCW] NORM $
43m0171 06667 640700070033000440000000	]       D[16] ALU[D+1] DEST[Q] NORM $
43m0171 06670 640700010235000070000000	        D[MASK 7] ALU[D&Q] DEST[Q] SHORT $
43m0171 06671 450300004537000440000000	        D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
43m0171 06672 640140614571000513006637	        D[CONST[TNIC2 & 77]] DEST[3] DEST-A-MEM JUMP[TNCASODOF] NORM $
43m0171                               	TNSO:   GBORP
43m0171                               	 [
43m0171 06673 640040014171000120006634	        D[CONST 12] DEST[Q] PUSHJ[TNRCW] NORM $
43m0172 06674 640710004571000440000000	]       D[MEM] DEST[AR] NORM $
43m0172                               	        GHORP
43m0172                               	 [
43m0172 06675 640040014171000110006634	        D[CONST 11] DEST[Q] PUSHJ[TNRCW] NORM $
43m0173 06676 640700000171000440000000	]       D[AR] DEST[Q] NORM $
43m0173 06677 450300004537000440000000	        D[MEM] ALU[D-Q] COND[OBUS=0] POPJ C600 $
43m0173 06700 640720014435014240000000	        D[CONST 24] ROT[6] ALU[D+Q] DEST[MA] NORM $
43m0173 06701 640706000550400440000000	        FIXM0 $
43m0173 06702 640041004171060443006624	        D[MEM] ROT[30] DEST[4 Q] DEST-A-MEM PUSHJ[TNSEND] NORM $
43m0173 06703 640300414571000113000000	        D[CONST[TNOC2 & 77]] DEST[2] POPJ DEST-A-MEM NORM $
43m0173                               	
43m0173                               	;RESET TYMNET INTERFACE.  OUTPUT COROUTINE GOES INTO NULL STATE.
43m0173                               	; INPUT COROUTINE GOES INTO STATE 0, INTRPTS GET ENABLED.
43m0173 06704 440710014571004033600000	TYMRS1: D[CONST 3] ROT[2] DEST[AR] CYLEN[IOB-OUT] SPEC[IOB-OUT] $
43m0173                               	         ;GET CONST TO ENB. INTRPTS; IOB-OUT CLEARS FLAGS.
43m0173 06705 440700000571000443770000	TYMRS2: MAPF[TNODIFS] START-OUT C600 $
43m0173 06706 440040010371004020160000	        MAPF[TNIRIFS] D[MASK 2] ALU[NOTD] ROT[2] DEST[Q] PUSHJ[DEV6ST1] C600 $
43m0173 06707 640700400741000443000000	        ALU[-1] DEST[2] DEST-A-MEM NORM $
43m0173 06710 640300614571000273000000	        D[CONST[TNIC0 & 77]] DEST[3] POPJ DEST-A-MEM NORM $
43m0173                               	
43m0173                               	TYMAREA:        ;SAVE LOCATION
43m0173                               	
43m0173                               	        .OPCODE[744]     [XLIST 
43m0173                               	 LIST            ]  ;RESET TYMNET
43m0173                               	
43m0173 03710 000700000571000440000000	        NOP $
43m0173 03711 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNRESET] $
43m0173                               	
43m0173 03712 000700000571000440000000	        NOP $
43m0173 03713 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNOUT] $
43m0173                               	
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

43m0173 03714 000700000571000440000000	        NOP $
43m0173 03715 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[TYMNIN] $
43m0173                               	
43m0173 03716 000700000571000440000000	        NOP $   ;AS NEAR AS I CAN TELL, THIS ONE (747) ISN'T USED. - PG
43m0173 03717 640141614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM JUMP[F5DIAG] $
43m0173                               	
43m0173                               	        .USE[TYMAREA]    [ XLIST
43m0173                               	 LIST ];RETURN TO MAIN CODE
43m0173                               	
43m0173 06711 640050024571004443606705	TYMNRESET:  SPEC[IOB-OUT] D[MA] ROT[2] DEST[AR] NORM PUSHJ[TYMRS2] $
43m0173                               	                ;RESET CO-ROUTINES, ENB. INTRPTS FROM EFF. ADDR. 34,35
43m0173 06712 000140000571000440002026	        JUMP[MAIN] $
43m0173                               	
43m0173 06713 640700000571000443600000	TYMNOUT: SPEC[IOB-OUT] NORM $  ;CLEAR "RDY FOR DATA" FROM PDP11
43m0173 06714 640040024171020440176624	        MAPF[TNODIFS] D[MA] ROT[8.] DEST[Q] NORM PUSHJ[TNSEND] $
43m0173                               	          ;SEND EFF. ADDR. 20-35 TO PDP11.
43m0173 06715 000140000571000440002026	        JUMP[MAIN] $
43m0173                               	
43m0173 06716 640740014571000310000000	TYMNIN: D[CONST 25.] LLOAD NORM $
43m0173 06717 640240000571000440006717	        NORM LOOP[.] $  ;GIVE DMA DEVICES SOME MEMORY TIME.
43m0173 06720 640700000571000443400000	        SPEC[IOB-IN] NORM $
43m0173 06721 240710030571070440050000	        MAPF[TYM.RD] D[IOD] ROT[27. + 1] DEST[AR] C800 $
43m0173                               	           ;Align input word with 16 data bits at RIGHT end.
43m0173 06722 531140000571010440006724	        D[AR] ROT[4] C550 COND[-OBUS<0] JUMP[. + 2] $
43m0173                               	           ;Don't clear "INPUT RDY" flag unless it's on.
43m0173 06723 640700000571000443600000	        SPEC[IOB-OUT] SHORT $  ;IT'S ON.
43m0173 06724 662104200571000440162032	        MAPF[TNIRIFS] D[AR] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
43m0173                               	
43m0173 06725 640706000550400440020000	F5DIAG: FIXM1 $
43m0173 06726 640710034771000440000000	        D[IR] ALU[NOTD] DEST[AR] NORM $
43m0173                               	                ;AR=-IR
43m0173 06727 640710000571032020000000	        D[AR] ROT[13.] MASK[2] DEST[AR] NORM $
43m0173                               	                ;AR=-AC MASK 2
43m0173 06730 640700000171014440000000	        D[AR] ROT[6] DEST[Q] NORM $
43m0173                               	                ;Q=INVERTED 2 LSB'S OF AC SHIFTED INTO STROBES
43m0173 06731 640704404575020440000000	        D[MEM] ROT[8.] ALU[DORQ] DEST[HOLD] NORM $
43m0173                               	                ;DATA SHIFTED WITH STROBES INSERTED
43m0173 06732 640710004571000440000000	        D[MEM] DEST[AR] NORM $
43m0173                               	                ;DATA=(E) (LSH 8) (STB ACTIVE LOW)
43m0173 06733 640040010171060220000000	        D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
43m0173                               	                ;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
43m0173 06734 640700010171014020000000	        D[MASK 2] ROT[6] DEST[Q] NORM $
43m0173                               	                ;MASK TO FORCE STB'S HIGH
43m0173 06735 640710004575000440000000	        D[MEM] ALU[DORQ] DEST[AR] NORM $
43m0173                               	                ;DATA=(E) (LSH 8) (STB'S FORCED INACTIVE HIGH)
43m0173 06736 640040010171060220000000	        D[MASK 18.] ROT[18. + 6] DEST[Q] PUSHJ[DEV6ST1] NORM $
43m0173                               	                ;LEAVE BITS 0-11. AND 30.-35. UNCHANGED
43m0173 06737 000141600615000440002026	        ALU[0] DEST[DEV-ADR] JUMP[MAIN] $
43m0173                               	
43m0173                               	
43m0162                               	]TYMNET
43m0162                               	
43m0162                               	LIST  ;matches the XLIST at top of page.
43m0162                               	
43m0162       6740	TYMFOO = .
43m0162                               	;$*$*$  I think this is the only way it will work for now.
43m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

43m0162                               	;$*$*$* Grrr...
43m0162                               	        .ORG[2141]       [ XLIST
43m0162                               	        .ENDORG
43m0162       6740	 [TYMAREA = .
43m0163                               	]       :2141
43m0163                               	        .DEFINE .ENDORG [] [LSTORG = .
43m0163                               	];.ENDORG
43m0162                               	 LIST ];DISP HERE ON TYMNET INTERFACE INTERRUPT.
43m0162                               	                        ; PREPARE TO CALL MAPOFF BY RE-LOADING DEV-ADR.
43m0162 02141 640141614571000010006602	        D[CONST 1] DEST[DEV-ADR] NORM JUMP[TNI] $       
43m0162                               	
43m0162                               	        .USE[TYMFOO]  [ XLIST
43m0162                               	        .ENDORG
43m0162       2142	 [LSTORG = .
43m0163                               	]       :TYMFOO
43m0163                               	        .DEFINE .ENDORG [] [TYMFOO = .
43m0163                               	];.ENDORG
43m0163                               	        .DEFINE .RELOC [] [.USE[TYMFOO]
43m0163                               	];.RELOC
43m0162                               	 LIST ]
43m0162                               	
43m0162                               	.REPEAT 1 - TYMNET [
43m0162                               	TNI:    DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $            ;"It can't happen here"
43m0162                               	];1 - TYMNET
43m0162                               	
43m0162                               	
43m0162                               	;What is 'device 6'?  Document!  TVR-Apr80 - THIS IS TYMNET (CLEAR AND STORE)
43m0162                               	DEV6CL:   ;CLEAR SOME DEV 6 BITS (SEE COMMENT BELOW).
43m0162 06740 640150000615000440000000	        ALU[0] DEST[AR] NORM JUMP[DEV6ST] $
43m0162                               	
43m0162                               	DEV6ST:    ;SET SOME OF THE BITS IN DEVICE 6'S OUTPUT REGISTER, A COPY
43m0162                               	           ;OF WHICH IS MAINTAINED IN A-MEM(1).
43m0162                               	           ;ENTER WITH MASK FOR UNCHANGED BITS IN IN Q, DATA IN AR.
43m0162                               	           ; $$$$ ON RETURN, Q HAS NEW VALUE OF AMEM(1) $$$$$
43m0162 06741 640701614571000060000000	        D[CONST 6] DEST[DEV-ADR] NORM $
43m0162                               	DEV6ST1:        ;ENTER HERE IF YOU'VE ALREADY SET DEVADR:=6
43m0162 06742 640700044235000440000000	        D[11] ALU[D&Q] DEST[Q] NORM $ ;GET AMEM(1), MASK IT.
43m0162 06743 640702200175000443600000	DEV6ST2: D[AR] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] NORM $ 
43m0162                               	                ;OR IN NEW DATA
43m0162 06744 440300200555000443150000	        MAPF[TYM.LD] ALU[Q] DEST[1] DEST-A-MEM CYLEN[IOB-OUT] POPJ $
43m0162                               	
43m0162                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

44m0162                               	;INTERVAL TIMER CODE.
44m0162                               	
44m0162                               	;a-mem useage:
44m0162                               	;       0       dispatch addr for interrupts
44m0162                               	;       1       pi chn (33: 35) and intrpt waiting flag (32)
44m0162                               	;               (BITS 0,19 ARE ON FOR USE BY TAPE CODE)
44m0162                               	;       2       CONSTANT W/ ONLY BIT 19 ON (USED BY TAPE CODE)
44m0162                               	;       3       INTERVAL TIMER REGISTER.
44m0162                               	
44m0162                               	  .REPEAT OTP [
44m0162                               	        TIM.CLR.ROT = 35. - 6
44m0162                               	        TIM.DO = 1
44m0162                               	        TIM.DI = 1
44m0162                               	        TIM.ENB = 1
44m0162                               	        TIM.DEV = 7
44m0162                               	        TIM.LOC = 2150
44m0162                               	    ] ;OTP
44m0162                               	
44m0162                               	  .REPEAT NTP [
44m0162                               	        TIM.CLR.ROT = 0
44m0162                               	        TIM.DO = 11
44m0162                               	        TIM.DI = 1
44m0162                               	        TIM.ENB = 10
44m0162                               	        TIM.DEV = 5
44m0162                               	        TIM.LOC = 2134
44m0162                               	    ] [
44m0162       0	        TIM.CLR.ROT = 0
44m0162       11	        TIM.DO = 11
44m0162       1	        TIM.DI = 1
44m0162       10	        TIM.ENB = 10
44m0162       5	        TIM.DEV = 5
44m0162       2134	        TIM.LOC = 2134
44m0162                               	    ];NTP
44m0162                               	
44m0162                               	
44m0162                               	        .ORG[TIM.LOC]    [ XLIST
44m0162                               	        .ENDORG
44m0162       6745	 [TYMFOO = .
44m0163                               	]       :TIM.LOC
44m0163                               	        .DEFINE .ENDORG [] [LSTORG = .
44m0163                               	];.ENDORG
44m0162                               	 LIST ] ;$*$*$ INTRPTS FROM DEVICE COME HERE.
44m0162                               	   .REPEAT 1 - TIMER [
44m0162                               	        DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $ ;FLUSH DEV INTERRUPTS 
44m0162                               	     ]
44m0162                               	
44m0162                               	   .REPEAT TIMER [
44m0162                               	        NORM JUMP[TIMINT] $
44m0162                               	     ]
44m0162                               	[
44m0162 02134 640140000571000440000000	        NORM JUMP[TIMINT] $
44m0162                               	     ]
44m0162                               	        .RELOC
44m0162                               	 [.USE[TYMFOO]
44m0162                               	 [ XLIST
44m0162                               	        .ENDORG
44m0162       2135	 [LSTORG = .
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

44m0163                               	]       :TYMFOO
44m0163                               	        .DEFINE .ENDORG [] [TYMFOO = .
44m0163                               	];.ENDORG
44m0163                               	        .DEFINE .RELOC [] [.USE[TYMFOO]
44m0163                               	];.RELOC
44m0163                               	 LIST ]]
44m0163                               	TIMINT:   ;ALL DEV 5 INTS COME FROM INTERVAL TIMER...
44m0163 06745 640702214571000013600000	        START-OUT D[CONST 1] ROT[TIM.CLR.ROT] DEST[IOD] NORM $
44m0163                               	           ;Clear the TIMER OVERFLOW FLAG.
44m0163 06746 240700054171000440100000	        MAPF[TIM.ENB] D[13] DEST[Q] C800 $
44m0163                               	           ;Get TIMER REGISTER.
44m0163                               	        D[CONST 1] ROT[12.] ALU[D+Q] DEST[Q 3] DEST-A-MEM
44m0163 06747 535140614035030013002026	                  C550 COND[-CRY0] JUMP[MAIN] $
44m0163                               	           ;Increment the count by 2^12, exit if no overflow.
44m0163 06750 510150044571000030002026	        D[11] MASK[3] DEST[AR] C550 COND[OBUS=0] JUMP[MAIN] $
44m0163                               	           ;Timer overflowed. ignore if no PI CHANNEL assigned.
44m0163 06751 640700044171000440000000	        D[11] DEST[Q] NORM $
44m0163                               	           ;Get full contents of A-MEM[1].
44m0163 06752 640140214575000103004562	        D[CONST 10] ALU[DORQ] DEST[1] DEST-A-MEM NORM JUMP[PIGEN] $
44m0163                               	           ;Set the "interrupting" status bit and generate a PI.
44m0163                               	
44m0163                               	   .OPCODE[760]  [XLIST 
44m0163                               	        .ENDORG
44m0163       6753	 [TYMFOO = .
44m0164                               	]       :INST-DISP + 2 * 760
44m0164                               	        .DEFINE .ENDORG [] [ LASTORG = .
44m0164                               	];.ENDORG
44m0163                               	 LIST            ];TIMER PSEUDO-IOT DISPATCH TABLE ENTRIES.
44m0163                               	
44m0163                               	; TCONO -- 760
44m0163 03740 640701614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] SHORT $
44m0163 03741 640140044171000440000000	        D[11] DEST[Q] NORM JUMP[TCNO1]$
44m0163                               	; TCONI -- 761
44m0163 03742 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0163 03743 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;store them and
44m0163                               	 return.
44m0163                               	; TCONSO -- 762
44m0163 03744 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0163 03745 530100010635000220000000	        D[MASK 22] ALU[D&Q] C550 COND[-OBUS=0] LBJUMP[DSKP1] $ ;Skip if on.
44m0163                               	; TCONSZ -- 763
44m0163 03746 640041614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TCNI1] $ ;get bits.
44m0163 03747 510100010635000220000000	        D[MASK 22] ALU[D&Q] C550 COND[OBUS=0] LBJUMP[DSKP1] $ ;Skip if off.
44m0163                               	; TDATAO -- 764  LOAD THE 36-BIT TIMER
44m0163 03750 640701614571000050000000	        D[CONST TIM.DEV] DEST[DEV-ADR] NORM $
44m0163 03751 640146000550400440020000	        FIXM1 JUMP[TDATO] $
44m0163                               	; TDATAI  --  765    READ TIMER REGISTER
44m0163 03752 640041614571000053400000	        START-IN D[CONST TIM.DEV] DEST[DEV-ADR] NORM PUSHJ[TDTI] $ ;get bits.
44m0163 03753 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;Store them and
44m0163                               	 return.
44m0163                               	
44m0163                               	   .RELOC
44m0163                               	 [.USE[TYMFOO]
44m0163                               	 [ XLIST
44m0163                               	        .ENDORG
44m0163       3754	 [ LASTORG = .
44m0164                               	]       :TYMFOO
44m0164                               	        .DEFINE .ENDORG [] [TYMFOO = .
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

44m0164                               	];.ENDORG
44m0164                               	        .DEFINE .RELOC [] [.USE[TYMFOO]
44m0164                               	];.RELOC
44m0164                               	 LIST ]]
44m0164 06753 640700010235010400000000	TCNO1:  D[MASK 32.] ROT[4] ALU[D&Q] DEST[Q] NORM $
44m0164 06754 000140234575000033002026	        D[IR] MASK[3] ALU[DORQ] DEST[1] DEST-A-MEM JUMP[MAIN] $
44m0164                               	           ;Put new PI CHAN. in bits 33-35 of A-MEM[1].
44m0164                               	
44m0164 06755 640710044171000040000000	TCNI1:  D[11] MASK[4] DEST[Q AR] NORM $ ;get intrpt flag and pi chn
44m0164 06756 640300034235000440000000	        D[IR] ALU[D&Q] DEST[Q] NORM POPJ $ ;this is for conso, z
44m0164                               	
44m0164 06757 640700004171000140000000	TDATO:  D[MEM] MASK[12.] DEST[Q] NORM $
44m0164                               	           ;Get low 12 bits of new timer value...
44m0164 06760 640702214575070013600000	        START-OUT D[CONST 1] ROT[35. - 7] ALU[DORQ] DEST[IOD] NORM $
44m0164                               	           ;Place in hardware counter (the "TP TIMER").
44m0164 06761 240700010171030300110000	        MAPF[TIM.DO] D[MASK 24.] ROT[12.] DEST[Q] C800 $
44m0164 06762 640140604635000443002026	        D[MEM] ALU[D&Q] DEST[3] DEST-A-MEM NORM JUMP[MAIN] $
44m0164                               	           ;Put other 24 bits into A-MEM[3] (the "TIMER REGISTER").
44m0164                               	
44m0164 06763 440710030571030143410000	TDTI:   MAPF[TIM.DI] START-IN D[IOD] ROT[12.] MASK[12.] DEST[AR] C600 $
44m0164                               	           ;Read hardware timer.
44m0164 06764 440700030171030140010000	        MAPF[TIM.DI] D[IOD] ROT[12.] MASK[12.] DEST[Q] C600 $
44m0164                               	           ;Read it again.
44m0164 06765 530140000735000443406763	        START-IN D[AR] ALU[D#Q] C550 COND[-OBUS=0] JUMP[TDTI] $
44m0164                               	           ;If it changed, try again (to ensure that we don't get a garbaged
44m0164                               	           ; value because of reading it while it is changing).
44m0164 06766 640310054575000440000000	        D[13] ALU[DORQ] DEST[AR] NORM POPJ $
44m0164                               	           ;Combine high-order bits from A-MEM[3] with
44m0164                               	           ; low-order bits from hardware counter.
44m0164                               	
44m0164                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

45m0164                               	;       IMP,VID,PAN,GRN,DLS,LPT,VC etc.
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Packet Switching Network Interface (IMP)
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT IMP [
45m0164                               	
45m0164                               	;Insert main code body here
45m0164                               	.INSERT IMP.SLO
45m0164                               	
45m0164                               	];IMP
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Panofsky-Samson Interface
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT STANSW [
45m0164                               	
45m0164                               	.INSERT PAN.SLO
45m0164                               	.INSERT TMPGRN.SLO      ;Temporary Grinnell Interface
45m0164                               	
45m0164                               	];.REPEAT STANSW
45m0164                               	
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Data Line Scanner (TTY scanner)
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT DLS [
45m0164                               	
45m0164                               	.DEFINE ASRC[ X ] [D[10 + X]]
45m0164                               	.DEFINE ADEST[ X ] [DEST[X] DEST-A-MEM]
45m0164                               	
45m0164                               	.REPEAT DLS2 [
45m0164                               	.INSERT DLS.SLO
45m0164                               	
45m0164                               	.REPEAT DLSDEB [
45m0164                               	.INSERT DLSDEB.SLO
45m0164                               	];DLSDEB
45m0164                               	] ;DLS2
45m0164                               	.REPEAT 1 - DLS2 [
45m0164                               	.INSERT ODLS.SLO
45m0164                               	.REPEAT DLSDEB [
45m0164                               	.INSERT ODLSDE.SLO
45m0164                               	] ;DLSDEB
45m0164                               	] ;1 - DLS2
45m0164                               	
45m0164                               	];[
45m0164                               	
45m0164                               	.DEFINE ASRC[ X ] [D[10 + X]]
45m0164                               	.DEFINE ADEST[ X ] [DEST[X] DEST-A-MEM]
45m0164                               	
45m0164                               	.REPEAT DLS2 [
45m0164                               	.INSERT DLS.SLO
45m0164                               	
45m0164                               	.REPEAT DLSDEB [
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

45m0164                               	.INSERT DLSDEB.SLO
45m0164                               	];DLSDEB
45m0164                               	] [
45m0164                               	.INSERT DLS.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

01m0001                               	;#####################################################################
01m0001                               	;   Let's make the dls be macro device 370;  so the
01m0001                               	;   iot's will have opcode 737, dispatch table
01m0001                               	;   entry loc. 3676
01m0001                               	;#########################################################################
01m0001                               	
01m0001                               	;-----------------------------------------------------------------------
01m0001                               	;DLS definitions
01m0001                               	;-----------------------------------------------------------------------
01m0001       37	DLS = 37        ;MACRODEVICE CODE 370
01m0001       6767	DLSORG = .  ;; DWP 1/27/80 %%% DLSORG = 7000    ;UCODE ORIGIN
01m0001       2137	DLSVECTOR = 2137        ;Interrupt dispatch address
01m0001                               	
01m0001                               	.REPEAT DLS2 [DLSWEBIT = 16.    ;ASTRO write enable bit
01m0001                               	DLSNLINES = 37  ;Highest line number
01m0001                               	DLSLNSIZE = 5   ;Number of bits in line-number field
01m0001                               	.DEFINE DLSIRQ [] [ROT[9.] COND[-OBUS<0]]
01m0001                               	.DEFINE DLSNOIRQ [] [ROT[9.] COND[OBUS<0]]]
01m0001       20	[DLSWEBIT = 16. ;ASTRO write enable bit
01m0001       37	DLSNLINES = 37  ;Highest line number
01m0001       5	DLSLNSIZE = 5   ;Number of bits in line-number field
01m0001                               	.DEFINE DLSIRQ [] [ROT[9.] COND[-OBUS<0]]
01m0001                               	.DEFINE DLSNOIRQ [] [ROT[9.] COND[OBUS<0]]].REPEAT 1 - DLS2 [DLSWEBIT = 10.
01m0001                               	DLSNLINES = 17
01m0001                               	DLSLNSIZE = 4
01m0001                               	.DEFINE DLSIRQ [] [ROT[9.] COND[OBUS<0]]
01m0001                               	.DEFINE DLSNOIRQ [] [ROT[9.] COND[-OBUS<0]]]
01m0001                               	
01m0001                               	;
01m0001                               	;A-MEM definitions
01m0001                               	;
01m0001       0	DLSINTAD = 0    ;Interrupt service routine
01m0001       1	DLSPICHN = 1    ;PI channel for DLS
01m0001       2	DLSLINE = 2     ;Line number which the scanner is simulated to have
01m0001                               	                ;stopped on
01m0001       3	DLSACT = 3      ;Active line flags
01m0001                               	                ;   DLSCNI1
01m0001       4	DLSTMP = 4      ;SCRATCH
01m0001                               	;
01m0001                               	;MAPF fields (IO SUBSEL)
01m0001                               	;
01m0001       0	DLSCR1 = 0      ;ASTRA CR1 (Control Register 1)
01m0001                               	;               Async                   Sync
01m0001                               	;       Bit 28          Normal mode (NOT looped)
01m0001                               	;       Bit 29  Send break              Xmit transparent
01m0001                               	;       Bit 30  Single stop bit         Transmit parity
01m0001                               	;                 if xmit enabled         if bit 29 is zero
01m0001                               	;         else  Not MISC OUT = 0        Force DLE
01m0001                               	;       Bit 31  Auto-echo (1/2 duplex)  Not MISC OUT = 0 (bit 29=0)
01m0001                               	;                                       DLE stripping (bit 29=1)
01m0001                               	;       Bit 32  Parity enable           Recieve parity enable
01m0001                               	;       Bit 33          Reciever enabled
01m0001                               	;       Bit 34          not RTS OUT = 0
01m0001                               	;       Bit 35          not DTR OUT = 0
01m0001                               	;
01m0001       1	DLSCR2 = 1      ;ASTRA CR2 (Control Register 2)
01m0001                               	;   Bits 28:29          Character length
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

01m0001                               	;               00  8 bits      10  6 Bits
01m0001                               	;               01  7 bits      11  5 Bits
01m0001                               	;       Bit 30  0  Asynchronous         1  Synchronous
01m0001                               	;       Bit 31  0  Odd parity           1  Even parity
01m0001                               	;       Bit 32  Rcv clk = xmt clk       SYN strip (CR1 bit 29=0)
01m0001                               	;               else Rcv clk = Rate 1   DEL-SYN strip (CR1 bit 29=1)
01m0001                               	;   Bits 33:35  Transmit clock select
01m0001                               	;       000     Ext. clock (EIA pins:  Xmt=15, Rcv=17 [???])
01m0001                               	;       001     Rate 1          150 baud
01m0001                               	;       010     Rate 2          300 baud
01m0001                               	;       011     Rate 3          109.9 baud      *** 1200 baud Temp.
01m0001                               	;       100     Rate 4          9600 baud
01m0001                               	;       101     Rate 4 / 2      4800 baud
01m0001                               	;       110     Rate 4 / 4      2400 baud
01m0001                               	;       111     Rate 4 / 8      1200 baud
01m0001                               	;
01m0001       2	DLSSTAT = 2     ;ASTRA Status register
01m0001                               	;       Bit 28  Data Set Change (DSR or CD changed while DTR=1, or RI
01m0001                               	;                 changed while DTR=0)
01m0001                               	;       Bit 29  DSR (Data Set Ready)
01m0001                               	;       Bit 30  CD (Carrier Detect)
01m0001                               	;       Bit 31  Framing error or SYN detect
01m0001                               	;       Bit 32  Parity error [Async, too???] or DLE detect
01m0001                               	;       Bit 33  Overrun error
01m0001                               	;       Bit 34  Data recieved
01m0001                               	;       Bit 35  Transmit holding register empty  (Note: this does NOT
01m0001                               	;                 necessarily mean the transmitter is off)
01m0001                               	;On write, this sets the SYN register, and if immediately followed by
01m0001                               	;another write, that write sets the DLE register.
01m0001       3	DLSHOLD = 3     ;ASTRA xmt/rcv Hold register
01m0001       10	DLSCSR = 10     ;Interface Command/Status Register
01m0001       4	DLSIACK = 4     ;Interrupt acknowledge (also, interrupting line)
01m0001       14	DLSNOSEL = 14   ;Don't select anything
01m0001                               	
01m0001                               	;Macros for reading ASTRA registers.  They are macros because the
01m0001                               	;control logic on the prototype didn't have the timing correct for the
01m0001                               	;ASTRA and the problem was pushed onto the microcode.
01m0001                               	
01m0001                               	.DEFINE DLSREAD[ XXX DST WID ]
01m0001                               	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001                               	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001                               	        MAPF[XXX] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001                               	        MAPF[XXX] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001                               	        MAPF[XXX + DLSNOSEL] D[IOD] MASK[WID] ALU[D] DEST[DST] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001                               	        MAPF[XXX + DLSNOSEL] $
01m0001                               	        MAPF[XXX + DLSNOSEL]  ];.DEFINE
01m0001                               	
01m0001                               	.DEFINE DLSWRITE[ XXX ]
01m0001                               	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001                               	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001                               	        MAPF[XXX] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

01m0001                               	                ;DROP CS, SET WE
01m0001                               	        MAPF[XXX] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001                               	        MAPF[XXX + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[XXX + DLSNOSEL]            ;Finish the last IOB-OUT
01m0001                               	];DEFINE DLSWRITE
01m0001                               	
01m0001                               	.DEFINE DLSRINT[] [
01m0001                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
01m0001                               	                ALU[Q+1] DEST[IOD] NORM $
01m0001                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
01m0001                               	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
01m0001                               	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
01m0001                               	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
01m0001                               	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
01m0001                               	        D[10 + DLSTMP] ];DEFINE DLSRINT
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

02m0001                               	;-----------------------------------------------------------------------
02m0001                               	;Default configuration.  Lines are reset to this on initialization.
02m0001                               	;See DLS definition page for meaning of this bits.  Three groups of
02m0001                               	;lines may be initialized, allowing for local terminal, 300 buad modems
02m0001                               	;and split speed modems.
02m0001                               	
02m0001                               	;Caution:  Only lower 6 bits are permissible here.  This means you
02m0001                               	;          can't start out with looped, in break mode, or with character
02m0001                               	;          length other than 8.  You must use macro code to set those.
02m0001                               	;
02m0001                               	;Note:  Groups can be omitted by setting DLSGRPxN to zero.
02m0001                               	;-----------------------------------------------------------------------
02m0001                               	;*****  THIS SHOULD BE IN THE SITE DEPENDENT FILE  *****
02m0001                               	.DEFINE DLSINI [] [
02m0001                               	DLSGRP[0 0 247 32]      ;Line 0 300 baud
02m0001                               	DLSGRP[1 3 247 23]      ;Lines 1-3 150/1200     *** Temp.
02m0001                               	DLSGRP[4 DLSNLINES 247 34]      ;Lines 4-LAST 9600
02m0001                               	] ;DLSINI
02m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

03m0001                               	;-----------------------------------------------------------------------
03m0001                               	; DLS Dispatch
03m0001                               	;-----------------------------------------------------------------------
03m0001       3676	DLSDISP = 3600 + DLS + DLS      ;Dispatch for DLS instructions
03m0001                               	:DLSDISP
03m0001 03676 640141614571000200003677	        D[CONST DLSDEV] DEST[DEV-ADR] JUMP[. + 1] NORM $
03m0001 03677 640140014171014670000000	        D[CONST DLSORG / 100] ROT[6] DEST[Q] JUMP[DLSIOT] NORM $
03m0001                               	:DLSORG         ;DISPATCH ON DLS IOT CODES
03m0001                               	
03m0001                               	DLSDISP2:
03m0001                               	.REPEAT DLSDEB [
03m0001                               	:DLSDISP2 + 40
03m0001                               	]
03m0001                               	[
03m0001                               	:DLSDISP2 + 40
03m0001                               	].REPEAT 1 - DLSDEB [
03m0001                               	:DLSDISP2 + 20  ;Space will be used as needed for first DLS
03m0001                               	;Other half is unused.  It would be a second DLS
03m0001                               	.REPEAT 10 [
03m0001                               	        ILGIOT $
03m0001                               	        NOP $
03m0001                               	];REPEAT
03m0001                               	];DLSDEB
03m0001                               	
03m0001       67	DLSLOW = DLSORG \ 100
03m0001                               	DLSIOT:
03m0001                               	
03m0001 07027 640700014175000670000000	                D[CONST DLSLOW] ALU[DORQ] DEST[Q] NORM $
03m0001 07030 640700034035032040000000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] DEST[Q] NORM $
03m0001 07031 500540034435032040000000	        D[IR] ROT[13.] MASK[4] ALU[D+Q] SDISP CYLEN[C550] $
03m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

04m0001                               	;-----------------------------------------------------------------------
04m0001                               	;BLKI DLS,
04m0001                               	DLSBLKI:
04m0001                               	.REPEAT 1 - DLSDEB [
04m0001                               	:DLSDISP2 + 0
04m0001                               	        ;Unimplemented
04m0001                               	        ILGIOT $
04m0001                               	        NOP $
04m0001                               	:DLSBLKI
04m0001                               	];DLSDEB
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	;DATAI DLS,
04m0001                               	;
04m0001                               	;       Bit 12  This is a modem control line
04m0001                               	;   Bits 13:17  Line number
04m0001                               	;       Bit 27  Interrupt from reciever (always true for modem control)
04m0001                               	;   Bits 28:35  Character (Note: 5 bit characters do NOT use bit 27 for
04m0001                               	;                          flag.  Use TRNN x,777 to test for rcv. int.)
04m0001                               	;Modem control use of bits 28:35
04m0001                               	;       Bit 28  Unused
04m0001                               	;       Bit 29  DTR (Data Terminal Ready)
04m0001                               	;   Bits 30:32  ACU bits (unimplemented - no auto-dialer)
04m0001                               	;       Bit 33  CD (Carrier Detect)
04m0001                               	;       Bit 34  RI (Ring Indicator)
04m0001                               	;       Bit 35  Unused
04m0001                               	;
04m0001                               	;-----------------------------------------------------------------------
04m0001                               	DLSDI1: ;Prepare to insert into dispatch table
04m0001                               	:DLSDISP2 + 2           ;Two instructions here and the rest elsewhere
04m0001 06771 640150050171000440006772	        ASRC[DLSLINE]  [D[10 + DLSLINE]]DEST[AR Q] JUMP[. + 1] NORM $
04m0001 06772 640140414675020013007032	        D[CONST 1] ROT[8.] ALU[-D&Q] ADEST[DLSLINE]  [DEST[DLSLINE]
04m0001                               	 DEST-A-MEM]JUMP[DLSDI1] NORM $
04m0001                               	:DLSDI1
04m0001 07032 510140014635020010000000	        D[CONST 1] ROT[8.] ALU[D&Q] COND[OBUS=0] JUMP[DLSDI2] C550 $
04m0001                               	                ;Did scanner stop on a receiver?
04m0001 07033 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
04m0001                               	                ;Yes.  Enable interrupt
04m0001 07034 440700044171000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] ASRC[DLSPICHN]  [D[10 + DLSPICHN]]DEST[Q] $
04m0001                               	                ;Clear RCVR flag.
04m0001 07035 640700214675006013000000	        D[CONST 1] ROT[3] ALU[-D&Q] ADEST[DLSPICHN]  [DEST[DLSPICHN] DEST-A-MEM]NORM $
04m0001 07036 662104200571000440002032	DLSDI2: D[AR] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
04m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

05m0001                               	
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;BLKO DLS,
05m0001                               	DLSBLKO:
05m0001                               	.REPEAT 1 - DLSDEB [
05m0001                               	:DLSDISP2 + 4
05m0001                               	                ;Unimplemented
05m0001                               	        ILGIOT $
05m0001                               	        NOP $
05m0001                               	:DLSBLKO
05m0001                               	];DLSDEB
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	;DATAO DLS,
05m0001                               	;
05m0001                               	;       Bit 11  Use this line
05m0001                               	;   Bits 12:17  Line number if bit 11 is on (else interrupting line)
05m0001                               	;       Bit 27  Turn off transmitter (if this bit is on, then scanner is
05m0001                               	;                 restarted, but termination of transmission is not
05m0001                               	;                 implemented.)  Note: bit 30 is NOT used as alternative
05m0001                               	;                 to bit 27 in 5-bit character mode.)
05m0001                               	;Modem Control usage for bits 27:35
05m0001                               	;       Bit 27  Unused
05m0001                               	;       Bit 28  Set Status Flag (request interrupt).  Not implemented;
05m0001                               	;                  causes bug trap.
05m0001                               	;       Bit 29  DTR (Data Terminal Ready)
05m0001                               	;   Bits 30:35  ACU bits (Not implemented - no auto-dialer)
05m0001                               	;DC10 escape - Bit 0 = 1
05m0001                               	;   Bits 20:27  ASTRA Control Register 1
05m0001                               	;   Bits 28:31  ASTRA Control Register 2
05m0001                               	;
05m0001                               	;-----------------------------------------------------------------------
05m0001                               	DLSDO1: ;Prepare to insert into dispatch table
05m0001                               	:DLSDISP2 + 6           ;Two instructions here and the rest elsewhere
05m0001 06775 640706000550400440020000	          FIXM1 $       ;Fetch operand
05m0001 06776 000140000571000440007037	        JUMP[DLSDO1] $
05m0001                               	:DLSDO1
05m0001 07037 531140004571026440000000	        D[MEM] ROT[11.] COND[-OBUS<0] JUMP[DLSNTHIS] C550 $
05m0001                               	                ;Is "use this line" on?
05m0001 07040 531140044571076440000000	        ASRC[DLSPICHN]  [D[10 + DLSPICHN]]ROT[31.] COND[-OBUS<0] JUMP[DLSTHIS] C550 $
05m0001                               	                ;Yes.  Use it if scanner not stopped on xmitter.
05m0001 07041 640700004171044050000000	        D[MEM] ROT[18.] MASK[DLSLNSIZE] DEST[Q] NORM $
05m0001                               	                ;It has stopped...
05m0001 07042 510140050735044050000000	        ASRC[DLSLINE]  [D[10 + DLSLINE]]ROT[18.] MASK[DLSLNSIZE] ALU[D#Q] COND[OBUS=0]
05m0001                               	 JUMP[DLSSCNR] C550 $
05m0001                               	                ;If it stopped on the line to use, ignore the "use this"
05m0001 07043 640150004171044050000000	DLSTHIS:        D[MEM] ROT[18.] MASK[DLSLNSIZE] DEST[AR Q] JUMP[DLSOUT] NORM $
05m0001                               	                ;Set line # from data.
05m0001 07044 531140044571076440002026	DLSNTHIS:       ASRC[DLSPICHN]  [D[10 + DLSPICHN]]ROT[31.] COND[-OBUS<0] JUMP[MAIN] C550
05m0001                               	 $
05m0001                               	                ;No "use this" - NOP if scanner not stopped.
05m0001 07045 640700044171000030000000	DLSSCNR:        ASRC[DLSPICHN]  [D[10 + DLSPICHN]]MASK[3] DEST[Q] NORM $
05m0001 07046 640700214575006043000000	        D[CONST 4] ROT[3] ALU[DORQ] ADEST[DLSPICHN]  [DEST[DLSPICHN] DEST-A-MEM]NORM $
05m0001                               	                ;Clear XMIT flag.
05m0001 07047 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
05m0001                               	                ;Enable interrupt.
05m0001 07050 440710050171044050100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] ASRC[DLSLINE]  [D[10 + DLSLINE]]ROT[18.]
05m0001                               	 MASK[DLSLNSIZE] DEST[AR Q] $
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

05m0001                               	                ;Use line # from scanner.
05m0001 07051 640701214537000430000000	DLSOUT: D[CONST 35.] ALU[D-Q] DEST[ROTR] NORM $
05m0001 07052 640700054171000440000000	        ASRC[DLSACT]  [D[10 + DLSACT]]DEST[Q] NORM $    ;Prepare to twiddle active bit
05m0001 07053 511140004571066440000000	        D[MEM] ROT[27.] COND[OBUS<0] JUMP[DLSOFF] C550 $
05m0001                               	                ;"turn off transmitter"?
05m0001 07054 640700614575200013000000	        D[CONST 1] ROT[R] ALU[DORQ] ADEST[DLSACT]  [DEST[DLSACT] DEST-A-MEM]NORM $
05m0001                               	                ;No.  Turn it on.
05m0001 07055 640700004171000100000000	        D[MEM] MASK[8] DEST[Q] NORM $
05m0001 07056 640700000175052440000000	        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
05m0001                               	        DLSWRITE[DLSHOLD] 
05m0001 07057 000700014175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
05m0001                               	                ;Set TTY number
05m0001 07060 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	                ;SET CS
05m0001 07061 000702214575046013630000	        MAPF[DLSHOLD] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	
05m0001                               	                ;DROP CS, SET WE
05m0001 07062 000702200555000443630000	        MAPF[DLSHOLD] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
05m0001                               	                ;DROP WE.
05m0001 07063 000700000571000443770000	        MAPF[DLSHOLD + DLSNOSEL] SPEC[IOB-OUT] $
05m0001                               	        MAPF[DLSHOLD + DLSNOSEL]                ;Finish the last IOB-OUT
05m0001 07064 640140000571000440172026	]JUMP[MAIN] NORM $
05m0001 07065 640140614675200013002026	DLSOFF: D[CONST 1] ROT[R] ALU[-D&Q] ADEST[DLSACT]  [DEST[DLSACT] DEST-A-MEM]JUMP[MAIN]
05m0001                               	 NORM $
05m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONO DLS,
06m0001                               	
06m0001                               	;
06m0001                               	;       Bit 30  Clear DC10
06m0001                               	;       Bit 31  Ready Hold (Not implemented, DTR switch is simulated as
06m0001                               	;                       being on.)
06m0001                               	;       Bit 32  Reset Scanner (more accurately, restart scanner. Allows
06m0001                               	;                        interrupts)
06m0001                               	;   Bits 33:35  PI channel
06m0001                               	;
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	DLSCNO1:
06m0001                               	:DLSDISP2 + 10
06m0001 06777 511040034571074440000000	        D[IR] ROT[30.] COND[OBUS<0] PUSHJ[DLSRST] C550 $
06m0001 07000 640140014171000700007066	        D[CONST 70] DEST[Q] JUMP[DLSCNO1] NORM $
06m0001                               	:DLSCNO1
06m0001 07066 640700044235000440000000	        ASRC[DLSPICHN]  [D[10 + DLSPICHN]]ALU[D&Q] DEST[Q] NORM $
06m0001 07067 640140234575000033002026	        D[IR] MASK[3] ALU[DORQ] ADEST[DLSPICHN]  [DEST[DLSPICHN] DEST-A-MEM]JUMP[MAIN]
06m0001                               	 NORM $
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONI DLS,
06m0001                               	;
06m0001                               	;    Bits 0:7   ASTRA Control Register 1
06m0001                               	;    Bits 8:13  ASTRA Control Register 2
06m0001                               	;    Bits 14:20 ASTRA Status Register
06m0001                               	;       Bit 30  DTR Distend (Simulated as always on)
06m0001                               	;       Bit 31  Transmit interrupt
06m0001                               	;       Bit 32  Recieve interrupt
06m0001                               	;               (Both bits 31 and 32 will not be on at the same time.
06m0001                               	;                Recieve will take priority.)
06m0001                               	;   Bits 33:35  PI channel
06m0001                               	;
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	DLSCNISV:
06m0001                               	:DLSDISP2 + 12
06m0001                               	                ;Get CONI information
06m0001 07001 662104244571000440002032	        ASRC[DLSPICHN]  [D[10 + DLSPICHN]]DEST[MEMSTO] MEMST  [COND[-MA-AC]
06m0001                               	 LBJUMP[MSMAIN] NORM ]$
06m0001 07002 000700000571000440000000	        NOP $
06m0001                               	                ;Store and fetch next instruction
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONSZ DLS,
06m0001                               	;-----------------------------------------------------------------------
06m0001 07003 640710044571000440000000	        ASRC[DLSPICHN]  [D[10 + DLSPICHN]]DEST[AR] NORM $
06m0001 07004 640140034171000220004470	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
06m0001                               	                ;Do standard skip off AR and IR
06m0001                               	;-----------------------------------------------------------------------
06m0001                               	;CONSO DLS,
06m0001                               	;-----------------------------------------------------------------------
06m0001 07005 640710044571000440000000	        ASRC[DLSPICHN]  [D[10 + DLSPICHN]]DEST[AR] NORM $
06m0001 07006 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
06m0001                               	                ;Do standard skip off AR and IR
06m0001                               	:DLSCNISV
06m0001                               	
06m0001 07070 000144620531000440004366	DLSBAD: d[pc] alu[d-1] dest[pc] jump[dohalt] $
06m0001                               	                ;Halt macro machine on this lossage...
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

06m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

07m0001                               	;-----------------------------------------------------------------------
07m0001                               	;Reset DLS
07m0001                               	;
07m0001                               	;Clear PI assignment and A-MEM registers.
07m0001                               	;Turn off interrupts
07m0001                               	;Setup defaults for lines 0:7, 8:5
07m0001                               	;
07m0001                               	;-----------------------------------------------------------------------
07m0001                               	.DEFINE DLSGRP[L0 L1 CR1 CR2] [
07m0001                               	        D[CONST L1 - L0] LLOAD $
07m0001                               	        D[CONST CR2] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001                               	        D[CONST CR1 / 100] ROT[6] DEST[Q] NORM $
07m0001                               	        D[CONST CR1 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001                               	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	] ;DLSGRP
07m0001                               	DLSRST:
07m0001 07071 640702214571060013600000	        D[CONST 1] ROT[24.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0001                               	                ;Hit MASTER RESET on all ASTRAs
07m0001 07072 000700214571000403100000	        MAPF[DLSCSR] LONG D[CONST 40] ADEST[DLSPICHN]  [DEST[DLSPICHN] DEST-A-MEM]$
07m0001                               	 ;Clear PIA
07m0001 07073 000700400615000443000000	        ALU[0] ADEST[DLSLINE]  [DEST[DLSLINE] DEST-A-MEM]LONG $ ;Clear receiver flag
07m0001 07074 000700600615000443000000	        ALU[0] ADEST[DLSACT]  [DEST[DLSACT] DEST-A-MEM]LONG $ ;All transmitters off
07m0001 07075 000712200615000443600000	        ALU[0] DEST[IOD AR] SPEC[IOB-OUT] LONG $ ;Let go of MR
07m0001                               	        MAPF[DLSCSR] LONG
07m0001                               	DLSINI
07m0001                               	 [
07m0001                               	DLSGRP[0 0 247 32]       [
07m0001 07076 000740014571000000100000	        D[CONST 0 - 0] LLOAD $
07m0001 07077 640040014171000320000000	        D[CONST 32] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07100 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07101 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07102 640250000433000440007077	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Line 0 300 baud
07m0001                               	DLSGRP[1 3 247 23]       [
07m0001 07103 000740014571000020000000	        D[CONST 3 - 1] LLOAD $
07m0001 07104 640040014171000230000000	        D[CONST 23] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07105 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07106 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07107 640250000433000440007104	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Lines 1-3 150/1200    *** Temp.
07m0001                               	DLSGRP[4 DLSNLINES 247 34]       [
07m0001 07110 000740014571000330000000	        D[CONST DLSNLINES - 4] LLOAD $
07m0001 07111 640040014171000340000000	        D[CONST 34] DEST[Q] PUSHJ[DLSSCR2] NORM $
07m0001 07112 640700014171014020000000	        D[CONST 247 / 100] ROT[6] DEST[Q] NORM $
07m0001 07113 640040014175000470000000	        D[CONST 247 & 77] ALU[DORQ] DEST[Q] PUSHJ[DLSSCR1] NORM $
07m0001 07114 640250000433000440007111	        D[AR] ALU[D+1] DEST[AR] LOOP[. - 3] NORM $
07m0001                               	];Lines 4-LAST 9600
07m0002 07115 640040014171000000000000	]       D[CONST 0] DEST[Q] PUSHJ[DLSCINT] NORM $
07m0002                               	.REPEAT DLS2 [
07m0002                               	        D[CONST 20] ROT[21.] DEST[Q] PUSHJ[DLSCINT] NORM $
07m0002                               	] [
07m0002 07116 640040014171052200000000	        D[CONST 20] ROT[21.] DEST[Q] PUSHJ[DLSCINT] NORM $
07m0002                               	];DLS2
07m0002 07117 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0002 07120 440300000571000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] POPJ $
07m0002                               	DLSCINT:
07m0002                               	.REPEAT DLS2 [
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

07m0002                               	        D[CONST 1] ROT[26.] ALU[DORQ] DEST[IOD Q] SPEC[IOB-OUT]
07m0002                               	                        NORM $
07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002                               	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM $
07m0002                               	        D[10 + DLSTMP] DLSNOIRQ POPJ LONG $
07m0002                               	] [
07m0002                               	        D[CONST 1] ROT[26.] ALU[DORQ] DEST[IOD Q] SPEC[IOB-OUT]
07m0002 07121 640702214175064013600000	                        NORM $
07m0002 07122 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07123 000701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM $
07m0002 07124 011300060571022440000000	        D[10 + DLSTMP] DLSNOIRQ  [ROT[9.] COND[OBUS<0]]POPJ LONG $
07m0002                               	];DLS2
07m0002                               	DLSCINT1:       DLSRINT  [
07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
07m0002 07125 640702200417000443740000	                ALU[Q+1] DEST[IOD] NORM $
07m0002                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
07m0002 07126 440702214437050013640000	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
07m0002 07127 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
07m0002 07130 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
07m0002 07131 240701030571000443040000	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07132 011300060571022440000000	        D[10 + DLSTMP] ]DLSNOIRQ  [ROT[9.] COND[OBUS<0]]POPJ $
07m0002 07133 000700000571000440000000	        NOP LONG $
07m0002 07134 000140000571000440007125	        JUMP[DLSCINT1] $
07m0002 07135 640700000175052440000000	DLSSCR1:        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
07m0002                               	        DLSWRITE[DLSCR1] 
07m0002 07136 000700014175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
07m0002                               	                ;Set TTY number
07m0002 07137 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;SET CS
07m0002 07140 000702214575046013600000	        MAPF[DLSCR1] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP CS, SET WE
07m0002 07141 000702200555000443600000	        MAPF[DLSCR1] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP WE.
07m0002 07142 000700000571000443740000	        MAPF[DLSCR1 + DLSNOSEL] SPEC[IOB-OUT] $
07m0002                               	        MAPF[DLSCR1 + DLSNOSEL]                 ;Finish the last IOB-OUT
07m0002 07143 640300000571000440140000	]POPJ NORM $
07m0002 07144 640700000175052440000000	DLSSCR2:        D[AR] ROT[21.] ALU[DORQ] DEST[Q] NORM $
07m0002                               	        DLSWRITE[DLSCR2] 
07m0002 07145 000700014175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
07m0002                               	                ;Set TTY number
07m0002 07146 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;SET CS
07m0002 07147 000702214575046013610000	        MAPF[DLSCR2] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP CS, SET WE
07m0002 07150 000702200555000443610000	        MAPF[DLSCR2] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
07m0002                               	                ;DROP WE.
07m0002 07151 000700000571000443750000	        MAPF[DLSCR2 + DLSNOSEL] SPEC[IOB-OUT] $
07m0002                               	        MAPF[DLSCR2 + DLSNOSEL]                 ;Finish the last IOB-OUT
07m0002 07152 640300000571000440150000	]POPJ NORM $
07m0002                               	
07m0002                               	;-----------------------------------------------------------------------
07m0002                               	;DLS interrupts are fairly straight-forward.  The micro-interrrupt
07m0002                               	;is turned off, the status of the line is obtained, and if enabled, a
07m0002                               	;macro interrupt is requested.  The macro interrupt is responsible for
07m0002                               	;executing some CONO,DATAI,DATAO which restarts the scanner by enabling
07m0002                               	;micro interrupts again.
07m0002                               	;-----------------------------------------------------------------------
SLOE   Jan ***, 1859 00:00:03  file DSK:DLS.SLO  --  of -- f2x

07m0002                               	DLSINT:
07m0002                               	: DLSVECTOR     ;Entry to interrupt
07m0002 02137 640142200615000443607153	        ALU[0] DEST[IOD] SPEC[IOB-OUT] JUMP[DLSINT] NORM $ ;Disable int.
07m0002                               	: DLSINT
07m0002                               	.REPEAT DLS2 [
07m0002                               	        MAPF[DLSCSR] D[CONST 3] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT]
07m0002                               	                        CYLEN[IOB-OUT] $
07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002                               	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002                               	        D[10 + DLSTMP] DLSIRQ JUMP[DLSINT1] $
07m0002                               	        D[CONST 2] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT] NORM $
07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002                               	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002                               	        D[10 + DLSTMP] C550 DLSNOIRQ JUMP[DLSIGNORE] $
07m0002                               	] [
07m0002                               	        MAPF[DLSCSR] D[CONST 3] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT]
07m0002 07153 440702214171062033700000	                        CYLEN[IOB-OUT] $
07m0002 07154 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07155 240701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07156 031140060571022440000000	        D[10 + DLSTMP] DLSIRQ  [ROT[9.] COND[-OBUS<0]]JUMP[DLSINT1] $
07m0002 07157 640702214171062023600000	        D[CONST 2] ROT[25.] DEST[Q IOD] SPEC[IOB-OUT] NORM $
07m0002 07160 440700000571000443540000	        MAPF[DLSNOSEL] SPEC[IOB-IN] CYLEN[IOB-OUT] $
07m0002 07161 240701030571000443140000	        MAPF[DLSNOSEL] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07162 511140060571022440000000	        D[10 + DLSTMP] C550 DLSNOIRQ  [ROT[9.] COND[OBUS<0]]JUMP[DLSIGNORE] $
07m0002                               	];DLS2
07m0002                               	DLSINT1:        DLSRINT  [
07m0002                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT]
07m0002 07163 640702200417000443740000	                ALU[Q+1] DEST[IOD] NORM $
07m0002                               	        MAPF[DLSIACK] CYLEN[IOB-OUT] SPEC[IOB-OUT] 
07m0002 07164 440702214437050013640000	                D[CONST 1] ROT[20.] ALU[D+Q+1] DEST[IOD] $
07m0002 07165 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
07m0002 07166 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
07m0002 07167 240701030571000443040000	        MAPF[DLSIACK] D[IOD] DEST[DLSTMP] DEST-A-MEM C800 $
07m0002 07170 000704460571000440000000	        D[10 + DLSTMP] ]DEST[HOLD] $
07m0002                               	.REPEAT 1 - DLS2 [
07m0002                               	        D[MEM] DLSNOIRQ JUMP[DLSIGNORE] C550 $
07m0002                               	]
07m0002 07171 640710004571102040000000	        D[MEM] ROT[33.] MASK[4] DEST[AR] NORM $
07m0002 07172 640710000575052440000000	        D[AR] ROT[21.] ALU[DORQ] DEST[AR] NORM $
07m0002 07173 640711200571036050000000	        D[AR] ROT[15.] MASK[DLSLNSIZE] DEST[AR ROTR] NORM $
07m0002 07174 640710000571044440000000	        D[AR] ROT[18.] DEST[AR] NORM $
07m0002 07175 511140004571102440000000	        D[MEM] ROT[33.] COND[OBUS<0] JUMP[DLSRCVINT] C550 $
07m0002 07176 531140054571200440000000	        ASRC[DLSACT]  [D[10 + DLSACT]]ROT[R] COND[-OBUS<0] JUMP[DLSIGNORE] C550 $
07m0002 07177 640700400571000443000000	        D[AR] ADEST[DLSLINE]  [DEST[DLSLINE] DEST-A-MEM]NORM $
07m0002 07200 650150044171000440000000	        ASRC[DLSPICHN]  [D[10 + DLSPICHN]]DEST[AR Q] COND[OBUS=0] JUMP[DLSCH0] NORM $
07m0002 07201 640140214575006063004562	        D[CONST 6] ROT[3] ALU[DORQ] ADEST[DLSPICHN]  [DEST[DLSPICHN]
07m0002                               	 DEST-A-MEM]JUMP[PIGEN] NORM $
07m0002 07202 640140214575006063002026	DLSCH0: D[CONST 6] ROT[3] ALU[DORQ] ADEST[DLSPICHN]  [DEST[DLSPICHN]
07m0002                               	 DEST-A-MEM]JUMP[MAIN] NORM $
07m0002 07203 640700000171006440000000	DLSRCVINT:      D[AR] ROT[3] DEST[Q] NORM $
07m0002                               	        DLSREAD[DLSSTAT HOLD 8.] 
07m0002 07204 000702214175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
07m0002                               	                ;Set TTY number  -- FBUS 9
07m0002 07205 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
07m0002                               	                ;Assert CS
07m0002 07206 440700000571000440020000	        MAPF[DLSSTAT] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
07m0002 07207 000702214171064013420000	        MAPF[DLSSTAT] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

07m0002                               	                ;Setup to drop CS, start read
07m0002 07210 000704430571000103760000	        MAPF[DLSSTAT + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[HOLD] SPEC[IOB-OUT] $
07m0002                               	                ;Finish read, drop CS
07m0002 07211 000700000571000440160000	        MAPF[DLSSTAT + DLSNOSEL] $
07m0002                               	        MAPF[DLSSTAT + DLSNOSEL]  ]D[MEM] ROT[34.]
07m0002 07212 531140004571104440160000	                COND[-OBUS<0] JUMP[DLSIGNORE] C550 $
07m0002 07213 640700000171006440000000	        D[AR] ROT[3] DEST[Q] NORM $
07m0002                               	        DLSREAD[DLSHOLD Q 8.] 
07m0002 07214 000702214175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
07m0002                               	                ;Set TTY number  -- FBUS 9
07m0002 07215 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
07m0002                               	                ;Assert CS
07m0002 07216 440700000571000440030000	        MAPF[DLSHOLD] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
07m0002 07217 000702214171064013430000	        MAPF[DLSHOLD] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
07m0002                               	                ;Setup to drop CS, start read
07m0002 07220 000700030171000103770000	        MAPF[DLSHOLD + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[Q] SPEC[IOB-OUT] $
07m0002                               	                ;Finish read, drop CS
07m0002 07221 000700000571000440170000	        MAPF[DLSHOLD + DLSNOSEL] $
07m0002 07222 640704400433070440170000	        MAPF[DLSHOLD + DLSNOSEL]  ]D[AR] ROT[28.] ALU[D+1] DEST[HOLD] NORM $
07m0002 07223 640700404575020443000000	        D[MEM] ROT[8.] ALU[DORQ] ADEST[DLSLINE]  [DEST[DLSLINE] DEST-A-MEM]NORM $
07m0002 07224 650150044171000030000000	        ASRC[DLSPICHN]  [D[10 + DLSPICHN]]MASK[3] DEST[AR Q] COND[OBUS=0] JUMP[DLSRCVIGN]
07m0002                               	 NORM $
07m0002 07225 640140214575006053004562	        D[CONST 5] ROT[3] ALU[DORQ] ADEST[DLSPICHN]  [DEST[DLSPICHN]
07m0002                               	 DEST-A-MEM]JUMP[PIGEN] NORM $
07m0002 07226 640140214575006053002026	DLSRCVIGN:      D[CONST 5] ROT[3] ALU[DORQ] ADEST[DLSPICHN]  [DEST[DLSPICHN]
07m0002                               	 DEST-A-MEM]JUMP[MAIN] NORM $
07m0002 07227 640702214571066013600000	DLSIGNORE:      D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
07m0002 07230 440150000215000440102026	        MAPF[DLSCSR] CYLEN[IOB-OUT] ALU[0] DEST[AR Q] JUMP[MAIN] $
07m0002                               	

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

45m0164                               	
45m0164                               	.REPEAT DLSDEB [
45m0164                               	.INSERT DLSDEB.SLO
45m0164                               	];[
45m0164                               	.INSERT DLSDEB.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:DLSDEB.SLO  --  of -- f2x

01m0001                               	;DLS DEBUGGING IOTS
01m0001                               	
01m0001                               	.DEFINE SETLIN [ ] [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]
01m0001                               	
01m0001                               	.DEFINE MJUMP[X] [D[AR] ALU[DORQ] DEST[Q] JUMP[X] NORM]
01m0001                               	
01m0001                               	;;;;;  DWP 1/27/80:7600
01m0001                               	DLS.DEB:
01m0001                               	:DLSDISP2 + 20          ;IOT DISPATCH FOR DEVICE 374
01m0001                               	
01m0001 07007 640040010171000100000000	SETLIN  [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                   ;BLKI 374 = READ
01m0001                               	 CR1
01m0001 07010 640140000571000440000000	JUMP[DLS.RCR1] NORM $
01m0001                               	
01m0001 07011 640040010171000100000000	SETLIN  [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                   ;DATAI 374 = READ
01m0001                               	 CR2
01m0001 07012 640140000571000440000000	JUMP[DLS.RCR2] NORM $
01m0001                               	
01m0001 07013 640040010171000100000000	SETLIN  [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                   ;BLKO 374 = READ
01m0001                               	 STAT
01m0001 07014 640140000571000440000000	JUMP[DLS.RSTAT] NORM $
01m0001                               	
01m0001 07015 640040010171000100000000	SETLIN  [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                   ;DATAO 374 = READ
01m0001                               	 HOLD
01m0001 07016 640140000571000440000000	JUMP[DLS.RHOLD] NORM $
01m0001                               	
01m0001 07017 640040010171000100000000	SETLIN  [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                   ;CONO 374 = WRITE
01m0001                               	 CR1
01m0001 07020 640140000175000440000000	MJUMP[DLS.WCR1]  [D[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WCR1] NORM]$
01m0001                               	
01m0001 07021 640040010171000100000000	SETLIN  [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                   ;CONI 374 = WRITE
01m0001                               	 CR2
01m0001 07022 640140000175000440000000	MJUMP[DLS.WCR2]  [D[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WCR2] NORM]$
01m0001                               	
01m0001 07023 640040010171000100000000	SETLIN  [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                   ;CONSZ 374 =
01m0001                               	 WRITE STAT (SYN,DLE)
01m0001 07024 640140000175000440000000	MJUMP[DLS.WSTAT]  [D[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WSTAT] NORM]$
01m0001                               	
01m0001 07025 640040010171000100000000	SETLIN  [D[MASK[8.]] DEST[Q] PUSHJ[DLS.SETLIN] NORM]$                   ;CONSO 374 =
01m0001                               	 WRITE HOLD
01m0001 07026 640140000175000440000000	MJUMP[DLS.WHOLD]  [D[AR] ALU[DORQ] DEST[Q] JUMP[DLS.WHOLD] NORM]$
01m0001                               	
01m0001                               	:DLS.DEB
01m0001                               	
01m0001 07231 640706000550400440020000	DLS.SETLIN:     FIXM1 $                 ;SETUP LINE # IN Q
01m0001 07232 640710004635000440000000	        D[MEM] ALU[D&Q] DEST[AR] NORM $
01m0001 07233 640700010171052050000000	        D[MASK[DLSLNSIZE]] ROT[21.] DEST[Q] NORM $
01m0001 07234 640300004235006440000000	        D[MEM] ROT[3] ALU[D&Q] DEST[Q] POPJ NORM $
01m0001                               	
01m0001                               	DLS.RCR1:       DLSREAD[DLSCR1 AR 8.] 
01m0001 07235 000702214175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07236 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07237 440700000571000440000000	        MAPF[DLSCR1] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07240 000702214171064013400000	        MAPF[DLSCR1] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

01m0001 07241 000710030571000103740000	        MAPF[DLSCR1 + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07242 000700000571000440140000	        MAPF[DLSCR1 + DLSNOSEL] $
01m0001 07243 000140000571000440140000	        MAPF[DLSCR1 + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RCR2:       DLSREAD[DLSCR2 AR 8.] 
01m0001 07244 000702214175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07245 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07246 440700000571000440010000	        MAPF[DLSCR2] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07247 000702214171064013410000	        MAPF[DLSCR2] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07250 000710030571000103750000	        MAPF[DLSCR2 + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07251 000700000571000440150000	        MAPF[DLSCR2 + DLSNOSEL] $
01m0001 07252 000140000571000440150000	        MAPF[DLSCR2 + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RSTAT:      DLSREAD[DLSSTAT AR 8.] 
01m0001 07253 000702214175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07254 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07255 440700000571000440020000	        MAPF[DLSSTAT] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07256 000702214171064013420000	        MAPF[DLSSTAT] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07257 000710030571000103760000	        MAPF[DLSSTAT + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07260 000700000571000440160000	        MAPF[DLSSTAT + DLSNOSEL] $
01m0001 07261 000140000571000440160000	        MAPF[DLSSTAT + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001                               	DLS.RHOLD:      DLSREAD[DLSHOLD AR 8.] 
01m0001 07262 000702214175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q IOD] $
01m0001                               	                ;Set TTY number  -- FBUS 9
01m0001 07263 000702214175050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[Q IOD] SPEC[IOB-OUT] $
01m0001                               	                ;Assert CS
01m0001 07264 440700000571000440030000	        MAPF[DLSHOLD] CYLEN[IOB-OUT] $ ;TIME FOR CHIP TO SELECT
01m0001 07265 000702214171064013430000	        MAPF[DLSHOLD] D[CONST 1] ROT[26.] DEST[Q IOD] SPEC[IOB-IN] $
01m0001                               	                ;Setup to drop CS, start read
01m0001 07266 000710030571000103770000	        MAPF[DLSHOLD + DLSNOSEL] D[IOD] MASK[8.] ALU[D] DEST[AR] SPEC[IOB-OUT] $
01m0001                               	                ;Finish read, drop CS
01m0001 07267 000700000571000440170000	        MAPF[DLSHOLD + DLSNOSEL] $
01m0001 07270 000140000571000440170000	        MAPF[DLSHOLD + DLSNOSEL]  ]JUMP[DLS.READ] $
01m0001                               	
01m0001 07271 640700010171000100000000	DLS.READ:       D[MASK[8.]] DEST[Q] NORM $
01m0001 07272 640700000235000440000000	        D[AR] ALU[D&Q] DEST[Q] NORM $
01m0001 07273 662104204575000000202032	        D[MEM] SPEC[LEFT] ALU[DORQ] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM
01m0001                               	 ]$
01m0001                               	
01m0001                               	DLS.WCR1:       DLSWRITE[DLSCR1] 
01m0001 07274 000700014175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07275 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07276 000702214575046013600000	        MAPF[DLSCR1] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP CS, SET WE
01m0001 07277 000702200555000443600000	        MAPF[DLSCR1] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

01m0001                               	                ;DROP WE.
01m0001 07300 000700000571000443740000	        MAPF[DLSCR1 + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSCR1 + DLSNOSEL]                 ;Finish the last IOB-OUT
01m0001 07301 000140000571000440142026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WCR2:       DLSWRITE[DLSCR2] 
01m0001 07302 000700014175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07303 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07304 000702214575046013610000	        MAPF[DLSCR2] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP CS, SET WE
01m0001 07305 000702200555000443610000	        MAPF[DLSCR2] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07306 000700000571000443750000	        MAPF[DLSCR2 + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSCR2 + DLSNOSEL]                 ;Finish the last IOB-OUT
01m0001 07307 000140000571000440152026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WSTAT:      DLSWRITE[DLSSTAT] 
01m0001 07310 000700014175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07311 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07312 000702214575046013620000	        MAPF[DLSSTAT] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	
01m0001                               	                ;DROP CS, SET WE
01m0001 07313 000702200555000443620000	        MAPF[DLSSTAT] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07314 000700000571000443760000	        MAPF[DLSSTAT + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSSTAT + DLSNOSEL]                ;Finish the last IOB-OUT
01m0001 07315 000140000571000440162026	]JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.WHOLD:      DLSWRITE[DLSHOLD] 
01m0001 07316 000700014175064010000000	[       D[CONST 1] ROT[26.] ALU[DORQ] DEST[Q] $
01m0001                               	                ;Set TTY number
01m0001 07317 000702214575050013600000	        D[CONST 1] ROT[20.] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;SET CS
01m0001 07320 000702214575046013630000	        MAPF[DLSHOLD] D[CONST 1] ROT[35. - DLSWEBIT] ALU[DORQ] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	
01m0001                               	                ;DROP CS, SET WE
01m0001 07321 000702200555000443630000	        MAPF[DLSHOLD] ALU[Q] DEST[IOD] SPEC[IOB-OUT] $
01m0001                               	                ;DROP WE.
01m0001 07322 000700000571000443770000	        MAPF[DLSHOLD + DLSNOSEL] SPEC[IOB-OUT] $
01m0001                               	        MAPF[DLSHOLD + DLSNOSEL]                ;Finish the last IOB-OUT
01m0001 07323 000140000571000440172026	]JUMP[MAIN] $
01m0001                               	
01m0001 07324 000140000571000440007324	DLS.INT:        JUMP[.] $
01m0001 07325 000140000571000440007326	        JUMP[. + 1] $
01m0001 07326 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0001 07327 440700000571000440100000	        MAPF[DLSCSR] CYLEN[IOB-OUT] $
01m0001 07330 000142400571000440002026	        DEST[CLR-DEV-FROM-INTR] JUMP[MAIN] $
01m0001                               	
01m0001                               	DLS.RINT:
01m0001                               	: DLSDISP2 + 0  ;BLKI 370 - GET INTERRUPT STATUS
01m0001 06767 000140000571000440006767	        JUMP[.] $
01m0001 06770 000140000571000440007331	        JUMP[DLS.RINT] $
01m0001                               	: DLS.RINT
SLOE   Jan ***, 1859 00:00:03  file DSK:DLSDEB.SLO  --  of -- f2x

01m0001 07331 640700014171064010000000	        D[CONST 1] ROT[26.] DEST[Q] NORM $
01m0001                               	        MAPF[DLSNOSEL] SPEC[IOB-OUT] D[CONST 1] ROT[20.]
01m0001 07332 640702214437050013740000	                ALU[D+Q+1] DEST[IOD] NORM $
01m0001 07333 440700000571000440140000	        MAPF[DLSNOSEL] CYLEN[IOB-OUT] $
01m0001 07334 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07335 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07336 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07337 000700000571000440040000	        MAPF[DLSIACK] LONG $
01m0001 07340 000702200555000443640000	        MAPF[DLSIACK] SPEC[IOB-OUT] ALU[Q] DEST[IOD] LONG $
01m0001 07341 000700000571000443440000	        MAPF[DLSIACK] SPEC[IOB-IN] LONG $
01m0001 07342 140700030171000440040000	        MAPF[DLSIACK] CYLEN[IOB-IN] D[IOD] DEST[Q] $
01m0001 07343 662104200555000440002032	        ALU[Q] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0001                               	
01m0001                               	DLS.EINT:
01m0001                               	: DLSDISP2 + 4  ;BLKO 370 - ENABLE INTERRUPT
01m0001 06773 000140000571000440006773	        JUMP[.] $
01m0001 06774 000140000571000440007344	        JUMP[DLS.EINT] $
01m0001                               	:DLS.EINT
01m0001 07344 640702214571066013600000	        D[CONST 1] ROT[27.] DEST[IOD] SPEC[IOB-OUT] NORM $
01m0001 07345 440140000571000440102026	        MAPF[DLSCSR] CYLEN[IOB-OUT] JUMP[MAIN] $

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

45m0164                               	]DLSDEB
45m0164                               	];DLS2
45m0164                               	.REPEAT 1 - DLS2 [
45m0164                               	.INSERT ODLS.SLO
45m0164                               	.REPEAT DLSDEB [
45m0164                               	.INSERT ODLSDE.SLO
45m0164                               	] ;DLSDEB
45m0164                               	] ;1 - DLS2
45m0164                               	
45m0164                               	]DLS                    9 JAN 80  BO
45m0164                               	
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Line Printer Interface (LPT)
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT LPT [
45m0164                               	
45m0164                               	.INSERT LPTX.SLO        
45m0164                               	
45m0164                               	];LPT
45m0164                               	
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	;
45m0164                               	;       Versatec Interface (VC)
45m0164                               	;
45m0164                               	;------------------------------------------------------------------------------
45m0164                               	.REPEAT VC [
45m0164                               	
45m0164                               	.INSERT VC.SLO
45m0164                               	
45m0164                               	]
45m0164                               	[
45m0164                               	
45m0164                               	.INSERT VC.SLO

SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- f2x

01m0001       0	VCDEB = 0       ; Nonzero for debugging microcode
01m0001                               	
01m0001       2026	VCBAD = MAIN
01m0001                               	
01m0001                               	; Versatec now has its own device code 520, with 524 reserved for a second VC.
01m0001                               	VCDSP:  
01m0001                               	:. + 20         ;Reserve space for dispatch table
01m0001                               	;Let's save this for a second VC
01m0001                               	.REPEAT 10 [    ILGIOT $
01m0001                               	                NOP $
01m0001                               	];[     ILGIOT 
01m0001 07366 000140000571000440002026	[  JUMP [MAIN] ]$
01m0001 07367 000700000571000440000000	                NOP $
01m0001                               	][      ILGIOT 
01m0001 07370 000140000571000440002026	[  JUMP [MAIN] ]$
01m0001 07371 000700000571000440000000	                NOP $
01m0001                               	][      ILGIOT 
01m0001 07372 000140000571000440002026	[  JUMP [MAIN] ]$
01m0001 07373 000700000571000440000000	                NOP $
01m0001                               	][      ILGIOT 
01m0001 07374 000140000571000440002026	[  JUMP [MAIN] ]$
01m0001 07375 000700000571000440000000	                NOP $
01m0001                               	][      ILGIOT 
01m0001 07376 000140000571000440002026	[  JUMP [MAIN] ]$
01m0001 07377 000700000571000440000000	                NOP $
01m0001                               	][      ILGIOT 
01m0001 07400 000140000571000440002026	[  JUMP [MAIN] ]$
01m0001 07401 000700000571000440000000	                NOP $
01m0001                               	][      ILGIOT 
01m0001 07402 000140000571000440002026	[  JUMP [MAIN] ]$
01m0001 07403 000700000571000440000000	                NOP $
01m0001                               	][      ILGIOT 
01m0001 07404 000140000571000440002026	[  JUMP [MAIN] ]$
01m0001 07405 000700000571000440000000	                NOP $
01m0001                               	].REPEAT 10
01m0001                               	
01m0001                               	VCORG:          ; Origin of Versatec code
01m0001                               	
01m0001                               	; Versatec driver definitions and register usage
01m0001                               	;
01m0001                               	; CONO - command out.  Takes (E) as
01m0001                               	;               Bits 0-15: Command to Versatec
01m0001                               	;               Bits 16-29: Unused
01m0001                               	;               Bit 30: Enable interrupt on READY
01m0001                               	;               Bits 31-32: Mode 00 - unused (same as mode 01)
01m0001                               	;                                01 - 7-bit bytes, 5 per word, left justified
01m0001                               	;                                10 - 8-bit bytes, 4 per word, left justified
01m0001                               	;                                11 - 8-bit bytes, 9 per two words
01m0001                               	;               Bits 33-35: PI channel
01m0001                               	;
01m0001                               	; CONI - status in.  Puts in E
01m0001                               	;               Bits 0-17: Zero, except
01m0001                               	;                       3-4, 10-11: State of corresponding
01m0001                               	;                                       command out bits.
01m0001                               	;               Bits 18-23: Status bits from Versatec
01m0001                               	;               Bit 24: Reserved
01m0001                               	;               Bit 25: Versatec READY bit
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- f2x

01m0001                               	;               Bit 26: Data ready bit
01m0001                               	;               Bits 27-29: zero
01m0001                               	;               Bit 30: ENB-RDY-INT
01m0001                               	;               Bits 31-35: Mode and PI from last command out
01m0001                               	;
01m0001                               	; CONSZ, CONSO - Test right half of above CONI bits.
01m0001                               	;
01m0001                               	; DATAO - Start output.  Takes (E) as
01m0001                               	;               Bits 0-17: 2's complement byte count (0 means 256K bytes)
01m0001                               	;               Bits 18-35: Starting memory address
01m0001                               	;       This operation sets Busy, clears Done, and starts the output.
01m0001                               	;       When output finishes, Busy clears and Done sets.
01m0001                               	;
01m0001                               	; The following are debugging aids
01m0001                               	;
01m0001                               	; BLKI - Enters the interrupt routine.
01m0001                               	; DATAI - Returns the remaining byte count/MA.
01m0001                               	; BLKO - Unused.
01m0001                               	;
01m0001                               	; A-MEM Usage:  0 - Interrupt Dispatch
01m0001                               	;               1 - MA saved between bursts
01m0001                               	;               2 - byte count saved between bursts
01m0001                               	;               3 - Constants depending on Mode
01m0001                               	;                       Bit 35: 0 for modes 1&2, 1 for mode 3
01m0001                               	;                       Bits 32-34: Bytes/Word - 1
01m0001                               	;                       Bits 25-31: Bytes/burst
01m0001                               	;               4 - Command/Status Register
01m0001                               	;               5 - Mask for command bits that are levels.
01m0001                               	;               6 - Saved AC during output burst
01m0001                               	;               7 - Saved PC during output burst
01m0001                               	;
01m0001                               	; Other registers:
01m0001                               	;               PC - Addresses memory during output
01m0001                               	;               AC - Counts bytes during output
01m0001                               	;               Loop Count - counts bytes in a word
01m0001                               	;               Q, AR, HOLD - temporary
01m0001                               	;
01m0001                               	: VCDSP + 0
01m0001                               	.REPEAT 1 - VCDEB [     ; Make debugging ops illegal (NOP)
01m0001                               	.repeat 3 [     ILGIOT $ NOP $
01m0001                               	] ; .REPEAT 3
01m0001                               	] [     ; Make debugging ops illegal (NOP)
01m0001                               	.repeat 3 [     ILGIOT $ NOP $
01m0001                               	] [     ILGIOT 
01m0001 07346 000140000571000440002026	[  JUMP [MAIN] ]$ NOP $
01m0001 07347 000700000571000440000000	
01m0001                               	][      ILGIOT 
01m0001 07350 000140000571000440002026	[  JUMP [MAIN] ]$ NOP $
01m0001 07351 000700000571000440000000	
01m0001                               	][      ILGIOT 
01m0001 07352 000140000571000440002026	[  JUMP [MAIN] ]$ NOP $
01m0001 07353 000700000571000440000000	
01m0001                               	]; .REPEAT 3
01m0001                               	]; .REPEAT 1 - VCDEB
01m0001                               	
01m0001                               	.REPEAT VCDEB [         ; BLKI - act like the Versatec interrupted
01m0001                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- f2x

01m0001                               	        JUMP[.] NORM $
01m0001                               	        D[CONST VCDEV] DEST[DEV-ADR] JUMP[VCINT] NORM $
01m0001                               	]
01m0001                               	
01m0001                               	: VCORG + 2     ; Dispatch base and interrupt entry
01m0001                               	
01m0001                               	; Dispatch for modes 1-3 relative to the vector (2 words/entry)
01m0001                               	;               Set burst count for the mode
01m0001 07410 640700014171014170000000	        D[CONST 17] ROT[6] DEST[Q] NORM $ ;Mode 1 - 60 bytes/burst, 5 bytes/word
01m0001 07411 640140614575000103000000	        D[CONST 10] ALU[DORQ] DEST[3] SPEC[DEST-A-MEM] JUMP[VCSET2] NORM $
01m0001                               	;
01m0001 07412 640700014171014200000000	        D[CONST 20] ROT[6] DEST[Q] NORM $ ;Mode 2 - 64 bytes/burst, 4 bytes/word
01m0001 07413 640140614575000063000000	        D[CONST 06] ALU[DORQ] DEST[3] SPEC[DEST-A-MEM] JUMP[VCSET2] NORM $
01m0001                               	;
01m0001 07414 640700014171014170000000	        D[CONST 17] ROT[6] DEST[Q] NORM $ ;Mode 3 - 63 bytes/burst, 4 bytes/word
01m0001 07415 640140614575000673000000	        D[CONST 67] ALU[DORQ] DEST[3] SPEC[DEST-A-MEM] JUMP[VCSET2] NORM $
01m0001                               	;
01m0001                               	VCINT:          ;Interrupt routine
01m0001                               	
01m0001                               	: VCORG
01m0001                               	.REPEAT VCDEB [
01m0001                               	        JUMP[.] NORM $
01m0001                               	        JUMP[VCINT] NORM $
01m0001                               	: VCINT
01m0001                               	]
01m0001 07406 640702200615000443600000	        ALU[0] DEST[IOD] SPEC[IOB-OUT] NORM $ ;Disable interrupts
01m0001                               	        MAPF[4] CYLEN[IOB-OUT] SPEC[IOB-OUT]
01m0001                               	.REPEAT VCDEB [ $ ] 
01m0001                               	.REPEAT 1 - VCDEB [ JUMP[VCINT] $
01m0001                               	: VCINT
01m0001                               	]
01m0001 07407 440140000571000443647416	[ JUMP[VCINT] $
01m0001                               	: VCINT
01m0001 07416 440700000571000443600000	]       MAPF[0] SPEC[IOB-OUT] CYLEN[IOB-OUT] $ ; Clear lat-byte bit
01m0001                               	        MAPF[5] CYLEN[IOB-OUT] ; Clear request
01m0001 07417 470140050571000440050000	                D[12] COND[-OBUS=0] JUMP[VCGO] $ ;Output if count/= 0
01m0001                               	
01m0001 07420 640700060171000440000000	        D[14] DEST[Q] NORM $ ; Fetch status register
01m0001 07421 511140060571074440000000	        D[14] ROT[30.] COND[OBUS<0] JUMP[VCINT2] C550 $
01m0001                               	
01m0001                               	; End of data transfer.  Set data ready bit.
01m0001                               	        D[CONST 1] ROT[9.] ALU[DORQ] DEST[4]
01m0001 07422 640141014575022013000000	                SPEC[DEST-A-MEM] JUMP[VCINT3] NORM $
01m0001                               	
01m0001                               	; READY interrupt.  Clear ready int enable bit.
01m0001                               	VCINT2: D[CONST 1] ROT[5] ALU[-D&Q] DEST[4]
01m0001 07423 640701014675012013000000	                SPEC[DEST-A-MEM] NORM $
01m0001                               	 
01m0001                               	VCINT3: D[14] MASK[3] DEST[AR Q CLR-DEV-FROM-INTR]
01m0001 07424 530152460171000030004562	                COND[-OBUS=0] JUMP[PIGEN] C550 $ ; Macro int if enabled
01m0001 07425 640140000571000440002026	        JUMP[MAIN] NORM $
01m0001                               	
01m0001                               	;IOT dispatch
01m0001                               	        .PAIR
01m0001                               	 [:. \ 2 + .
01m0002 07426 010140020571016010002100	]       D[PC] ROT[6 + 1] MASK[1] COND[OBUS=0] JUMP[MUUO] $
01m0002                               	                ;Trap if User and not IOT-USER
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- f2x

01m0002 07427 640700034171034040000000	VCIOT:  D[IR] ROT[12. + 1 + 1] MASK[4] DEST[Q] NORM $
01m0002                               	                ;Extract IOT decode * 2.  Note we can do this because the
01m0002                               	                ;machine has already done indexing/indirection and bits
01m0002                               	                ;13:17 are guaranteed zero
01m0002 07430 540540040435044200000000	        D[10] ROT[18.] MASK[16.] ALU[D+Q] SDISP CYLEN[DISP] $
01m0002                               	                ;Dispatch of type of IOT
01m0002                               	
01m0002                               	;
01m0002                               	; Command out to Versatec
01m0002                               	
01m0002                               	VCCMD:
01m0002                               	: VCDSP + 10 ; CONO dispatch
01m0002                               	.REPEAT VCDEB [
01m0002                               	        JUMP[.] NORM $
01m0002                               	        JUMP[VCCMD] NORM $
01m0002                               	: VCCMD
01m0002                               	]
01m0002 07356 640041614571000140000000	        D[CONST VCDEV] DEST[DEV-ADR] PUSHJ[VCONO] NORM $
01m0002 07357 000140000571000440002026	        JUMP[MAIN] $
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	: VCCMD
01m0002                               	]
01m0002                               	[
01m0002                               	: VCCMD
01m0002                               	]; Reset.
01m0002                               	
01m0002 07431 640700014171074060000000	VCRST:  D[CONST 6] ROT[30.] DEST[Q] NORM $ ; mask for VC mode bits
01m0002                               	        D[CONST 3] ROT[24.] ALU[DORQ]
01m0002 07432 640701214575060033000000	                DEST[5] SPEC[DEST-A-MEM] NORM $
01m0002                               	
01m0002 07433 000700014171060730000000	        D[CONST VCDSP / 100] ROT[6 + 18.] DEST[Q] $     ;Setup dispatch
01m0002                               	.IF VCDSP \ 100 /= 0 [
01m0002 07434 000700014175044460000000	        D[CONST VCDSP \ 100] ROT[18.] ALU[DORQ] DEST[Q] $
01m0002                               	]
01m0002                               	        D[CONST VCORG / 100] ROT[6] ALU[DORQ] DEST[0 Q] ;Interrupt base address
01m0002 07435 640700014175014743000000	                SPEC[DEST-A-MEM] NORM $
01m0002                               	.IF VCORG \ 100 /= 0 [
01m0002                               	        D[CONST VCORG \ 100] ALU[DORQ] DEST[0]
01m0002 07436 640700014575000063000000	                SPEC[DEST-A-MEM] NORM $
01m0002                               	]
01m0002 07437 640144414571000100000000	        D[CONST 10] DEST[HOLD] JUMP[VCONO0] NORM $ ; Invent CONO 124,[10]
01m0002                               	
01m0002                               	; CONO routine
01m0002                               	
01m0002 07440 640706000550400440020000	VCONO: FIXM1 $
01m0002                               	
01m0002                               	VCONO0: SPEC[IOB-OUT]
01m0002 07441 640710004571076013600000	        D[MEM] ROT[31.] MASK[1] DEST[AR] NORM $ ; Save int-on-rdy bit
01m0002                               	
01m0002                               	        MAPF[0] SPEC[IOB-OUT] CYLEN[IOB-OUT] ; Clear the FIFO
01m0002 07442 440702204171000443600000	        D[MEM] DEST[IOD Q] $ ;Set up the control bits
01m0002                               	
01m0002                               	        MAPF[1] SPEC[IOB-OUT] LONG ;Output control bits
01m0002 07443 000702264235000443610000	        D[15] ALU[D&Q] DEST[IOD Q] $ ;Clear the ones that pulse.
01m0002                               	
01m0002                               	        MAPF[5] SPEC[IOB-OUT] LONG ; Clear int req
01m0002 07444 000700004175000063650000	        D[MEM] MASK[6] ALU[DORQ] DEST[Q] $ ; Save the mode
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- f2x

01m0002                               	
01m0002                               	        MAPF[1] SPEC[IOB-OUT] LONG ; Clear the pulsed bits
01m0002 07445 000702200571004443610000	        D[AR] ROT[2] DEST[IOD] $ ;Set up the int-on-rdy bit
01m0002                               	
01m0002                               	        MAPF[4] CYLEN[IOB-OUT] ; Set interrupt enablings
01m0002                               	        D[CONST 1] ROT[9.] ALU[DORQ] DEST[4] ;Set data ready bit
01m0002 07446 440701014575022013040000	                SPEC[DEST-A-MEM] $
01m0002                               	
01m0002                               	        D[MEM] ROT[33.] MASK[2] DEST[AR] ;Extract the mode
01m0002 07447 510150004571102020000000	                COND[OBUS=0] JUMP[VCONO1] C550 $
01m0002 07450 640140000171002440000000	        D[AR] ROT[1] DEST[Q] JUMP[VCONO2] NORM $ ; Double mode to Q
01m0002                               	
01m0002 07451 640700014171002010000000	VCONO1: D[CONST 1] ROT[1] DEST[Q] NORM $ ;Change mode 0 to 1 and double
01m0002                               	
01m0002 07452 500540040435000440000000	VCONO2: D[10] ALU[D+Q] SDISP C550 $ ;Set up constants by mode.
01m0002                               	;
01m0002                               	; Back from setup of constants.  Clear byte count.
01m0002                               	;
01m0002 07453 000140400615000443002026	VCSET2: ALU[0] DEST[2] SPEC[DEST-A-MEM] JUMP[MAIN] $
01m0002                               	;
01m0002                               	; Read status/control bits
01m0002                               	
01m0002                               	VCSTAT:
01m0002                               	: VCDSP + 12 ; CONI dispatch
01m0002                               	
01m0002                               	.REPEAT VCDEB [
01m0002                               	        JUMP[.] NORM $
01m0002                               	        JUMP[VCSTAT] NORM $
01m0002                               	: VCSTAT
01m0002                               	]
01m0002 07360 640041614571000143400000	        D[CONST VCDEV] DEST[DEV-ADR] SPEC[IOB-IN] PUSHJ[VCGST] NORM $
01m0002                               	;               Fetch device status into AR.
01m0002 07361 662104200571000440002032	        D[AR] DEST[MEMSTO] MEMST  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	: VCSTAT
01m0002                               	]
01m0002                               	[
01m0002                               	: VCSTAT
01m0002                               	]VCONSZ:
01m0002                               	: VCDSP + 14 ; CONSZ dispatch
01m0002                               	.REPEAT VCDEB [
01m0002                               	        JUMP[.] NORM $
01m0002                               	        JUMP[VCONSZ] NORM $
01m0002                               	: VCONSZ
01m0002                               	] ; VCDEB
01m0002 07362 640041614571000143400000	        D[CONST VCDEV] DEST[DEV-ADR] SPEC[IOB-IN] PUSHJ[VCGST] NORM $
01m0002 07363 640140034171000220004470	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCZ] NORM $
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	: VCONSZ
01m0002                               	]
01m0002                               	[
01m0002                               	: VCONSZ
01m0002                               	]VCONSO:
01m0002                               	: VCDSP + 16 ; CONSO dispatch
01m0002                               	.REPEAT VCDEB [
01m0002                               	        JUMP[.] NORM $
01m0002                               	        JUMP[VCONSO] NORM $
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- f2x

01m0002                               	: VCONSO
01m0002                               	] ; VCDEB
01m0002 07364 640041614571000143400000	        D[CONST VCDEV] DEST[DEV-ADR] SPEC[IOB-IN] PUSHJ[VCGST] NORM $
01m0002 07365 640140034171000220004472	        D[IR] MASK[18.] DEST[Q] JUMP[CTYCS] NORM $
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	: VCONSO
01m0002                               	]
01m0002                               	[
01m0002                               	: VCONSO
01m0002                               	]
01m0002 07454 140710030571020100020000	VCGST:  MAPF[2] D[IOD] ROT[8.] MASK[8.] DEST[AR] CYLEN[IOB-IN] $
01m0002 07455 640700000171024440000000	        D[AR] ROT[10.] DEST[Q] NORM $ ;Merge status with command.
01m0002 07456 640310060575000440000000	        D[14] ALU[DORQ] DEST[AR] POPJ NORM $
01m0002                               	;
01m0002                               	VCOUNT:
01m0002                               	.REPEAT VCDEB [         ;BLKI - return byte count & MA.
01m0002                               	:VCDSP + 2
01m0002                               	        JUMP[.] $
01m0002                               	        D[CONST VCDEV] DEST[DEV-ADR] JUMP[VCOUNT] NORM $
01m0002                               	: VCOUNT
01m0002                               	        D[12] ROT[18.] MASK[0] SPEC[LEFT] DEST[Q] NORM $
01m0002                               	        D[11] MASK[18.] ALU[DORQ] DEST[MEMSTO] MEMST $
01m0002                               	]
01m0002                               	VCOUT:
01m0002                               	: VCDSP + 6 ; DATAO dispatch
01m0002                               	
01m0002                               	.REPEAT VCDEB [
01m0002                               	        JUMP[.] NORM $
01m0002                               	        JUMP[VCOUT] NORM $
01m0002                               	: VCOUT
01m0002                               	        FIXM1 $
01m0002                               	        D[CONST VCDEV] DEST[DEV-ADR] NORM $
01m0002                               	]
01m0002                               	.REPEAT 1 - VCDEB [
01m0002                               	        FIXM1 $
01m0002                               	        D[CONST VCDEV] DEST[DEV-ADR] JUMP[VCOUT] NORM $
01m0002                               	: VCOUT
01m0002                               	]
01m0002                               	[
01m0002 07354 640706000550400440020000	        FIXM1 $
01m0002 07355 640141614571000140007457	        D[CONST VCDEV] DEST[DEV-ADR] JUMP[VCOUT] NORM $
01m0002                               	: VCOUT
01m0002                               	];              Illegal op if BUSY is on.
01m0002 07457 510140060571066010002026	        D[14] ROT[27.] MASK[1] COND[OBUS=0] JUMP[VCBAD] CYLEN[C550] $
01m0002 07460 640700060171000440000000	        D[14] DEST[Q] NORM $
01m0002 07461 640701014675022013000000	        D[CONST 1] ROT[9.] ALU[-D&Q] DEST[4] SPEC[DEST-A-MEM] NORM $ ; Clear DONE
01m0002 07462 640700010171000000200000	        D[MASK 0] SPEC[LEFT] DEST[Q] NORM $ ;Pad byte count with ones in left.
01m0002 07463 640700404575044223000000	        D[MEM] ROT[18.] MASK[18.] ALU[DORQ] DEST[2] SPEC[DEST-A-MEM] NORM $
01m0002 07464 640700204571000223000000	        D[MEM] MASK[18.] DEST[1] SPEC[DEST-A-MEM] NORM $
01m0002                               	;
01m0002                               	VCGO:           ;Q gets 0 for 7-bit bytes, 1 for 8-bit.
01m0002                               	  .REPEAT NEWMAP [
01m0002                               	        ALU[-1] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Disable mapping.
01m0002                               	           ]
01m0002                               	[
01m0002 07465 640705200741000440000000	        ALU[-1] DEST[MAP-DISABLE] NORM $
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

01m0002                               	          ;Disable mapping.
01m0002                               	           ]  .REPEAT 1 - NEWMAP [
01m0002                               	        DEST[CLR-DEV-FROM-INTR] SHORT $
01m0002                               	        START-IN D[CONST 1] DEST[DEV-ADR] PUSHJ[MAPOFF] $
01m0002                               	        MAPF[10] D[CONST VCDEV] DEST[DEV-ADR] C800 $
01m0002                               	         ]
01m0002 07466 640700060171100010000000	        D[14] ROT[32.] MASK[1] DEST[Q] NORM $
01m0002 07467 640701214435000070000000	        D[CONST 7] ALU[D+Q] DEST[ROTR] NORM $ ;byte length to rotate and
01m0002 07470 640701414435000070000000	        D[CONST 7] ALU[D+Q] DEST[MASKR] NORM $ ;mask registers.
01m0002 07471 640700014171000000000000	        D[CONST 0] DEST[Q] NORM $ ;Q contains last-byte flag, initially 0.
01m0002 07472 640701400551000443000000	        ALU[AC] DEST[6] SPEC[DEST-A-MEM] NORM $ ;Save AC and PC for scratching.
01m0002 07473 640701620571000443000000	        D[PC] DEST[7] SPEC[DEST-A-MEM] NORM $
01m0002 07474 640704644571000440000000	        D[11] DEST[PC] NORM $ ;PC gets current MA.
01m0002 07475 640700051571000440000000	        D[12] DEST[AC] NORM $ ;AC gets (negative) byte count.
01m0002 07476 640700055421100070000000	        D[13] ROT[32.] MASK[7] ALU[D+AC] DEST[AC] NORM $ ;Add burst count,
01m0002                               	        ALU[AC] DEST[2] SPEC[DEST-A-MEM]
01m0002 07477 511140400551000443000000	                COND[OBUS<0] JUMP[VCBRST] CYLEN[C550] $ ;check for overflow.
01m0002 07500 640700055463100070000000	        D[13] ROT[32.] MASK[7] ALU[AC-D] DEST[AC] NORM $
01m0002                               	;               Ov.  AC gets bytes remaining.
01m0002 07501 640140414571000003000000	        D[CONST 0] DEST[2] SPEC[DEST-A-MEM] JUMP[VCLP] NORM $ ;Clear byte count.
01m0002                               	
01m0002 07502 640700055473100070000000	VCBRST: D[13] ROT[32.] MASK[7] ALU[0-D] DEST[AC] NORM $ ;No. ov.  AC_ burst ct.
01m0002                               	
01m0002 07503 640040000571000440000000	VCLP:   PUSHJ[VCWRD] NORM $ ;Output a word.  If mode 1 or 2 and not last byte,
01m0002                               	;               loop on these two instructions.
01m0002                               	        MAPF[3] D[13] MASK[1] ALU[DORQ] COND[OBUS=0] JUMP[VCLP]
01m0002 07504 010140054575000010037503	                LONG $
01m0002                               	;               go to VCDONE if last byte.
01m0002 07505 530140000555000440000000	        ALU[Q] COND[-OBUS=0] JUMP[VCDONE] CYLEN[C550] $
01m0002                               	;
01m0002                               	;               Mode 3.  Pull high 4 bits of the odd byte.
01m0002 07506 640704404571010040000000	        D[MEM] ROT[4] MASK[4] DEST[HOLD] NORM $
01m0002                               	;               Shift them to proper place in Q and fetch next word.
01m0002 07507 640720004171010440600000	        SPEC[MA_PC] D[MEM] ROT[4] DEST[MA Q] NORM $
01m0002 07510 640706000550400440020000	        FIXM1 $
01m0002 07511 640704404571010440000000	        D[MEM] ROT[4] DEST[HOLD] NORM $ ;Low bits of odd byte to low end.
01m0002                               	;               Check whether this is the last byte of the burst.
01m0002 07512 531140001413000440000000	        ALU[AC+1] DEST[AC] COND[-OBUS<0] JUMP[VCLST] CYLEN[C550] $
01m0002                               	;               No.  Put it out.
01m0002 07513 640702204575000043600000	        SPEC[IOB-OUT] D[MEM] MASK[4] ALU[DORQ] DEST[IOD] NORM $
01m0002                               	;               Set up byte count for second word.
01m0002 07514 440740054571106030030000	        MAPF[3] D[13] ROT[35.] MASK[3] LLOAD CYLEN[IOB-OUT] $
01m0002                               	;               Clear last-byte flag, put out second word.
01m0002 07515 640040014171000000000000	        D[CONST 0] DEST[Q] PUSHJ[VCWRD1] NORM $
01m0002                               	;               Loop for next double word if not end of burst.
01m0002 07516 010140000555000440037503	        MAPF[3] ALU[Q] COND[OBUS=0] JUMP[VCLP] LONG $
01m0002                               	;               End of burst.  Save updated MA and restore AC and PC.
01m0002 07517 640700220571000443030000	VCDONE: MAPF[3] D[PC] DEST[1] SPEC[DEST-A-MEM] NORM $
01m0002 07520 640702214571000103600000	        SPEC[IOB-OUT] D[CONST 10] DEST[IOD] NORM $ ;Enable interrupt
01m0002 07521 440704674571000440040000	        MAPF[4]D[17] DEST[PC] CYLEN[IOB-OUT] $
01m0002                               	  .REPEAT NEWMAP [
01m0002                               	        ALU[0] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Enable mapping.
01m0002                               	         ]
01m0002                               	[
01m0002 07522 640705200615000440000000	        ALU[0] DEST[MAP-DISABLE] NORM $
01m0002                               	          ;Enable mapping.
SLOE   Jan ***, 1859 00:00:03  file DSK:VC.SLO  --  of -- f2x

01m0002                               	         ]  .REPEAT 1 - NEWMAP [
01m0002                               	        D[IR] MASK[3] DEST[IOD] NORM $
01m0002                               	        ALU[0] DEST[DEV-ADR] SPEC[IOB-OUT] NORM $
01m0002                               	        MAPF[10] D[CONST VCDEV] DEST[DEV-ADR] C800 $
01m0002                               	         ]
01m0002 07523 640142471571000440002026	        D[16] DEST[CLR-DEV-FROM-INTR AC] JUMP[MAIN] NORM $
01m0002                               	;               Odd byte is the last.  Put it out with the last-byte bit on.
01m0002 07524 640700014175104010000000	VCLST:  D[CONST 1] ROT[34.] ALU[DORQ] DEST Q NORM $
01m0002 07525 640142204575000043607517	        SPEC[IOB-OUT] D[MEM] MASK[4] ALU[DORQ] DEST[IOD] JUMP[VCDONE] NORM $
01m0002                               	
01m0002                               	; Subroutine to output one word.  Instruction following call must have
01m0002                               	; MAPF[3] CYLEN[IOB-OUT].
01m0002                               	;
01m0002                               	;               Entry for modes 1 and 2, and first word of a pair for
01m0002                               	;               mode 3.  Set loop count to bytes/word.
01m0002 07526 640760054571106030600000	VCWRD:  SPEC[MA_PC] DEST[MA] D[13] ROT[35.] MASK[3] LLOAD NORM $
01m0002 07527 640706000550400440020000	        FIXM1 $
01m0002                               	;               Second entry for other word in mode 3 (it's been fetched).
01m0002                               	;               Add bytes/word to bytes remaining.
01m0002                               	VCWRD1: SPEC[PC+1] D[13] ROT[35.] MASK[3] ALU[D+AC] CARRY DEST[AC]
01m0002 07530 511140055423106032000000	                COND[OBUS<0] JUMP[VCOUT1] CYLEN[C550] $
01m0002                               	;               Overflow.  Change loop count to bytes remaining.
01m0002 07531 640740055523106030000000	        D[13] ROT[35.] MASK[3] ALU[D-AC] DEST[AC] LLOAD NORM $
01m0002                               	;               Set last-byte flag in Q.
01m0002 07532 640140014171104010000000	        D[CONST 1] ROT[34.] DEST[Q] JUMP[VCOUT1] NORM $
01m0002                               	;               This two-instruction loop puts out all but the last byte.
01m0002 07533 000042204571001000000000	VCOLP:  D[MEM] MASK[R] DEST[IOD] PUSHJ[VCODLY] LONG $
01m0002 07534 000244404571200440037533	VCOUT1: MAPF[3] D[MEM] ROT[R] DEST[HOLD] LOOP[VCOLP] LONG $
01m0002                               	;               Last byte here, with the flag bit set if end of burst.
01m0002 07535 000702204575001000000000	        D[MEM] MASK[R] ALU[DORQ] DEST[IOD] LONG $
01m0002 07536 000700000571000440000000	VCODLY: NOP LONG $
01m0002 07537 000300000571000443600000	        SPEC[IOB-OUT] POPJ LONG $
01m0002                               	

SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

45m0164                               	
45m0164                               	]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

46m0164                               	; dsk stuff
46m0164                               	
46m0164                               	;a-mem useage:
46m0164                               	;       0       dispatch addr for interrupts
46m0164                               	;       1       pi chn (33: 35) and intrpt waiting flag (32)
46m0164                               	;       2       copy of last cmd sent to controller (by opcode 721)
46m0164                               	
46m0164                               	        .OPCODE[740]     [XLIST 
46m0164                               	        .ENDORG
46m0164       7540	 [TYMFOO = .
46m0165                               	]       :INST-DISP + 2 * 740
46m0165                               	        .DEFINE .ENDORG [] [ LASTORG = .
46m0165                               	];.ENDORG
46m0164                               	 LIST            ];disk pseudo-iot dispatch table entries.
46m0164                               	
46m0164                               	 ; dcono -- 740
46m0164 03700 640701614571000100000000	        d[const 10] dest[dev-adr] short $
46m0164 03701 640140234571000033000000	        d[ir] mask[3] dest[1] DEST-A-MEM norm jump[dcno1]$
46m0164                               	; dconi -- 741
46m0164 03702 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0164 03703 662104200571000440002032	        d[ar] dest[memsto] memst  [COND[-MA-AC] LBJUMP[MSMAIN] NORM ]$ ;store them and
46m0164                               	 return.
46m0164                               	; dconso -- 742
46m0164 03704 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0164 03705 530100010635000220000000	        d[mask 22] alu[d&q] c550 cond[-obus=0] lbjump[dskp1] $
46m0164                               	; dconsz -- 743
46m0164 03706 640041614571000100000000	        d[const 10] dest[dev-adr] norm pushj[dcni1] $ ;get bits.
46m0164 03707 510100010635000220000000	        d[mask 22] alu[d&q] c550 cond[obus=0] lbjump[dskp1] $
46m0164                               	
46m0164                               	        .RELOC
46m0164                               	 [.USE[TYMFOO]
46m0164                               	 [ XLIST
46m0164                               	        .ENDORG
46m0164       3710	 [ LASTORG = .
46m0165                               	]       :TYMFOO
46m0165                               	        .DEFINE .ENDORG [] [TYMFOO = .
46m0165                               	];.ENDORG
46m0165                               	        .DEFINE .RELOC [] [.USE[TYMFOO]
46m0165                               	];.RELOC
46m0165                               	 LIST ]]
46m0165 07540 550140034571000030002026	dcno1:  d[ir] mask[3]  c500 cond[obus=0] jump[main] $
46m0165                               	         ; if assigned pi channel is not 0, then
46m0165                               	         ;  enable interrupt on "not active", by
46m0165                               	         ;  re-loading last cmd with 10 bit on.
46m0165 07541 640700014171000200000000	        D[CONST 20] DEST[Q] NORM $
46m0165 07542 510140034635000440000000	        D[IR] ALU[D&Q] C550 OBUS=0 JUMP[DCNO2] $
46m0165 07543 640140014171000400000000	        D[CONST 40] DEST[Q] NORM JUMP[DCNO3] $
46m0165 07544 640700014171000100000000	DCNO2:  d[const 10] dest[q] short $
46m0165 07545 640702250575000443600000	DCNO3:  d[12] alu[dorq] dest[iod] spec[iob-out] norm $
46m0165 07546 440140000571000440042026	        mapf[4] cylen[iob-out] jump[main] $
46m0165                               	
46m0165 07547 640710044171000440000000	dcni1:  d[11] dest[q ar] norm $ ;get intrpt flag and pi chn
46m0165 07550 640300034235000440000000	        d[ir] alu[d&q] dest[q] norm popj $ ;this is for conso, z
46m0165                               	
46m0165                               	        .ORG[2156]       [ XLIST
46m0165                               	        .ENDORG
46m0165       7551	 [TYMFOO = .
SLOE   Jan ***, 1859 00:00:03  file STRING:  --  of -- f2x

46m0166                               	]       :2156
46m0166                               	        .DEFINE .ENDORG [] [LSTORG = .
46m0166                               	];.ENDORG
46m0165                               	 LIST ];$*$*$ 
46m0165                               	
46m0165                               	        ;interrupts from disk (dev 10) come here.
46m0165 02156 640142250571000443600000	        d[12] dest[iod] spec[iob-out] norm jump[dskint] $
46m0165                               	          ;clear interrrupt enable bit (amem[2] has last cmd)
46m0165                               	
46m0165                               	        .RELOC
46m0165                               	 [.USE[TYMFOO]
46m0165                               	 [ XLIST
46m0165                               	        .ENDORG
46m0165       2157	 [LSTORG = .
46m0166                               	]       :TYMFOO
46m0166                               	        .DEFINE .ENDORG [] [TYMFOO = .
46m0166                               	];.ENDORG
46m0166                               	        .DEFINE .RELOC [] [.USE[TYMFOO]
46m0166                               	];.RELOC
46m0166                               	 LIST ]]        .PAIR
46m0166                               	 [:. \ 2 + .
46m0167                               	];$*$*$ This exists elsewhere by another name.  TVR-Apr80
46m0167 07552 640140000571000440002026	dskp1:  jump[main] norm $       ;conso and consz lbjump to here.
46m0167 07553 640164620433000440002027	        doskip $
46m0167                               	
46m0167 07554 510150044171000440040000	dskint: mapf[4] d[11] dest[q ar] c550 cond[obus=0] jump[ddis] $
46m0167                               	        d[const 10] alu[dorq] dest[1] DEST-A-MEM norm
46m0167 07555 640140214575000103004562	                jump[pigen] $ ;set flag and request intrpt.
46m0167 07556 640142400571000440002026	ddis:   dest[clr-dev-from-intr] norm jump[main] $
46m0167                               	
46m0167 07557 640151614571000100000000	DSKWT1: D[CONST 10] DEST[DEV-ADR AR] NORM JUMP[DSKWT4] $
46m0167 07560 511140004571076440000000	DSKWT3: D[MEM] ROT[31.] C550 COND[OBUS<0] JUMP[DSKWDN] $
46m0167 07561 640740014571014010000000	        D[CONST 1] ROT[6] LLOAD NORM $
46m0167 07562 500240000571000440007562	        C550 LOOP[.] $
46m0167 07563 640700000571000443400000	DSKWT4: START-IN NORM $
46m0167 07564 240144430571000440007560	        MAPF[0] D[IOD] DEST[HOLD] C800  JUMP[DSKWT3] $
46m0167 07565 530150000531000440007563	DSKWDN: D[AR] ALU[D-1] DEST[AR] C550 COND[-OBUS=0] JUMP[DSKWT4] $
46m0167 07566 000140000571000440002026	        JUMP[MAIN] $
46m0167                               	
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

47m0167                               	
47m0167                               	;
47m0167                               	;ECC logging area
47m0167                               	;
47m0167                               	.REPEAT 1 - XUCODE [
47m0167                               	: 7760
47m0167                               	];.REPEAT 1 - XUCODE
47m0167                               	.REPEAT XUCODE [
47m0167                               	: 17760
47m0167                               	];[
47m0167                               	: 17760
47m0167                               	].REPEAT XUCODE
47m0167                               	
47m0167                               	 .REPEAT 20 [NOP $
47m0167                               	]
47m0167 17760 000700000571000440000000	[NOP $
47m0167 17761 000700000571000440000000	][NOP $
47m0167 17762 000700000571000440000000	][NOP $
47m0167 17763 000700000571000440000000	][NOP $
47m0167 17764 000700000571000440000000	][NOP $
47m0167 17765 000700000571000440000000	][NOP $
47m0167 17766 000700000571000440000000	][NOP $
47m0167 17767 000700000571000440000000	][NOP $
47m0167 17770 000700000571000440000000	][NOP $
47m0167 17771 000700000571000440000000	][NOP $
47m0167 17772 000700000571000440000000	][NOP $
47m0167 17773 000700000571000440000000	][NOP $
47m0167 17774 000700000571000440000000	][NOP $
47m0167 17775 000700000571000440000000	][NOP $
47m0167 17776 000700000571000440000000	][NOP $
47m0167 17777 000700000571000440000000	][NOP $
47m0167                               	]
SLOE   Jan ***, 1859 00:00:03  file DSK:CFNEW.SLO  --  of -- f2x

48m0167                               	;; this should be after everything else
48m0167                               	: 0
48m0167 00000 000140000571000440004000	        JUMP[MSTART] $          ;Auto-load micro code tapes someday.
48m0167                               	

SLOE   Jan ***, 1859 00:00:03  file DSK:F2X.SLO  --  of -- f2x

01m0044                               	
01m0044                               	LIST-LABELS

labels
  0   38     0 .               10   21  3103 ACBI1            4    2  2212 ADJSP
 41  161  5002 ADJSP1          41  161  5010 ADJSP2          17  104  2763 ANDCA1          17  104  2764 ANDCA2
 17  104  2765 ANDCA3          30  142  4701 APDINT          30  146  4715 APIOT           30  142  4671 APRC1
 30  142  4672 APRC2           30  142  4673 APRCHK          30  142  4702 APRCI           30  142  4702 APRCII
 30  142  4674 APRCK1          30  142  4647 APRCO           30  142  4656 APRCO2          30  142  4661 APRCO3
 30  145  4713 APRDI           30  141  5300 APRDSP          30  142  4662 APRIEN          20  138  4523 APRRST
  4    2  2161 AREA216          9   15  2602 AREA260          9   15  2623 AREA262          9   15  2642 AREA264
  9   15  2665 AREA266          9   15  2702 AREA270          9   16  2742 AREA274         12   47  3426 AREA342
 12   49  3444 AREA344         12   49  3470 AREA346         12   51  3504 AREA350         12   51  3526 AREA352
 12   53  3544 AREA354         12   53  3566 AREA356         19  134  5140 AREA51          19  136  3572 AREA52
 16   92  4223 ASHC1           16   92  4241 ASHC2           16   92  4235 ASHC4           16   92  4232 ASHC6
 16   93  4244 ASHC7           16   92  4230 ASHC8           16   92  4234 ASHC9           16   92  4203 ASHDO
 16   90  2734 ASHDO1          16   92  4207 ASHDOP          16   91  4174 ASHNEG          16   91  4175 ASHNN1
 16   91  4172 ASHPLS           9   16  2724 ASOS1            9   16  2722 ASOS2            9   16  2762 ASOS3
 14   59  4023 BADPC           16   92  4221 BIGAS2          16   92  4177 BIGASH          16   90  2725 BIGLSH
 14   68  2651 BII             14   67  2645 BII1            14   68  2654 BII2            14   67  2642 BIIH
 43  162  6641 BITREV          17  103  4255 BLT1            17  103  4264 BLT2            17  103  4263 BLT3
 17  103  4274 BLT4            17  103  4262 BLT5            17  103  4276 BLT6            17  103  4261 BLT7
 17  103  4300 BLT8            17  103  4266 BLT9            17  103  4317 BLTA1           17  103  4331 BLTA10
 17  103  4344 BLTA12          17  103  4254 BLTA2           17  103  4304 BLTA3           17  103  4315 BLTA4
 17  103  4326 BLTAL2          17  103  4312 BLTL1           17  103  4332 BLTL2           18  112  4450 BRPNT
 25  140  6177 BWRTA1           1    6 10275 CCLR            20  138  4510 CLKCLR          32  150  6213 CLKINT
 32  150  6216 CLKRDFLG        20  138  4510 CLKRST          20  138  4525 CLRDEVINT       18  112  4425 CONSW
 19  136  5235 CTYCI           19  136  5241 CTYCI1          19  136  5240 CTYCI2          19  136  5251 CTYCI3
 19  136  5247 CTYCI8          19  136  5245 CTYCI9          19  136  5233 CTYCO           19  136  5252 CTYCO1
 19  136  5256 CTYCO3          19  136  5261 CTYCO4          19  136  5266 CTYCO5          19  138  4472 CTYCS
 19  138  4470 CTYCZ           19  136  5213 CTYDI           19  136  5222 CTYDO           19  134  5100 CTYDSP
 19  134  2144 CTYIN1          19  134  2130 CTYINT          19  135  5211 CTYIOT          19  136  3566 CTYRS1
 19  136  5270 CTYRST           1    6 10330 D1               1    2 10052 DCG1             1    2 10047 DCGO
  1    2 10071 DCGRD            1    2 10066 DCGWR           46  165  7547 dcni1           46  165  7540 dcno1
 46  165  7544 DCNO2           46  165  7545 DCNO3           46  167  7556 ddis            18  112  4436 DEPNSW
 18  112  4437 DEPSW1          18  112  4435 DEPTSW          43  162  6740 DEV6CL          43  162  6741 DEV6ST
 43  162  6742 DEV6ST1         43  162  6743 DEV6ST2          4    3  2262 DFN             40  157  6262 DFN1
 15   77  4126 DIV1            15   79  4132 DIV2            15   81  4136 DIV3             7   10  2471 DIV9
  1    1  7231 DLS.DEB          1    1  7344 DLS.EINT         1    1  7324 DLS.INT          1    1  7235 DLS.RCR1
  1    1  7244 DLS.RCR2         1    1  7271 DLS.READ         1    1  7262 DLS.RHOLD        1    1  7331 DLS.RINT
  1    1  7253 DLS.RSTAT        1    1  7231 DLS.SETLIN       1    1  7274 DLS.WCR1         1    1  7302 DLS.WCR2
  1    1  7316 DLS.WHOLD        1    1  7310 DLS.WSTAT        6    1  7070 DLSBAD           4    1  7032 DLSBLKI
  5    1  7037 DLSBLKO          7    2  7202 DLSCH0           7    2  7121 DLSCINT          7    2  7125 DLSCINT1
  6    1  7070 DLSCNISV         6    1  7066 DLSCNO1          4    1  7032 DLSDI1           4    1  7036 DLSDI2
  3    1  6767 DLSDISP2         5    1  7037 DLSDO1           7    2  7227 DLSIGNORE        7    2  7153 DLSINT
  7    2  7163 DLSINT1          3    1  7027 DLSIOT           5    1  7044 DLSNTHIS         5    1  7065 DLSOFF
  5    1  7051 DLSOUT           7    2  7226 DLSRCVIGN        7    2  7203 DLSRCVINT        7    1  7071 DLSRST
  5    1  7045 DLSSCNR          7    2  7135 DLSSCR1          7    2  7144 DLSSCR2          5    1  7043 DLSTHIS
  4    3  2240 DMOVE           41  161  5015 DMOVE2           4    3  2250 DMOVEM          41  162  5026 DMOVM2
  4    3  2242 DMOVN           41  161  5020 DMOVN2           4    3  2252 DMOVNM          41  162  5031 DMVNM2
 41  162  5034 DMVNM3          41  162  5035 DMVNM4          41  162  5036 DMVNM5          15   83  4142 DODDIV
 15   83  4147 DODIV           15   83  4151 DODIV1          15   83  4155 DODIV2          15   83  4154 DODIV3
 15   85  2164 DODIV4          15   85  2172 DODIV5          15   85  2170 DODIV6          18  106  4366 DOHALT
 15   70  4055 DOIMUL          15   70  4062 DOMMUL          15   70  4066 DOMUL           15   70  4067 DOMUL1
 15   71  4074 DOMUL4           9   15  2622 DOSKP1           5    3  2276 DPB             14   63  2636 DPB1
 14   66  2671 DPB2            14   66  2672 DPB4            14   63  2637 DPB5            14   64  4024 DPB7
 46  167  7554 dskint          46  167  7552 DSKP1           20  138  4474 DSKRST          46  167  7565 DSKWDN
 46  167  7557 DSKWT1          46  167  7560 DSKWT3          46  167  7563 DSKWT4          31  150  6206 ECC-UNC
 23  138  4647 END-OF-PI-CODE  18  112  4443 EXMNSW          18  112  4445 EXMSW1          18  112  4442 EXMTSW
 40  159  6430 EXPUF           43  173  6725 F5DIAG           5    3  2300 FAD             40  159  6433 FADSU1
 40  159  6432 FADSUB          40  157  6300 FAOS1           40  157  6302 FAOS2           40  157  6304 FAOS3
 40  157  6310 FAOS4           40  157  6300 FAOS5           40  161  6541 FD              40  157  6324 FD1
 40  157  6327 FD2             40  157  6341 FD2A            40  159  6363 FD2C            40  159  6362 FD2D
 40  159  6364 FD3             40  159  6367 FD4             40  161  6574 FDAD            40  161  6534 FDS
 40  161  6535 FDS1            40  161  6556 FDSHFT           5    3  2360 FDV             41  162  5063 FIXER
 41  162  5071 FIXER1          41  162  5072 FIXER2          41  162  5074 FIXER3           4    3  2254 FIXR
 41  162  5044 FIXR1           41  162  5056 FIXR2           41  162  5050 FIXRN            4    3  2256 FLTR
 41  162  6576 FLTR1           40  160  6511 FM              40  160  6514 FM1             40  160  6517 FM2
  1    2 10031 FMNBW1           1    2 10030 FMNBWT           5    3  2340 FMP             40  157  6312 FMP1
 40  157  6314 FMP2            40  157  6316 FMP3            40  157  6322 FMP4            40  157  6312 FMP5
  1    2 10036 FMTHNG          40  160  6502 FPLOW           40  160  6464 FPNAR           40  159  6372 FPNDIV
 40  159  6435 FS1             40  159  6440 FS2             40  159  6445 FS3             40  160  6457 FS4
 40  160  6461 FS5              5    3  2320 FSB              4    3  2264 FSC             40  157  6270 FSC1
 40  157  6274 FSC2            40  157  6267 FSCZAP          38  151  6224 GOHIGH          38  154 10346 GOLOW
 38  154 10344 GOMAIN           1    6 10336 GOMSTART        18  125  3474 HHS             38  154 10342 HIGHSMAIN
 18  114  3427 HLAR            18  114  3430 HLLEM1          18  120  3454 HLLES1          18  123  3470 HLLES2
 18  129  3533 HLLM1           18  118  3450 HLLOS1          18  113  2774 HLLZS1          18  114  3432 HLREM1
 18  129  3534 HLRM1           18  113  2777 HLRZS1          18  127  3526 HLSZ            18  124  3472 HMV
 18  128  3531 HOL             18  127  3527 HOR             18  114  3426 HRAR            18  114  3431 HRLEM1
 18  129  3532 HRLM1           18  113  2775 HRLZS1          18  114  3433 HRREM1          18  121  3456 HRRES1
 18  129  3535 HRRM1           18  119  3452 HRROS1          18  113  2776 HRRZS1          18  128  3530 HRSZ
 18  116  3444 HSMAIN          18  117  3446 HSMN1            5    3  2266 IBP             14   70  4032 IBP1
 14   70  4035 IBT1            15   71  4076 IDIV1           15   73  4106 IDIV2           15   75  4116 IDIV3
  7   10  2461 IDIV9            5    3  2274 IDPB            14   61  2610 IDPB1           14   61  2614 IDPB2
 14   66  2666 IDPB3            5    3  2270 ILDB            14   60  2602 ILDB1           14   60  2606 ILDB2
 14   61  2616 ILDB3           15   70  4037 IMUL1           15   70  4041 IMUL2           15   70  4044 IMUL3
 40  159  6422 INSEX1          40  159  6421 INSEXP          18  133  3546 JFCL1           16   86  4162 JFFO1
 16   86  4163 JFFO2           16   86  4166 JFFO3           16   86  4171 JFFO4           16   86  4167 JFFO5
 18  133  3555 JRA1            18  131  3504 JRST1           18  132  3515 JRST2           18  133  3544 JRST3
 18  131  3507 JRST4           18  131  3510 JRST5           18  131  3514 JRST8           18  131  3513 JRST9
 18  133  3553 JSA1            27  141  5551 JSMFR            8   13  2553 JSP1            18  133  3551 JSR2
  4    2  2210 JSYS            28  141  5635 JSYS1           28  141  5642 JSYS2            4    2  2211 JSYS3
 41  162  5042 KAFIXN          41  162  5040 KAFIXP           4    3  2244 KIFIX           41  162  5055 KIFIX1
 41  162  5060 KIFIXN           1    1 10001 KNYCLR           1    2 10023 KNYGOA           1    3 10163 KNYMTP
  1    2 10017 KNYRGO           1    1 10001 KNYRS1           1    6 10316 KNYW1            1    6 10314 KNYWAIT
  5    3  2272 LDB             14   62  2624 LDB1            14   62  2633 LDB2            14   62  2635 LDB4
 14   62  2625 LDB5            17  104  2766 LOG2            17  104  2767 LOG3            19  134  5120 LPTDSP
 16   97  2752 LSHC1           16   99  2735 LSHC2           16   90  2731 LSHDO           16   90  2733 LSHDO1
 16   88  2713 LSHNEG          16   88  2714 LSHNN1          16   90  2726 LSHPDO          16   88  2711 LSHPLS
  4    1  2026 MAIN             4    1  2027 MAIN1            4    1  2030 MAIN2           25  140  5147 MAPCO0
 26  141  5363 MAPCO1          26  141  5400 MAPCO4          26  141  5405 MAPCO6          26  141  5407 MAPCO7
 26  141  5356 MAPCOA          25  140  5170 MAPCOB          25  140  5171 MAPCOC          26  141  5360 MAPCOE
 26  141  5367 MAPCOG          25  141  5344 MAPCW1          25  141  5345 MAPCW2          26  141  5412 MAPCW9
 25  141  5340 MAPCWT          26  141  5414 MAPDO           25  140  5145 MAPIO1          25  140  5141 MAPIOT
 26  141  5402 MAPOFF          27  141  5625 MAPRSL          27  141  5624 MAPRSS          27  141  5622 MAPRST
 25  140  6201 MBLT2           25  140  6126 MBLT3            1    6  5000 MBOOT            1    7  6220 MBOOTA
  1    6 10260 MBOOTH           1    6 10303 MBTBY1           1    6 10311 MBTBY2           1    6 10302 MBTBYTE
  1    6 10313 MBTBYX           1    6 10322 MBTCHECK         1    6 10326 MBTDNX           1    6 10340 MBTERR
 26  141  5444 MFA1            26  141  5452 MFA2            26  141  5426 MFA3            26  141  5433 MFA4
 27  141  5520 MFA5            26  141  5432 MFA6            26  141  5427 MFA7            26  141  5456 MFB3
 27  141  5561 MFB4            27  141  5561 MFB5            27  141  5573 MFC1            26  141  5443 MFHIEX
 25  140  6111 MFOTH           25  140  6110 MFRD            25  140  6104 MFT1            25  140  6105 MFT1A
 26  141  5437 MFT1B           25  140  6106 MFT1D           27  141  5554 MFTR1           27  141  5557 MFTR10
 27  141  5604 MFTR2           27  141  5605 MFTR3           27  141  5607 MFTR4           27  141  5620 MFTR41
 27  141  5607 MFTR5           27  141  5610 MFTR6           27  141  5616 MFTR7           27  141  5617 MFTR9
 26  141  5475 MFTYP0          26  141  5473 MFTYP1          26  141  5423 MFUS             6    3  2400 MOVE
  6    3  2401 MOVE1            6    3  2402 MOVEI            6    3  2404 MOVEM            6    3  2406 MOVES
  6    3  2430 MOVM             6    4  2142 MOVM1            6    4  2432 MOVMI            6    4  2434 MOVMM
  6    4  2436 MOVMS            6    6  2042 MOVMS1           6   10  2054 MOVMS2           6    7  2044 MOVMS3
  6    8  2046 MOVMS4           6    9  2050 MOVMS5           6   10  2052 MOVMS6           6    3  2420 MOVN
  6    3  2422 MOVNI            6    3  2424 MOVNM            6    3  2426 MOVNS           18  113  2773 MOVNS1
  6    3  2410 MOVS             6    3  2412 MOVSI            6    3  2414 MOVSM            6    3  2416 MOVSS
 18  113  2772 MOVSS1          26  141  5401 MPOFF1          15   70  4060 MSETOV           4    1  2032 MSMAIN
  4    1  2033 MSMAIN1         14   58  4000 MSTART          15   70  4061 MSTOV1          14   59  4001 MSTRT1
 27  141  5605 MTRPAL          18  134  4460 MUJSA           18  134  4464 MUJSM1          18  134  4456 MUJSP
 18  134  4453 MUJSR           18  134  4462 MUJSYS          15   70  4046 MUL1            15   70  4050 MUL2
 15   70  4052 MUL3             4    1  2100 MUUO             4    2  2101 MUUO2            4    2  2103 MUUO3
  4    2  2105 MUUO4            4    2  2106 MUUO44           4    2  2120 MUUO5X           4    2  2124 MUUO5Y
  0   38     0*NAF              1    2 10040 NCNTW1           1    2 10040 NCNTWT          40  159  6404 NEGNOR
  4    1  2027 NMAIN1          40  159  6407 NN1              3    1     0*no-@            40  159  6412 NORMOV
 40  160  6476 NORND           18  105  2071 NORSW           18  106  4411 NORSW2          18  105  2073 NOSW
 40  159  6417 NOVNO           40  159  6415 NOVYES          40  159  6375 NRMLIZ          10   23  3133 OCAI1
 10   24  3163 OCBI1           10   24  3153 OCMI1           17  104  2770 ORCM2           17  104  2771 ORCM3
  1    6 10267 P2               1    6 10270 P2A             31  148  4734 PDLMEM          31  148  4736 PDLO
 31  147  4717 PDLO1           31  147  4722 PDLO2           31  147  4724 PDLO3           31  147  4727 PDLO4
 31  147  4723 PDLO5           31  147  4732 PDLO6           31  148  4735 PDLOE           21  138  4534 PI-CHECK-RQS
 22  138  4603 PI-DISMISS      21  138  4526 PI-GET-CHN      23  138  4644 PI-RESET        23  138  4637 PICONISUB
 23  138  4606 PICONO          30  141  5320 PIDSP           22  138  4562 PIGEN           22  138  4567 PIGEN1
 22  138  4574 PIGENWT         21  138  4532 PIGETMASK       21  138  4553 PIINTGO         21  138  4530 PIL1
 21  138  4554 PIL11           23  138  4622 PIL3            23  138  4624 PIL4            23  138  4626 PIL5
 23  138  4630 PIL6            23  138  4613 PIL7            23  138  4615 PIL8            23  138  4617 PIL9
  4    2  2105 PIMUUO          16  102  4247 POP1            16  102  4252 POPJ1           40  159  6401 POSNOR
 16  102  4245 PUSH1           16  102  4253 PUSHJ1          25  140  6147 QORCRY          18  106  4350 RESET
 18  106  4353 RESLOP          18  106  4345 RESW1           18  112  4420 RESW2           16   94  2742 ROTC1
 16   95  2747 ROTC2           16   88  2707 ROTDO           16   87  2704 ROTNEG          16   87  2705 ROTNN1
 16   87  2702 ROTPLS          20  138  4501 SDSKO2          31  149  6042 SECCS           20  138  4477 SET-DSK-OUT
 40  159  6427 SETFOV          25  140  6152 SETHFU          25  140  6146 SETHLF          18  112  4444 SETLTS
 10   17  3030 SETM            16   92  4202 SETOV1          16  101  2034 SJMAIN           9   15  2663 SKIPX1
 12   47  3424 SKMAIN           4    1  2024 SMAIN            4    1  2025 SMAIN1          31  149  6072 SOEDOV
 31  149  6036 SOVRS           31  149  6035 STOPS           18  106  4367 STPLOP          18  106  4403 STPLP1
  1    2 10045 STRTDC          18  112  4424 STRTSW          18  105  2062 SWINT           38  151  6222 TAPDSP
  1    3 10171 TAPEBR           1    3 10170 TAPEFR           1    3 10143 TAPEMT           1    4 10225 TAPENR
  1    2 10005 TAPERD           1    3 10202 TAPERS           1    3 10167 TAPERW           1    5 10227 TAPERX
  1    5 10235 TAPEWR          20  138  4514 TAPRST          44  164  6755 TCNI1           44  164  6753 TCNO1
 44  164  6757 TDATO           12   51  3525 TDC1            12   53  3565 TDO1            44  164  6763 TDTI
 12   49  3466 TDZ1            12   49  3467 TDZ2             1    3 10161 TERAS1           1    3 10162 TERASE
 40  161  6532 TESMUL          13   55  3740 TIMER-IOTS      44  163  6745 TIMINT          20  138  4517 TIMRST
 12   45  3416 TLC1            12   43  3412 TLO1            12   41  3406 TLZ1            43  162  6637 TNCASODOF
 43  162  6602 TNI             43  162  6614 TNI0            43  162  6615 TNI1            43  162  6622 TNI2
 43  167  7627 TNIC0           43  170  6646 TNIC0A          43  170  6650 TNIC0B          43  170  6654 TNIC0C
 43  168  7642 TNIC1           43  169  7651 TNIC2           43  170  6642 TNICDN          43  167  7637 TNICRM
 43  162  6636 TNIRF           43  162  7600 TNOC0           43  163  7602 TNOC0A          43  164  7611 TNOC2
 43  162  6633 TNORE           43  162  6634 TNRCW            1    5 10233 TNRP3           43  162  6624 TNSEND
 43  170  6666 TNSI            43  171  6673 TNSO             1    3 10200 TPCLRNK          1    2 10010 TPINIT
  1    2 10112 TPMAOK           1    3 10174 TPSETDMP         1    3 10172 TPSETIND         1    3 10176 TPSETNK
 12   44  3414 TRC1             1    2 10102 TRCHA            1    2 10100 TRCHECK          1    2 10101 TRCHKB
  1    2 10126 TRCRET           1    2 10135 TRCX             1    2 10104 TRDONE           1    2 10136 TREOF
  1    2 10137 TRERR           12   42  3410 TRO1             1    2 10075 TRP2            12   40  3404 TRZ1
 12   49  3465 TSZ2             1    5 10253 TWER1            1    5 10250 TWERR            1    3 10160 TWREOF
  1    5 10236 TWRTRY          43  173  6711 TYMAREA         43  170  6655 TYMCLK          43  173  6716 TYMNIN
 43  173  6713 TYMNOUT         43  173  6711 TYMNRESET       43  173  6704 TYMRS1          43  173  6705 TYMRS2
 20  138  4506 TYMRST           4    2  2125 UAOP            20  138  4502 UDSKST           4    3  2260 UFA
 40  157  6256 UFA1            40  160  6477 UFANOR           4    2  2200 UMOVE           28  141  5656 UMOVX
  1    5 10234 UTAPWR           4    1  2076 UUO0-7           4    1  2020 UUO1             4    1  2021 UUO2
  4    1  2060 UUOGO            4    2  2117 UUOPJ            1    2  7502 VCBRST           1    2  7431 VCCMD
  1    2  7517 VCDONE           1    1  7346 VCDSP            1    2  7465 VCGO             1    2  7454 VCGST
  1    1  7416 VCINT            1    1  7423 VCINT2           1    1  7424 VCINT3           1    2  7427 VCIOT
  1    2  7503 VCLP             1    2  7524 VCLST            1    2  7536 VCODLY           1    2  7533 VCOLP
  1    2  7440 VCONO            1    2  7441 VCONO0           1    2  7451 VCONO1           1    2  7452 VCONO2
  1    2  7454 VCONSO           1    2  7454 VCONSZ           1    1  7406 VCORG            1    2  7457 VCOUNT
  1    2  7457 VCOUT            1    2  7534 VCOUT1           1    2  7431 VCRST            1    2  7453 VCSET2
  1    2  7454 VCSTAT           1    2  7526 VCWRD            1    2  7530 VCWRD1          15    2 11166 VID33L
 14    1 11067 VIDCCL          14    1 11054 VIDCCS          14    2 11152 VIDCE1          14    2 11155 VIDCE2
 14    2 11136 VIDCHE          14    1 11007 VIDCHH          14    1 10750 VIDCHI          14    1 11100 VIDCHL
 14    1 11126 VIDCHS           5    1  6254 VIDCOM          15    2 11165 VIDD33          27    8 11673 VIDDIV
 10    1 10636 VIDDON          24    8 11570 VIDDOT          10    1 10433 VIDDPA           7    1 10347 VIDDPI
 10    1 10435 VIDDPO          24    8 11572 VIDDT1          24    8 11576 VIDDT2          24    8 11604 VIDDT3
 27    8 11675 VIDDV1          27    8 11703 VIDDV2          27    8 11704 VIDDVL          11    1 10651 VIDEND
  7    1 10362 VIDHER          22    7 11534 VIDHZL          22    7 11521 VIDHZV           5    1  6245 VIDIN
  7    1 10355 VIDIN1           7    1 10364 VIDIN2           7    1 10366 VIDIN3           7    1 10401 VIDIN4
 11    1 10650 VIDINT          20    2 11344 VIDLL1          20    4 11420 VIDLL2          10    1 10645 VIDMHE
 10    1 10600 VIDMHH          10    1 10557 VIDMHL          10    1 10632 VIDMLE          10    1 10621 VIDMLH
 10    1 10611 VIDMLL          26    8 11665 VIDMUL           9    1 10431 VIDNR1           8    1 10404 VIDNTI
  9    1 10417 VIDNTR           5    1  6250 VIDOUT          16    2 11177 VIDPT1          16    2 11171 VIDPUT
 12    1 10675 VIDRET          12    1 10744 VIDRIE          12    1 10735 VIDRIH          11    1 10652 VIDSAM
 14    1 11017 VIDSC1          14    1 11020 VIDSC2          14    1 11013 VIDSCL          14    2 11160 VIDSCN
 20    4 11411 VIDSL1          20    6 11465 VIDSL2           5    1  6225 VIDTAB          10    1 10476 VIDTD1
 10    1 10466 VIDTDE          10    1 10454 VIDTDL          10    1 10513 VIDTFL          10    1 10510 VIDTNE
 10    1 10500 VIDTNL          20    2 11212 VIDVC1          20    2 11216 VIDVC2          20    2 11224 VIDVC3
 20    2 11234 VIDVC4          20    2 11250 VIDVC5          20    2 11257 VIDVC6          20    2 11266 VIDVCH
 20    2 11206 VIDVCI          23    8 11546 VIDVEN          20    2 11275 VIDVI0          20    2 11304 VIDVI1
 20    2 11313 VIDVI2          20    2 11327 VIDVI3          20    2 11341 VIDVI4          25    8 11645 VIDVL1
 25    8 11652 VIDVL2          25    8 11660 VIDVL3          25    8 11636 VIDVLM          21    6 11507 VIDVRL
 21    6 11474 VIDVRV           1    2 10074 WCDONE          29  141  5775 XBLTL           28  141  5736 XBY1
 28  141  5756 XBY13           28  141  5747 XBY14           28  141  5743 XBY15           28  141  5761 XBY3
 28  141  5741 XBY4            28  141  5662 XCT1            28  141  5730 XCT10           28  141  5712 XCT11
 28  141  5711 XCT12           28  141  5702 XCT13           28  141  5703 XCT18           28  141  5714 XCT2
 28  141  5675 XCT3            28  141  5670 XCT4            28  141  5666 XCT5            28  141  5672 XCT6
 28  141  5715 XCTAC           28  141  5732 XCTBLG          29  141  5774 XCTBLT          28  141  5735 XCTBYT
 28  141  5724 XCTSTK          28  141  5665 XCTUMV          28  141  5713 XDISP           29  141  5770 XFIXMA
  4    3  2041 XMOVEM1         29  141  6017 XPDLO2          29  141  6021 XPOP1           29  141  6032 XPOP2
 29  141  6034 XPOP3           29  141  6010 XPUSH1          40  160  6473 YESRND          40  160  6510 ZLOW

01m0043                               	LIST-CORMAP


			Storage map


     0	X...............................................................
   100	................................................................
   200	................................................................
   300	................................................................
   400	................................................................
   500	................................................................
   600	................................................................
   700	................................................................
  1000	................................................................
  1100	................................................................
  1200	................................................................
  1300	................................................................
  1400	................................................................
  1500	................................................................
  1600	................................................................
  1700	................................................................
  2000	XXXXXXXXXXX.XXXXXXXXXXXXX.XXXX..XXXXXXXXXXXXX...X.XXXXXXXXXX..XX
  2100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXX.....X.X...XXXXXXXXXX..
  2200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2400	XXX.X.XXXXX.XXXXXXX.X.XXXXX.XXXXXXX.XXXXXXX.XXXXXXX.XXXXXXX.XXXX
  2500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  2600	XXXXXXX.XXXXX.XXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXX..
  2700	XXXXXXXXXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXX
  3000	X.X.X.X.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.X.X.XX
  3200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3400	XXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  3500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXXX......
  3600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  3700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.X.
  4000	XXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  4700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX................................
  5000	XXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...
  5100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  5200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  5300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  5700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..
  6100	X...XXXXXX..X...XXXXXXX.XXX.XX..XXXXXXXXXXXXXX..XXXXXXX.X...XXXX
  6200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXX
  6300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  6700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  7500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXX.........
  7600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...............
  7700	................................................................
 10000	XXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10200	XXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 10700	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11000	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11100	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11200	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11300	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11400	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11500	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11600	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
 11700	X..XXXXX........................................................
 12000	................................................................
 12100	................................................................
 12200	................................................................
 12300	................................................................
 12400	................................................................
 12500	................................................................
 12600	................................................................
 12700	................................................................
 13000	................................................................
 13100	................................................................
 13200	................................................................
 13300	................................................................
 13400	................................................................
 13500	................................................................
 13600	................................................................
 13700	................................................................
 14000	................................................................
 14100	................................................................
 14200	................................................................
 14300	................................................................
 14400	................................................................
 14500	................................................................
 14600	................................................................
 14700	................................................................
 15000	................................................................
 15100	................................................................
 15200	................................................................
 15300	................................................................
 15400	................................................................
 15500	................................................................
 15600	................................................................
 15700	................................................................
 16000	................................................................
 16100	X.......X.......................................................
 16200	................................................................
 16300	................................................................
 16400	................................................................
 16500	................................................................
 16600	................................................................
 16700	................................................................
 17000	................................................................
 17100	................................................................
 17200	................................................................
 17300	................................................................
 17400	................................................................
 17500	................................................................
 17600	................................................................
 17700	................................................XXXXXXXXXXXXXXXX
  3837 locations used,  highest used = 17777
%Warn    no-@  is an undefined label 
                                                                                                                                                                                                                                                                                                                                                               